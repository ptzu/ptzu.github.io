<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>解題區 on Ptzu's blog</title><link>https://ptzu.github.io/categories/%E8%A7%A3%E9%A1%8C%E5%8D%80/</link><description>Recent content in 解題區 on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 14 Apr 2018 19:42:12 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/%E8%A7%A3%E9%A1%8C%E5%8D%80/index.xml" rel="self" type="application/rss+xml"/><item><title>Uva 11269 - Setting Problems</title><link>https://ptzu.github.io/posts/uva11269/</link><pubDate>Sat, 14 Apr 2018 19:42:12 +0000</pubDate><guid>https://ptzu.github.io/posts/uva11269/</guid><description>題目
input 多筆測資, 每筆開頭輸入 n (1 &amp;lt;= n &amp;lt;= 20) 代表有 n 道題目 下一列輸入 Sultan 準備這道題目要花多久 再下一列輸入 GolapiBaba 準備這道題目要花多久
題解 Sultan 和 GolapiBaba 想準備 N 道題目 兩人分工準備一道題目, 分別花上不同的時間 Sultan 做完他的部份, GolapiBaba 才可以接著做 每個人都不能同時準備兩道以上的題目 問最少要花多少時間
作法 完全想不到&amp;hellip; 這似乎叫作相鄰交換法 一次考慮兩個任務 a, b 我們想知道 ab, ba 這兩種順序 何者花的時間比較少 若是 a 先做, 花的時間為 a.st + max(a.nd, b.st) + b.nd 反之一樣 排序好之後, 去計算時間即可
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>TIOJ 1072 A.誰先晚餐</title><link>https://ptzu.github.io/posts/tioj1072/</link><pubDate>Sat, 14 Apr 2018 17:02:34 +0000</pubDate><guid>https://ptzu.github.io/posts/tioj1072/</guid><description>題目
input 輸入檔包含多組測試資料，每一組測試資料的第一行有一個整數N (1 ≤ N ≤ 10000)，代表跟小尹去吃飯的人數，接下來的N行每行有兩個以空白字元分隔的整數Ci Ei ( 1 ≤ i ≤ N, 1 ≤ Ci, Ei ≤ 1000)，其中Ci代表烹煮第i個人點的餐點所需要的時間，Ei代表第i個人把他點的餐點吃完所需要的時間。讀到N = 0的時候代表測試檔案的結尾，不需要對於這個數字作任何輸出。
題解 有 N 個人要吃飯 因為有人吃的快，有人吃的慢 每道餐點做的時間也不一樣 老闆只有一個廚具 要如何安排順序 使飯局結束時間最早
作法 由於不管怎麼排，老闆都是一直做菜 所以做完所有餐點的總時間都是一樣的 而結束時間就會是最後一道菜 加上那個人吃的時間 要使結束時間最短 最後一個人必須吃最快
以這樣的想法去 greedy 即可 另外也有可能最早吃的人 吃太久而超過最後一個人 所以每個人吃的時間都要維護最大值
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 11389 - The Bus Driver Problem</title><link>https://ptzu.github.io/posts/uva11389/</link><pubDate>Sat, 14 Apr 2018 16:38:26 +0000</pubDate><guid>https://ptzu.github.io/posts/uva11389/</guid><description>題目
input 多筆測資, 每筆測資開頭輸入 n, d, r (1 &amp;lt;= n &amp;lt;= 100)(1 &amp;lt;= d &amp;lt;= 10000)(1 &amp;lt;= r &amp;lt;= 5) 下一列輸入 n 個早上路徑 再下一列輸入 n 個下午路徑
題解 有 n 位司機, 每位司機會被分配到一個早上和下午路徑 若是一天的總路程超過 d, 則每一單位長度要付 r 元 求如何安排使加班費最少
作法 大的配小的
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>工作排程問題統整</title><link>https://ptzu.github.io/posts/job-scheduling/</link><pubDate>Fri, 13 Apr 2018 20:58:24 +0000</pubDate><guid>https://ptzu.github.io/posts/job-scheduling/</guid><description>Job Scheduling 1 題目
input 第一列輸入 T, 代表 T cases 每筆測資開頭輸入 n (1 &amp;lt;= N &amp;lt;= 100) 代表 n 個工作 每個工作輸入 id, deadline, profit
題解 有 n 個工作 每個工作花費 1 單位時間完成 只要在 deadline 前完成就可以 求最大的 profit 為多少
作法 紀錄最大的 deadline profit 大到小排序後 每次從 max deadline 往前掃, 若有空間就放 時間複雜度: {%math%}O(n^2){%endmath%}
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 1201 Intervals</title><link>https://ptzu.github.io/posts/poj1201/</link><pubDate>Fri, 13 Apr 2018 16:46:55 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1201/</guid><description>題目
input 輸入 N (1 &amp;lt;= N &amp;lt;= 50000) 代表有 N 個區間 區間輸入 [a, b] 有 c 個元素
題解 給一些區間, 並告訴你其中有幾個元素 區間之間可重疊元素 請問總共最少有幾個元素？
作法 區間約束 令 d[i] 為 0&amp;hellip;i 區間有幾個元素 則題目可以轉化為 d[b + 1] - d[a] &amp;gt;= c index 向右平移 1 是為了不要有負的 index 然後稍做整理 d[a] - d[b + 1] &amp;lt;= -c 建一條從 a -&amp;gt; b 的 -c 邊 除此之外還有個條件是 0 &amp;lt;= d[i + 1] - d[i] &amp;lt;= 1 建好圖之後求差分約束即可
PS： 網路上很多作法在建邊是這樣定義 d[b + 1] - d[a] &amp;gt;= c, 從 a -&amp;gt; b 建一條 c 邊 然後求最長路徑 想法應該是一樣 不過有點麻煩我就用我習慣的定義了</description></item><item><title>POJ 3169 Layout</title><link>https://ptzu.github.io/posts/poj3169/</link><pubDate>Fri, 13 Apr 2018 07:33:17 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3169/</guid><description>題目
input 輸入 N, E1, E2 (2 &amp;lt;= N &amp;lt;= 1,000)(1 &amp;lt;= E1,E2 &amp;lt;= 10,000) 分別代表 N 頭牛, 最大距離限制數量, 最小距離限制數量 接著輸入 E1, E2 個限制
題解 有 N 頭牛編號 1 ~ N 有些牛想要和其他牛保持距離, 有些牛希望和其他牛在一定距離內 給一些限制表示兩頭牛之間的最大及最小距離 問第一頭牛和最後一頭牛的最大距離是多少
作法 差分約束裸題 有負環輸出 -1 到不了輸出 -2
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>TIOJ 1224 矩形覆蓋面積計算</title><link>https://ptzu.github.io/posts/tioj1224/</link><pubDate>Wed, 28 Mar 2018 21:10:33 +0000</pubDate><guid>https://ptzu.github.io/posts/tioj1224/</guid><description>題目
input 輸入檔只包含一筆測試資料。 第一列有一個正整數n(1&amp;lt;=n&amp;lt;=100,000)，代表有n個矩形。 接下來有n列，每列有四個整數 L,R,D,U(0&amp;lt;=L&amp;lt;R&amp;lt;=1,000,000；0&amp;lt;=D&amp;lt;U&amp;lt;=1,000,000)代表矩形的左、右、下、上四個邊界座標。
題解 給你很多平面上的矩形，請求出它們覆蓋的總表面積。
作法 和 POJ 1151相同
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX struct line{ int pos, y1, y2, type; bool operator &amp;lt;(const line&amp;amp; a)const{ return pos &amp;lt; a.</description></item><item><title>POJ 3461 Oulipo</title><link>https://ptzu.github.io/posts/poj3461/</link><pubDate>Sun, 18 Mar 2018 09:54:41 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3461/</guid><description>題目
input 多筆測資, 每筆測資先輸入目標字串 t (1 &amp;lt;= |t| &amp;lt;= 10000) 再輸入比對字串 s (|t| &amp;lt;= |s| &amp;lt;= 1000000)
題解 給一文本 求目標字串在文本的出現次數
作法 KMP比對
AC code #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 10010; int fail[MAX_N]; int len, ans; void getf(string s){ fail[0] = -1; int idx = -1; for(int i = 1; i &amp;lt; s.</description></item><item><title>KMP Algorithm</title><link>https://ptzu.github.io/posts/template-kmp/</link><pubDate>Sun, 18 Mar 2018 09:54:26 +0000</pubDate><guid>https://ptzu.github.io/posts/template-kmp/</guid><description>index 從 0 開始 無配對為 -1
AC code const int MAX_N = ...; int fail[MAX_N]; void getf(string s){ fail[0] = -1; int idx = -1; for(int i = 1; i &amp;lt; s.length(); i++){ while(idx != -1 &amp;amp;&amp;amp; s[i] != s[idx + 1]){ idx = fail[idx]; } if(s[i] == s[idx + 1]){ fail[i] = idx + 1; idx++; } else fail[i] = -1; } } void KMP(string s, string t){ int idx = -1, t_len = t.</description></item><item><title>POJ 1741 Tree</title><link>https://ptzu.github.io/posts/poj1741/</link><pubDate>Sat, 17 Mar 2018 16:11:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1741/</guid><description>題目
input 多筆測資, 每筆開頭輸入 n, k (n &amp;lt;= 10000) 代表 n 個點, 路徑長 k 接著輸入 n - 1 條邊 u, v, w 代表 u 連到 v 權重 w
題解 給一棵樹 求點對 (u, v) 長度不超過 k 有幾個點對
作法 利用重心分解的技巧 每次都從重心做樹分治 複雜度: {%math%}O(logn){%endmath%} 針對每個重心, 跑一次DFS 每個子樹我們可以求點到根的距離 cal(x) 可以求取以 x 為根, 經過 x 的路徑有幾條 經過排序後, 可以在 O(n) 時間內求取所有點對 瓶頸在排序, 複雜度：{%math%}O(nlogn){%endmath%}
由於當 k 夠大時, cal(x) 會計算到不經過 x, 但長度為 &amp;lt;= k 的路徑 因此每次都要扣掉子樹的數量
總複雜度: {%math%}O(nlog^{2}n){%endmath%}</description></item><item><title>重心分解 Tree Decomposition</title><link>https://ptzu.github.io/posts/template-tree-decomposition/</link><pubDate>Sat, 17 Mar 2018 16:11:19 +0000</pubDate><guid>https://ptzu.github.io/posts/template-tree-decomposition/</guid><description>又稱為重心剖分、點分治
由於重心有個特性是, 子樹大小不超過 n / 2 n 為整顆樹的大小
所以每次找重心可以將時間複雜度壓到 O(logn)
Code struct edge{ int to, w; }; int V, k; vector &amp;lt;edge&amp;gt; g[10010]; bool vis[10010]; int son[10010], centroid, balance_size; int dis[10010]; void tree_centroid(int x, int fa, const int size){ int mx_son = 0; son[x] = 1; for(int i = 0; i &amp;lt; sz(g[x]); i++){ int v = g[x][i].to; if(v == fa || vis[v]) continue; tree_centroid(v, x, size); son[x] += son[v]; mx_son = max(mx_son, son[v]); } mx_son = max(mx_son, size - son[x]); if(mx_son &amp;lt; balance_size){ balance_size = mx_son; centroid = x; } } void tree_decomposition(int x, const int size){ balance_size = INF; tree_centroid(x, -1, size); int cent = centroid; vis[cent] = true; do something.</description></item><item><title>POJ 1655 Balancing Act</title><link>https://ptzu.github.io/posts/poj1655/</link><pubDate>Wed, 14 Mar 2018 14:42:58 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1655/</guid><description>題目
input 含多筆測資, 每筆測資開頭輸入 V (1 &amp;lt;= V &amp;lt;= 20,000) 代表 V 個點 接著輸入 V - 1 條樹邊
題解 找樹重心, 有多個就輸出編號最小的
作法 找樹重心, 有多個就輸出編號最小的
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX vector &amp;lt;int&amp;gt; g[20010]; int son[20010], centroid, balance_size; int V; void init(){ for(int i = 0; i &amp;lt; V; i++) g[i].</description></item><item><title>樹重心 Tree Centroid</title><link>https://ptzu.github.io/posts/template-tree-centroid/</link><pubDate>Wed, 14 Mar 2018 14:42:43 +0000</pubDate><guid>https://ptzu.github.io/posts/template-tree-centroid/</guid><description>將樹的一點移除, 會產生許多子樹 其中使子樹中最大數量最小的點為重心
方法為跑一次 DFS, 紀錄每個點的子樹數量 同時也更新最小值
Code vector &amp;lt;int&amp;gt; g[20010]; int son[20010], centroid, balance_size; int V; void dfs(int x, int pa){ int mx_son = 0; void tree_centroid(int x, int fa, const int size){ int mx_son = 0; son[x] = 1; for(int i = 0; i &amp;lt; sz(g[x]); i++){ int v = g[x][i]; if(v == fa) continue; tree_centroid(v, x, size); son[x] += son[v]; mx_son = max(mx_son, son[v]); } mx_son = max(mx_son, size - son[x]); if(mx_son &amp;lt; balance_size || (mx_son == balance_size &amp;amp;&amp;amp; x &amp;lt; centroid)){ balance_size = mx_son; centroid = x; } } 例題 POJ 1655</description></item><item><title>POJ 1830 开关问题</title><link>https://ptzu.github.io/posts/poj1830/</link><pubDate>Tue, 13 Mar 2018 16:32:10 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1830/</guid><description>題目
input 输入第一行有一个数K，表示以下有K组测试数据。 每组测试数据的格式如下： 第一行 一个数N（0 &amp;lt; N &amp;lt; 29） 第二行 N个0或者1的数，表示开始时N个开关状态。 第三行 N个0或者1的数，表示操作结束后N个开关的状态。 接下来 每行两个数I J，表示如果操作第 I 个开关，第J个开关的状态也会变化。每组数据以 0 0 结束。
題解 有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。你的目标是经过若干次开关操作后使得最后N个开关达到一个特定的状态。对于任意一个开关，最多只能进行一次开关操作。你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序）
作法 用高斯消去法找自由變數量
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX typedef vector&amp;lt;int&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; int tot; // 自由變數量 void gauss(mat &amp;amp;m){ int n = m.</description></item><item><title>高斯消去法</title><link>https://ptzu.github.io/posts/template-gauss-elimination/</link><pubDate>Tue, 13 Mar 2018 16:32:04 +0000</pubDate><guid>https://ptzu.github.io/posts/template-gauss-elimination/</guid><description>Code typedef vector&amp;lt;int&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; int tot; // 自由變數量 void gauss(mat &amp;amp;m){ int n = m.size(); tot = 0; for(int col = 0; col &amp;lt; n; col++){ int tmp = tot; for(; tmp &amp;lt; n; tmp++) if(m[tmp][col]) break; if(tmp != n &amp;amp;&amp;amp; m[tmp][col]){ // 找到開頭是 1 的列, 有可能不在當前位置, 做列交換 for(int k = 0; k &amp;lt;= n; k++) swap(m[tot][k], m[tmp][k]); for(int row = 0; row &amp;lt; n; row++){ // 做消去 if(row !</description></item><item><title>Uva 684 - Integral Determinant</title><link>https://ptzu.github.io/posts/uva684/</link><pubDate>Mon, 12 Mar 2018 01:00:56 +0000</pubDate><guid>https://ptzu.github.io/posts/uva684/</guid><description>題目
input 多筆測資, 每筆測資開頭輸入 n (n &amp;lt;= 30) 代表矩陣大小 接著輸入 n x n 矩陣
題解 求行列式
作法 求行列式
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX typedef vector&amp;lt;ll&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; ll determinant(mat m){ int n = m.</description></item><item><title>矩陣行列式 Matrix Determinant</title><link>https://ptzu.github.io/posts/template-matrix-determinant/</link><pubDate>Sun, 11 Mar 2018 16:44:05 +0000</pubDate><guid>https://ptzu.github.io/posts/template-matrix-determinant/</guid><description>Code typedef vector&amp;lt;ll&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; ll determinant(mat m){ int n = m.size(); ll det = 1; for(int col = 0; col &amp;lt; n; col++){ for(int row = col + 1; row &amp;lt; n; row++){ int x = col, y = row; // 目前列, 下一列 while(m[y][col]){ // 下一列不為 0 就繼續做 ll q = m[x][col] / m[y][col]; for(int k = 0; k &amp;lt; n; k++){ m[x][k] -= m[y][k] * q; } swap(x, y); } if(x !</description></item><item><title>HDU 1466 计算直线的交点数</title><link>https://ptzu.github.io/posts/hdu1466/</link><pubDate>Sat, 10 Mar 2018 20:59:25 +0000</pubDate><guid>https://ptzu.github.io/posts/hdu1466/</guid><description>題目
input 输入数据包含多个测试实例,每个测试实例占一行,每行包含一个正整数n（n&amp;lt;=20）,n表示直线的数量.
題解 平面上有n条直线，且无三线共点，问这些直线能有多少种不同交点数。 比如,如果n=2,则可能的交点数量为0(平行)或者1(不平行)。
作法 自己畫了幾個例子, 只覺得好亂 那麼多種直線, 找不到轉移式&amp;hellip;
只好上網找題解 首先將線分為兩種, 自由線以及平行線 所謂自由線就是那條線可以是任何方向, 只要不和平行線平行就好 平行線是彼此間互相平行的線, 定義180度水平的為平行線好了 接著我們試著畫看看 假設有 5 條自由線, 方向任意(甚至他們之間平行也沒差, 只要不和平行線平行就好) 然後我們加上一條水平線, 發現增加 5 個交點 再加上一條, 也是增加 5 個交點 於是假設現在有 i 條自由線, 加上 j 條平行線 增加的點為 i * j 個點
最後我們定義 dp[i][j]: 總共有 i 條線, j 個交點這種狀況是否成立 列舉不同數量的自由線和交點數量 若該狀態成立 dp[all][k + 平行線數 * 自由線數] 也會成立
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 10285 - Longest Run on a Snowboard</title><link>https://ptzu.github.io/posts/uva10285/</link><pubDate>Thu, 08 Mar 2018 21:37:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10285/</guid><description>題目
input 第一列輸入 T, 代表 T cases 每筆測資輸入 name, row, col 接著輸入每個點的高度
題解 現在要滑雪, 從平地到目前高度的步數是 1 接下來只能選比目前低的&amp;quot;周圍點&amp;quot;滑下去 每滑一個點算一步, 求最長路徑
作法 非常水的一題&amp;hellip; 每個點 dfs 一次就好了 dp 陣列只是紀錄跑過的不要跑, 加快而已
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 10010; int a[200][200]; int dp[200][200]; pii dir[] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int r, c; int ans; void solve(pii s, int len){ dp[s.</description></item><item><title>Uva 10056 - What is the Probability ?</title><link>https://ptzu.github.io/posts/uva10056/</link><pubDate>Thu, 08 Mar 2018 20:41:17 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10056/</guid><description>題目
input 第一列輸入 T (T &amp;lt;= 1000), 代表 T cases 每筆測資輸入 n, p, k 代表 n 個玩家, 抽到勝利的機率, 第 k 個玩家
題解 一群人在玩骰子, 非傳統骰子, 只要骰到某個數字他就贏 骰到某個數字的機率為 p, 求第 k 個人贏的機率
作法 模擬算機率 贏的機率為 p, 輸的機率為 1 - p = q 但由於沒有說要玩幾輪 所以不斷累加 全輸的機率 * 某一輪贏的機率 因為後面的機率已經太小了, 不會影響答案, 所以設個中斷點即可
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 10319 - Manhattan</title><link>https://ptzu.github.io/posts/uva10319/</link><pubDate>Thu, 08 Mar 2018 12:02:59 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10319/</guid><description>題目
input 含多筆測資, 輸入 T, 代表 T 座城市 每筆測資開頭輸入 r, c, m (0 &amp;lt;= r,c &amp;lt;= 20)(0 &amp;lt;= m &amp;lt;= 200) 代表 street, avenue, route 數量 接著 m 條 route 輸入起點與終點
題解 每座城市有 r 條 street(東西向), c 條 avenue(南北向) 替每條路指定方向(只能往東南西北一個方向) 定義一條合法的 route 為起點走到終點, 走的路都為指定方向 而一條 simple route, 就是路程中最多一次轉向
給 M 對起點終點, 若有至少一條 simple route 就輸出 Yes 反之 No
作法 判斷 2-SAT 是否為 true
將一條路當成一個邏輯變數 先定義向東以及向南為 True 假設起點為 (r1, c1), 終點為 (r2, c2)</description></item><item><title>2-SAT</title><link>https://ptzu.github.io/posts/template-twosat/</link><pubDate>Thu, 08 Mar 2018 12:02:50 +0000</pubDate><guid>https://ptzu.github.io/posts/template-twosat/</guid><description>當有{%math%}(a\vee b){%endmath%}這種型式的時候 可以轉成{%math%}(\neg a\Rightarrow b\wedge \neg b\Rightarrow a){%endmath%} 箭頭左邊建一條邊到右邊
addClause 的 flag 是代表該變數要不要取 not
只要{%math%}x, \neg x{%endmath%}不在同一個 SCC 內, 命題為真
邏輯定律 肯定前件律(MP): {%math%}p\supset q,\ p/\ q{%endmath%} 否定後件律(MT): {%math%}p\supset q,\ \neg q/\ \neg p{%endmath%} 連言律(Conj): {%math%}p,\ q/\ p\wedge q{%endmath%} 簡化律(Simp): {%math%}p\wedge q/\ p{%endmath%} 選言三段論(DS): {%math%}p\vee q,\ \neg p/\ q{%endmath%} 假言三段論(HS): {%math%}p\supset q,\ q\supset r/\ p\supset r{%endmath%} 添加律(Add): {%math%}p/\ p\vee q{%endmath%} 建構兩難律(CD): {%math%}p\supset q,\ r\supset s,\ p\vee r/\ q\vee s{%endmath%} 雙重否定律(DN): {%math%}p\equiv \neg \neg p{%endmath%} 笛摩根定律(DeM): {%math%}\neg (p\wedge q)\equiv \neg p \vee \neg q{%endmath%} 交換律(Comm): {%math%}p\vee q\equiv q\vee p{%endmath%} 結合律(Assoc): {%math%}p\vee (q\vee r) \equiv (p\vee q)\vee r{%endmath%} 分配律(Dist): {%math%}p\wedge (q\vee r)\equiv (p\wedge q)\vee (p\wedge r){%endmath%} {%math%}p\vee (q\wedge r)\equiv (p\vee q)\wedge (p\vee r){%endmath%} 換值換位律(Contra): {%math%}p\supset q\equiv \neg q\supset \neg p{%endmath%} 蘊涵律(Impl): {%math%}p\supset q\equiv \neg p\vee q{%endmath%} 等值律(Equiv): {%math%}(p\equiv q)\equiv (p\supset q)\wedge (q\supset p)\equiv (p\wedge q)\vee (\neg p\wedge \neg q){%endmath%} 移出律(Exp): {%math%}(p\wedge q)\supset r\equiv p\supset (q\supset r){%endmath%} 恆真律(Taut): {%math%}p\supset q\equiv \neg p\vee q{%endmath%} 其中 {%math%}\supset {%endmath%} 是條件符號</description></item><item><title>POJ 1523 SPF</title><link>https://ptzu.github.io/posts/poj1523/</link><pubDate>Tue, 06 Mar 2018 21:20:50 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1523/</guid><description>題目
input 含多筆測資 無限量的輸入邊 直到輸入 0 結束
題解 Single Point of Failure 定義為拿掉該點, 會使得至少一點不連通 求所有的 SPF 和會分成幾塊
作法 求拿掉割點會分成幾塊
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;set&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 10010; int V, E; vector &amp;lt;int&amp;gt; g[MAX_V]; int dfn[MAX_V], low[MAX_V], tot, bccid[MAX_V], bcc_cnt; int cut[MAX_V]; stack &amp;lt;int&amp;gt; S; int cnt; set &amp;lt;int&amp;gt; ans; void init(){ for(int i = 0; i &amp;lt; V; i++) g[i].</description></item><item><title>POJ 2117 Electricity</title><link>https://ptzu.github.io/posts/poj2117/</link><pubDate>Tue, 06 Mar 2018 21:20:47 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2117/</guid><description>題目
input 多筆測資, 每筆測資輸入 V, E V, E 為 0 結束 接著輸入 E 條邊
題解 現有 V 個電廠, 要建立一個電路網不需要任兩個電廠都連接 要考慮電路網的可靠度, 假設一個電廠掛掉, 會被分成幾個區塊 請問最多可能被分為幾塊
作法 和找割點差不多 cut[i] 改成會切開幾個兒子(有幾個橋邊) 若 i 是根, 則會增加 cut[i] - 1 個
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 3352 Road Construction</title><link>https://ptzu.github.io/posts/poj3352/</link><pubDate>Tue, 06 Mar 2018 17:47:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3352/</guid><description>題目
input 多筆測資, 每筆測資開頭輸入 V, E (3 ≤ V ≤ 1000)(2 ≤ E ≤ 1000) 分別代表點數和邊數 接著輸入 E 條邊
注意輸入和輸出的中文字都是沒有的
題解 有一座島上有 V 個名勝景點, 他們之間有許多路互相連接 現在想要維修&amp;quot;一條&amp;quot;路, 所以這條路就不能走了 然而不想讓這些名勝景點斷開連結 所以決定建造一些路, 使得之間仍然連通, 建造中的路可以行走 問最少需要建造幾條路？ 維修中的路不能走, 建造中的路可以走, 真是神邏輯&amp;hellip;
作法 邊-雙連通分量
拔掉一個邊還要連通, 那代表該圖要是雙連通分量 作法是找到雙連通分量, 縮點後 想要將此圖建成雙連通 需要加的邊數為 (度數為 1 的點) + 1 / 2
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 796 - Critical Links</title><link>https://ptzu.github.io/posts/uva796/</link><pubDate>Sun, 04 Mar 2018 21:01:42 +0000</pubDate><guid>https://ptzu.github.io/posts/uva796/</guid><description>題目
input 含多筆測資 每筆測資第一列輸入 n, 代表有幾台伺服器 接著輸入 n 台伺服器所連接的伺服器 格式: u (num) v1, v2&amp;hellip; 伺服器 u 連接到 v
題解 在電腦網路中, 若移除某條網路 會造成某兩台伺服器不連通 則稱此條網路為 critical 求有哪些 critical network
作法 求橋裸題 橋的輸出必須升序, 並且由小的編號連到大的(題目沒看到哪裡有講= =)
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 10010; int V, E; vector &amp;lt;int&amp;gt; g[MAX_V]; int dfn[MAX_V], low[MAX_V], tot; vector &amp;lt;pii&amp;gt; ans; void init(){ for(int i = 0; i &amp;lt; V; i++) g[i].</description></item><item><title>雙連通單元 BCC</title><link>https://ptzu.github.io/posts/template-bcc/</link><pubDate>Sun, 04 Mar 2018 19:30:28 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bcc/</guid><description>在一個無向圖中 若任兩點, 存在&amp;quot;兩條點不重複路徑&amp;quot;, 則稱此圖為 點-雙連通 而點-雙連通內部沒有割點 若任兩點, 存在&amp;quot;兩條邊不重複路徑&amp;quot;, 則稱此圖為 邊-雙連通
點-雙連通的最大子圖稱為雙連通單元(分量)
點-雙連通單元 性質:
條件: low[v] &amp;gt;= dfn 割點可以屬於多個連通單元 任兩個連通單元的共同點最多一個, 也就是割點 連通單元內不會有割點 可順便求割點 這在網路上有兩種寫法 一種是在 stack 存點, 另一種存邊 由於割點可以屬於多個單元, 所以在 pop 時, 不能將割點 pop 出去 而這份 code, 不會將割點 pop 出去, 但有個副作用是 root 會留在 stack 多筆測資使用要小心
存邊的寫法有空再來理解
存點 Code // 割點的 bccid 沒有意義 const int MAX_V = ...; int V, E; vector &amp;lt;int&amp;gt; g[MAX_V], bcc[MAX_V]; int dfn[MAX_V], low[MAX_V], tot, bccid[MAX_V], bcc_cnt; bool cut[MAX_V]; stack &amp;lt;int&amp;gt; S; void dfs(int x, int fa){ int child = 0; dfn[x] = low[x] = ++tot; S.</description></item><item><title>關節點、橋</title><link>https://ptzu.github.io/posts/template-articulation-point/</link><pubDate>Fri, 02 Mar 2018 12:59:19 +0000</pubDate><guid>https://ptzu.github.io/posts/template-articulation-point/</guid><description>關節點 關節點必須符合兩個性質其中一個：
假設目前點為 x, 子孫為 v, low[v] &amp;gt;= dfn 若該點是 root(起始點), 則他的小孩數量 &amp;gt; 1 先來看第一個性質, 當 low[v] 都大於等於當前的編號 就代表所有子孫不會連到當前點的祖先 也就是當前點斷掉的話, 就會分成兩塊
接下來看為何為特別將 root 設個條件(搭配下面的測資) root 的子孫 low 值一定都比 dfn[root] 大 那拿掉 root 一定可以斷開嘛？ 答案是否, 當圖案為一直線 拿掉起點不會產生新的 SCC 只有當 root_child &amp;gt; 1 時才會
相關測資 #root Input: 5 1 2 2 3 3 4 4 5 0 0 Output: 3 # dfn and low Input: 5 1 3 2 2 4 5 3 4 5 0 5 1 2 3 2 3 4 5 4 5 0 Output: 1 1 Code // 割點的 bccid 沒有意義 const int MAX_V = .</description></item><item><title>POJ 1144 Network</title><link>https://ptzu.github.io/posts/poj1144/</link><pubDate>Fri, 02 Mar 2018 11:50:28 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1144/</guid><description>題目
input 含多筆測資, 每筆開頭輸入 N, 代表 N 個點, N = 0 結束測資 接下來有不定數量的列 每列開頭輸入 u, 當 u = 0 結束 u 後面接著多個數 v, 代表 u, v 之間有一條邊
題解 電話公司正在建立電話網, 有 N 個地方, 編號從 1 ~ N 每條電話線是雙向的, 每個地方都有個電話轉接站 任兩個地方可透過轉接站連接, 所以不必直接連接 若有個轉接站停電會造成某些區域無法互相連通 稱那個地方為 critical, 求有幾個地方是 critical
作法 找關節點數量 不過用 SCC 的方法也過了, 還沒去想是否正確
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;numeric&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>UOJ 146.【NOIP2015】信息传递</title><link>https://ptzu.github.io/posts/uoj146/</link><pubDate>Thu, 01 Mar 2018 17:07:05 +0000</pubDate><guid>https://ptzu.github.io/posts/uoj146/</guid><description>題目
input 第一列輸入 n (n &amp;lt;= 200000) 代表 n 個人 接著輸入每個人的傳遞對象
題解 有 n 个同学（编号为 1 到 n ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 i 的同学的信息传递对象是编号为 Ti 的同学。
游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？
作法 求 SCC 個數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 200010; int V, E; vector &amp;lt;int&amp;gt; g[MAX_V]; int dfn[MAX_V], low[MAX_V], tot, ans; bool vis[MAX_V]; stack &amp;lt;int&amp;gt; S; void dfs(int x){ dfn[x] = low[x] = ++tot; vis[x] = true; S.</description></item><item><title>強連通單元 SCC</title><link>https://ptzu.github.io/posts/template-scc/</link><pubDate>Tue, 27 Feb 2018 23:58:21 +0000</pubDate><guid>https://ptzu.github.io/posts/template-scc/</guid><description>強連通單元為一集合, 集合內任取兩點, 都可以互相連通 任何有向圖都能分解成幾個 SCC 將 SCC 縮成一個點就會變成 DAG 求 SCC 數量方法有兩種
Tarjan 跑兩次 DFS Tarjan dfn[i]: DFS的順序(時間編號) low[i]: 能到達 i 的最小的時間編號 i 能達到的最小時間編號
在理解的時候有幾個問題
stack 的作用？ 用來存放已經走過, 但還沒變成 SCC 的點 in_stack 陣列存在的必要性？ 在看網路很多模版的時候, 他們是取作 vis 陣列的 而我想說既然有 dfn 陣列, 那還沒有時間戳的點肯定是沒走過的 為何需要 vis 陣列？ 首先走過的點可分為兩種 一種是在 stack 裏面, 另一種是不在了 當一個點不在 stack 內, 代表已經成為一個 SCC 若我們拿別的 SCC 來更新自己 low 值肯定出錯 因為已成為 SCC 的點不可能再走到當前點了 所以我認為取做 in_stack 更加恰當, 只有在 stack 的點可以更新當前 low 值 要用 dfn 還是 low 更新？ 第 19 行網路上幾乎都是用 dfn 更新 但我想想, 在 stack 的點若可走到當前點 那個點的 low 值也一定可以走到當前點 所以用 low 值更新應該沒錯吧(?</description></item><item><title>POJ 2186 Popular Cows</title><link>https://ptzu.github.io/posts/poj2186/</link><pubDate>Tue, 27 Feb 2018 23:46:26 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2186/</guid><description>題目
input 輸入 N, M (1 &amp;lt;= N &amp;lt;= 10,000)(1 &amp;lt;= M &amp;lt;= 50,000) 代表 N 頭牛, M 條關係 接著 M 條關係 輸入 A B, 代表 牛A 認為 牛B 很紅
題解 (A, B) 代表 牛A 認為 牛B 很紅, 而這種關係有遞移性 即 A-&amp;gt;B, B-&amp;gt;C, 則 A-&amp;gt;C 請問有幾頭牛被其他所有的牛認為很紅？
作法 首先當一頭牛被所有牛認為很紅的時候(最紅) 那和這頭牛在同一個 SCC 的也必定是最紅 在求 SCC 時最後一個 SCC 就會是最紅的一群 因為整張圖是個 DAG, 最後一個 SCC 便是大家連過去的 所以找到最後一個 SCC 時, 就跑一次 RDFS, 如果能跑完所有點 就是答案
Tarjan AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 11069 - A Graph Problem</title><link>https://ptzu.github.io/posts/uva11069/</link><pubDate>Sun, 25 Feb 2018 00:46:36 +0000</pubDate><guid>https://ptzu.github.io/posts/uva11069/</guid><description>題目
input 多筆測資, 輸入 n (1 ≤ n ≤ 76)
題解 你的任務是：給你 n ，請算出這個圖形有以下性質的節點子集合共有多少個
集合裡不能有兩個相鄰的點。例如圖形中有 n = 3 個節點，則集合 {1,2} 是違法的，而集合 {1,3} 是合法的 當這個集合能再加入任一節點，卻可以不和其它節點相鄰，則這個集合是違法的。例如圖形中有 n = 5個節點，則集合 {1,5} 是違法的，因為這個集合再加入節點 3 仍不和其它節點相鄰，而集合 {1,3,5} 則是合法的 所以，當圖形有 n = 5 個節點時，應該有 4 個合法的集合：{1,3,5},{2,4},{2,5},{1,4}.
作法 對於 n = i 來說 i - 2 的所有組合必定可以加入 i 而 i - 1 必定不可加, 所以保留原樣轉移到 i 然而 i - 1 有些組合是從 i - 2 轉移過去 所以這樣會重複 因此分開紀錄 定義 dp[i][0] = dp[i - 2][0] + dp[i - 2][1] 從 i - 2 轉移過來的, 必定可以加 i dp[i][1] = dp[i - 1][0] 從 i - 1 轉移過來, 不能包含從 i - 2 過來的</description></item><item><title>Codeforces Good Bye 2017</title><link>https://ptzu.github.io/posts/cfgb2017/</link><pubDate>Fri, 23 Feb 2018 00:48:39 +0000</pubDate><guid>https://ptzu.github.io/posts/cfgb2017/</guid><description>目錄 若 p 則 q 給指令走路 盤子下降 A. New Year and Counting Cards 題目
input 輸入一字串 s (1 &amp;lt;= |s| &amp;lt;= 50) 每個字代表這張卡可以看到的字母
題解 現有 n 張卡 有一敘述: 若一面是 &amp;ldquo;a,e,i,o,u&amp;rdquo; 則另一面是 &amp;ldquo;0,2,4,6,8&amp;rdquo; 目前可以看到這些卡的一面, 若想確定這敘述是對的 最少需要翻開幾張卡看另一面？
作法 當敘述為真, 有兩種情況 p =&amp;gt; q 或是 not q =&amp;gt; not p 所以若是看到 p 或 not q, 則要翻開另一面確認
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Educational Codeforces Round 35</title><link>https://ptzu.github.io/posts/cfedu35/</link><pubDate>Thu, 22 Feb 2018 20:48:46 +0000</pubDate><guid>https://ptzu.github.io/posts/cfedu35/</guid><description>目錄 最小數字最近距離 裝蛋糕使最少塊最多 燈泡週期性 逆序數對奇偶性 A. Nearest Minimums 題目
input 輸入 N (2 ≤ n ≤ 10^5), 代表 array 大小 接著輸入 N 個值
題解 找最小值之間最近的距離
作法 紀錄好值和 index, 排序後去找
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX pii p[101010]; int n; int main(){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); p[i].</description></item><item><title>Codeforces Round 452</title><link>https://ptzu.github.io/posts/cf452/</link><pubDate>Tue, 20 Feb 2018 22:39:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf452/</guid><description>目錄 湊組別 月份日期合法 數字分堆差最小 湊出最多 9 相同數字區間刪除 區間刪除特定字元 A. Splitting in Teams 題目
input 輸入 n (2 ≤ n ≤ 2·10^5) 代表有 n 組 接著輸入每組有幾人 (1 ≤ a ≤ 2)
題解 有 n 組人參加訓練營, 每組有 1 人或 2 人 教練想要組隊參加比賽, 一隊有 3 人 若是一組要參加, 則整組的人都要參加 問最多能湊出幾隊去比賽
作法 兩人一組的一定只能和一人的組別配對 所以先算出這樣可以配出幾隊 然後剩下的一人組別再去湊
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>常用技巧篇</title><link>https://ptzu.github.io/posts/template-tricks/</link><pubDate>Tue, 20 Feb 2018 13:32:22 +0000</pubDate><guid>https://ptzu.github.io/posts/template-tricks/</guid><description>列舉因數 判斷後綴字串 a 是否為 b 的後綴字串
bool Suf(string a, string b){ if(a.length() &amp;gt; b.length()) return false; return a == b.substr(b.length() - a.length(), a.length()); } 分堆 離散化 平移視窗 浮點數 Graph linked list const int MAX_N = 50010; struct node{ int to, w; node* next; }*g[MAX_N], edges[MAX_N * 3]; int tot; inline void addEdge(int a, int b, int c){ node *e = &amp;amp;edges[tot++]; e-&amp;gt;to = b; e-&amp;gt;w = c; e-&amp;gt;next = g[a]; g[a] = e; }</description></item><item><title>Codeforces Round 451</title><link>https://ptzu.github.io/posts/cf451/</link><pubDate>Tue, 20 Feb 2018 11:56:25 +0000</pubDate><guid>https://ptzu.github.io/posts/cf451/</guid><description>目錄 四捨五入 花費組合 電話簿清除後綴字串 鬧鐘關閉滑動視窗 A. Rounding 題目
input 輸入 n (0 ≤ n ≤ 10^9)
題解 將最後一位數四捨五入
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 10000; int main(){ ll n; scanf(&amp;#34;%lld&amp;#34;, &amp;amp;n); if(n % 10 &amp;lt; 5){ n /= 10; n *= 10; } else{ n /= 10; n++; n *= 10; } printf(&amp;#34;%lld\n&amp;#34;, n); return 0; } B.</description></item><item><title>Codeforces Round 448</title><link>https://ptzu.github.io/posts/cf448/</link><pubDate>Sun, 18 Feb 2018 00:20:12 +0000</pubDate><guid>https://ptzu.github.io/posts/cf448/</guid><description>目錄 切 pizza 區間被 x 整除有 k 個 A. Pizza Separation 題目
input 輸入 n (1 ≤ n ≤ 360), 代表 pizza 切成 n 塊 輸入 n 塊的角度
題解 pizza 已經切成 n 塊, 現在想要將這些分為連續的兩部份 並且使這兩部份的角度和差距最小
作法 窮舉不同的和
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 447</title><link>https://ptzu.github.io/posts/cf447/</link><pubDate>Sat, 17 Feb 2018 23:43:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf447/</guid><description>目錄 窮舉 方格填數 A. QAQ 題目
input 輸入一字串 s
題解 QAQ 代表哭臉 給一字串, 求有幾個 QAQ (不必相連)
作法 窮舉
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 100010; int main(){ string s; cin &amp;gt;&amp;gt; s; int cnt = 0; for(int i = 0; i &amp;lt; s.</description></item><item><title>Codeforces Round 446</title><link>https://ptzu.github.io/posts/cf446/</link><pubDate>Sat, 17 Feb 2018 22:12:08 +0000</pubDate><guid>https://ptzu.github.io/posts/cf446/</guid><description>目錄 分裝可樂 耙子殺人 GCD A. Greed 題目
input 第一列輸入 n (2 ≤ n ≤ 100 000) 代表 n 罐可樂 下一列輸入每罐剩餘的可樂 (0 ≤ a ≤ 10^9) 最後輸入每個罐子的容量 (a ≤ b ≤ 10^9)
題解 有 n 罐可樂, 每個罐子有其剩餘的可樂和罐子容量 問是否能將全部剩餘的可樂分裝到兩個罐子內
作法 sorting 後找最大的兩個罐子
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 2823 Sliding Window</title><link>https://ptzu.github.io/posts/poj2823/</link><pubDate>Sat, 17 Feb 2018 17:50:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2823/</guid><description>題目
input 輸入 n, k (n ≤ 10^6) n 個數字及視窗大小 k
題解 視窗由左而右平移, 輸出每個視窗內的最小/大值
作法 利用單調隊列, 看有人用大小堆作, 之後再來試看看 首先單增隊列維護最小值, 同時紀錄隊列內每個值的 index, 用來判斷是否還在視窗內 將當前元素和隊尾做比較, 如果該元素比較小, 則把隊尾 pop, 直到遇到比該元素還大的 然後就把該元素塞進去, 此時的隊頭即為最小值 同理可以用單減隊列維護最大值, 作法同上
為何單增不能維護最大值呢？因為只要遇到比較小的元素, 就會被 pop 例如 3, 2, 1 最後只會留下 1
PS: 一直不太喜歡 POJ 的 compiler, 這題用 G++ 提交會超時, C++ 不會 明明同樣一份 code, 時間差了至少一倍以上
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>LCA (Lowest Common Ancestor)</title><link>https://ptzu.github.io/posts/template-lca/</link><pubDate>Fri, 16 Feb 2018 19:57:50 +0000</pubDate><guid>https://ptzu.github.io/posts/template-lca/</guid><description>待學方法: Tarjan 離線O(n), RMQ在線
使用倍增法(binary lifting)求 LCA par[v][k] 為點 v 往上走 {%math%}2^{k}{%endmath%} 次的點 首先跑一次 DFS 求出各點的深度 接著跑 LCA 時, 先將比較深的那個點, 往上走到相同高度 由於 LCA 那個點往上走, 每個點都是共同祖先 所以可以用二分搜尋的概念
0 0 0 0 1 1 1 1 ^ ^ 走 2^0 次 走 2^7 次 0 代表不是祖先 1 代表是祖先 一開始走最大步, 接著逐漸縮小 如果該點不是祖先, 就往上走 是祖先就不動, 最後停下來的地方就是邊界
可求任意點對的 LCA 注意: 點是 0-indexed, 需先求好每個點走 1 步的 par 複雜度: {%math%}O(NlogN){%endmath%}
Code const int MAX_N = 10000; const int MAX_LOG_N = 14; int N, root; int depth[MAX_N]; int par[MAX_N][MAX_LOG_N]; vector &amp;lt;int&amp;gt; g[MAX_N]; void init(){ memset(par, -1, sizeof(par)); memset(g, 0, sizeof(g)); } void dfs(int u, int p, int d){ depth[u] = d; for(int i = 0; i &amp;lt; sz(g[u]); i++){ int v = g[u][i]; if(v !</description></item><item><title>POJ 1330 Nearest Common Ancestors</title><link>https://ptzu.github.io/posts/poj1330/</link><pubDate>Fri, 16 Feb 2018 19:52:38 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1330/</guid><description>題目
input 第一列輸入 T, 代表 T cases 每筆第一列輸入 N (2 &amp;lt;= N &amp;lt;= 10,000) 代表樹有 N 個點 接著輸入 N - 1 條邊 u, v 代表 u 是 v 的父節點 最後一列輸入 qu, qv, 求 qu, qv 的 LCA
題解 找出最近共同祖先
作法 LCA 裸題
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>逆序數對 Inversion</title><link>https://ptzu.github.io/posts/template-inversion/</link><pubDate>Thu, 15 Feb 2018 21:23:46 +0000</pubDate><guid>https://ptzu.github.io/posts/template-inversion/</guid><description>若有一個 N 個數的數列 A 針對 index i &amp;lt; j, A[i] &amp;gt; A[j], 則 &amp;lt;A[i], A[j]&amp;gt; 稱為一個逆序數對 可用 Merge sort, BIT&amp;hellip; 等求出 詳細見:維基百科
例題 POJ 2299</description></item><item><title>POJ 2299 Ultra-QuickSort</title><link>https://ptzu.github.io/posts/poj2299/</link><pubDate>Thu, 15 Feb 2018 21:13:37 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2299/</guid><description>題目
input 有多筆測資, 每筆第一列輸入 n (n &amp;lt; 500,000) 接著輸入 n 個數
題解 給一數列做排序 只能相鄰數字做交換 請問要交換幾次才能完成排序 即為求逆序數對個數
作法 Merge Sort 求逆序數對
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 505050; int a[MAX_N]; ll ans; void Merge(int l, int m, int r){ vector &amp;lt;int&amp;gt; temp; int idx1 = l, idx2 = m + 1; while(idx1 &amp;lt;= m &amp;amp;&amp;amp; idx2 &amp;lt;= r){ if(a[idx1] &amp;lt;= a[idx2]){ temp.</description></item><item><title>POJ 2385 Apple Catching</title><link>https://ptzu.github.io/posts/poj2385/</link><pubDate>Wed, 14 Feb 2018 18:14:44 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2385/</guid><description>題目
input 第一列輸入 T, W (1 &amp;lt;= T &amp;lt;= 1,000), (1 &amp;lt;= W &amp;lt;= 30) 代表 T 分鐘和最多移動 W 次
題解 約翰農夫有兩棵蘋果樹, 每分鐘只會有一棵樹結出蘋果 Bessie 可以在兩棵樹間移動, 最多移動 W 次 初始位置在樹 1, 請問他最多能接到幾顆蘋果？
作法 第二次寫這題了, 雖然是簡單題 終於自己想出遞迴式, 超爽derrr 本來想放棄去看之前的 code QQ
首先定義 dp[i][j][k]: 在第 i 分鐘, 走了 j 步, 目前在第 k 樹最多能接到幾顆蘋果 考慮兩種情況
目前站在會結蘋果的樹下, 那有兩種選擇, 原本就站在 k 樹下所以不動 或者從 k ^ 1 樹走過來(k ^ 1, 0 變 1, 1 變 0) 這兩種情況挑大的, 然後 +1 目前站在沒有蘋果的樹下, 和上面一樣兩種選擇, 但是沒有蘋果, 所以不 +1 AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 2229 Sumsets</title><link>https://ptzu.github.io/posts/poj2229/</link><pubDate>Wed, 14 Feb 2018 10:24:02 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2229/</guid><description>題目
input 輸入 N (1 &amp;lt;= N &amp;lt;= 1,000,000)
題解 若只用 2 的次方數 求組出 N 有幾種方法
作法 定義 dp[i]: 組出 i 的方法數 將奇偶數分開考慮 首先奇數為前一個數 +1, 而 +1 不可能產生新的二次方數, 所以方法數和 i - 1 一樣
dp[i] = dp[i - 1] 偶數同樣可以從 i - 1 推過來 但是為偶數, 代表 +1 一定加到偶數個, 所以會產生新的二次方數 考慮 i / 2 這個數, 當他 +1 加到 i, 代表整個翻倍
dp[i] = dp[i - 1] + dp[i / 2] AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 3176 Cow Bowling</title><link>https://ptzu.github.io/posts/poj3176/</link><pubDate>Tue, 13 Feb 2018 23:10:22 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3176/</guid><description>題目
input 第一列輸入 N (1 &amp;lt;= N &amp;lt;= 350) 代表 N 列的三角形 接著輸入三角形
題解 牛牛們玩保齡球, 得分為從三角形頂部到底部, 所經過的點值總和 求最大得分為多少
作法 定義 dp[i][j] 為第 i 列第 j 行的得分總和 遞迴式即為是上層的兩個(或一個)選大的走下來 dp[i][j] += max(dp[i - 1][j - 1], dp[i - 1][j]) 最後求底層最大值即可
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 427</title><link>https://ptzu.github.io/posts/cf427/</link><pubDate>Tue, 13 Feb 2018 17:48:53 +0000</pubDate><guid>https://ptzu.github.io/posts/cf427/</guid><description>目錄 實作 Greedy 換數字 棋盤式 DP A. Key races 題目
input 輸入 s, v1, v2, t1, t2 (1 ≤ s, v1, v2, t1, t2 ≤ 1000) 分別代表字串長度, 打字速度, 延遲
題解 兩人比賽打字, 指定字串長度 s 比賽延遲 t 秒後才開始, 以每字 v 秒的速度打字, 打完後延遲 t 秒收到成功訊息 若第一人比較快, 輸出 &amp;ldquo;First&amp;rdquo; 反之輸出 &amp;ldquo;Second&amp;rdquo; 平手輸出 &amp;ldquo;Friendship&amp;rdquo;
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Codecraft-18 and Codeforces Round 458</title><link>https://ptzu.github.io/posts/cf458/</link><pubDate>Tue, 13 Feb 2018 11:39:59 +0000</pubDate><guid>https://ptzu.github.io/posts/cf458/</guid><description>題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int mod = 1e9 + 7; string s; int k; int dp[1010]; int C[1010][1010]; int main(){ fio; cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; k; if(k == 0){ puts(&amp;#34;1&amp;#34;); return 0; } dp[1] = 0; for(int i = 2; i &amp;lt;= 1000; i++) dp[i] = dp[__builtin_popcount(i)] + 1; C[0][0] = 1; for(int i = 1; i &amp;lt;= 1000; i++){ C[i][0] = 1; for(int j = 1; j &amp;lt;= 1000; j++){ C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; } } int one_num = 0, len = s.</description></item><item><title>NYOJ 16 矩形嵌套</title><link>https://ptzu.github.io/posts/nyoj16/</link><pubDate>Mon, 12 Feb 2018 01:33:06 +0000</pubDate><guid>https://ptzu.github.io/posts/nyoj16/</guid><description>題目
input 第一行是一个正正数N(0&amp;lt;N&amp;lt;10)，表示测试数据组数， 每组测试数据的第一行是一个正正数n，表示该组测试数据中含有矩形的个数(n&amp;lt;=1000) 随后的n行，每行有两个数a,b(0&amp;lt;a,b&amp;lt;100)，表示矩形的长和宽
題解 描述 有n个矩形，每个矩形可以用a,b来描述，表示长和宽。矩形X(a,b)可以嵌套在矩形Y(c,d)中当且仅当a&amp;lt;c,b&amp;lt;d或者b&amp;lt;c,a&amp;lt;d（相当于旋转X90度）。例如（1,5）可以嵌套在（6,2）内，但不能嵌套在（3,4）中。你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。
输出 每组测试数据都输出一个数，表示最多符合条件的矩形数目，每组输出占一行
作法 DAG 上 DP, 求最長路徑 若矩型 a, 可嵌套在矩型 b, 則 a 連一條邊到 b 形成一 DAG
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 16; pii p[1010]; int dp[1010]; vector &amp;lt;int&amp;gt; g[1010]; bool ok(pii a, pii b){ if((a.</description></item><item><title>位元操作 Bit Operation</title><link>https://ptzu.github.io/posts/template-bit-operation/</link><pubDate>Sun, 11 Feb 2018 23:34:06 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bit-operation/</guid><description>待補
https://blog.kuoe0.tw/posts/2012/01/28/bitwise-operation-set-operation/</description></item><item><title>HDU 4281 - Judges' response (2012天津網路賽)</title><link>https://ptzu.github.io/posts/hdu4281/</link><pubDate>Sun, 11 Feb 2018 20:13:14 +0000</pubDate><guid>https://ptzu.github.io/posts/hdu4281/</guid><description>題目
input 多筆測資, 每筆測資輸入 N, M, 2 &amp;lt;= N &amp;lt;= 16, 0 &amp;lt;= M &amp;lt;= 100000 代表 N - 1 位參賽者舉手發問, 裁判的耐心 M 接著輸入 N 個座標, 第一個座標為所有裁判的位置, 其餘為參賽者位置 再輸入 N 個解答問題所需要的時間, 同樣第一個為裁判
題解 現有一場比賽, 有 N - 1 位參賽者同時舉手發問 我們知道解答某參賽者的問題, 需要耗費的時間 但是每位裁判有固定 M 的耐心, 也就是他最多只願意花 M 分鐘解答 因此需要多位裁判去替選手解答 現有兩個問題:(第一次遇到一次問兩題的XD)
至少需要多少位裁判才能解答所有問題？ 假如裁判數量充足, 求一條路線使得所有裁判行走的時間總和最短 距離採歐基里得距離取 ceil, 且每位裁判的行走速度為 1 注意所有裁判的起始位置都一樣 作法 第一題可視為 n 個物品, 至少需要幾個箱子才能裝完(位元DP, 01背包(?)) 第二題是 MTSP, 上面那題我們已經將一個集合視為一個箱子, 也就是一位裁判負責的狀況 接著稍微解說一下作法:</description></item><item><title>POJ 2084 Game of Connections</title><link>https://ptzu.github.io/posts/poj2084/</link><pubDate>Sat, 10 Feb 2018 14:41:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2084/</guid><description>題目
input 多筆測資, 每筆輸入 n, 1 &amp;lt;= n &amp;lt;= 100 輸入 -1 結束測資
題解 有 2 * n 個點順時針排序, 任兩點連線, 但線不准交叉 求有幾種連法
作法 卡塔蘭數 固定點 1, 向周圍的點畫線 可以把圖分成左右兩塊, 左右兩塊的點數都是偶數(因為奇數必不能兩兩互連) 我們可以得到以下結論 h(0) = 1,h(1) = 1 遞迴式：
h(n) = h(0)*h(n-1) + h(1)*h(n-2) + &amp;hellip; + h(n-1)h(0) (其中 n &amp;gt;= 2) 即為卡塔蘭數
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>卡塔蘭數 Catalan number</title><link>https://ptzu.github.io/posts/template-catalan-number/</link><pubDate>Sat, 10 Feb 2018 00:02:58 +0000</pubDate><guid>https://ptzu.github.io/posts/template-catalan-number/</guid><description>一般式: {%math%} C_{n} = \dfrac {1}{n+1}\binom{2n}{n} = \dfrac {\left( 2n\right) !}{\left( n+1\right) !n!} {%endmath%} 遞迴式: {%math%}C_{n} = \dfrac {4*n-2}{n+1}C_{n-1}{%endmath%} 若可以觀察出 h(0) = 1,h(1) = 1 h(n) = h(0)*h(n-1) + h(1)*h(n-2) + &amp;hellip; + h(n-1)h(0) (其中 n &amp;gt;= 2) 則有可能是卡塔蘭數 可用於 二元樹種類個數&amp;hellip;等問題
Code big fac[MAX_N * 2]; big res = fac[2 * n] / fac[n + 1] / fac[n]; 例題 Uva 10007 POJ 2084</description></item><item><title>Uva 10007 - Count the Trees</title><link>https://ptzu.github.io/posts/uva10007/</link><pubDate>Fri, 09 Feb 2018 22:17:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10007/</guid><description>題目
input 多筆測資, 每筆測資輸入 n, 1 &amp;lt;= n &amp;lt;= 300 代表 n 個結點 輸入 0 測資結束
題解 給 n 個點求有幾種不同結構的二元樹 因為不同數字也算不同, 所以再乘上 n!
作法 卡塔蘭數 + 大數
AC code import java.util.Scanner; import java.math.BigInteger; import java.util.*; public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); BigInteger[] fac = new BigInteger[601]; fac[0] = fac[1] = BigInteger.ONE; for(int i = 2; i &amp;lt;= 600; i++) fac[i] = fac[i - 1].</description></item><item><title>快速傅利葉轉換 FFT</title><link>https://ptzu.github.io/posts/template-fft/</link><pubDate>Fri, 09 Feb 2018 21:03:48 +0000</pubDate><guid>https://ptzu.github.io/posts/template-fft/</guid><description>Code const int N = 500005; const double PI = acos(-1.0); struct Virt{ double r,i; Virt(double r=0.0,double i=0.0){ this-&amp;gt;r=r; this-&amp;gt;i=i; } Virt operator+(const Virt &amp;amp;x){ return Virt(r+x.r,i+x.i); } Virt operator-(const Virt &amp;amp;x){ return Virt(r-x.r,i-x.i); } Virt operator*(const Virt &amp;amp;x){ return Virt(r*x.r-i*x.i,i*x.r+r*x.i); } }; //雷德算法--倒位序 void Rader(Virt F[],int len){ int j=len&amp;gt;&amp;gt;1; for(int i=1;i&amp;lt;len-1;i++){ if(i&amp;lt;j)swap(F[i],F[j]); int k = len &amp;gt;&amp;gt; 1; while(j&amp;gt;=k){ j-=k; k&amp;gt;&amp;gt;=1; } if(j&amp;lt;k)j+=k; } } //FFT实现 void FFT(Virt F[],int len,int on){ Rader(F, len); for(int h=2;h&amp;lt;=len;h&amp;lt;&amp;lt;=1) //分治后计算长度为h的DFT { Virt wn(cos(-on*2*PI/h),sin(-on*2*PI/h)); //单位复根e^(2*PI/m)用欧拉公式展开 for(int j=0; j&amp;lt;len; j+=h) { Virt w(1,0); //旋转因子 for(int k=j;k&amp;lt;j+h/2;k++) { Virt u=F[k]; Virt t=w*F[k+h/2]; F[k]=u+t; //蝴蝶合并操作 F[k+h/2]=u-t; w=w*wn; //更新旋转因子 } } } if(on==-1) for(int i=0;i&amp;lt;len;i++) F[i].</description></item><item><title>雙調TSP (Bitonic TSP)</title><link>https://ptzu.github.io/posts/template-bitonic-tsp/</link><pubDate>Thu, 08 Feb 2018 17:09:02 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bitonic-tsp/</guid><description>前言 從字面理解不知道是什麼怪東西。。。 據說是 CLRS 書 15-1 的習題, 有空再去翻看看~
簡單來說是 TSP 的簡化版, 限定從最左走到最右, 而且必須嚴格遞增/減 所以不再是 NP-Hard, 而是有 {%math%}O(n^{2}){%endmath%} 的作法
狀態 定義dp[i][j]: 從起點 1 出發, 走到 i 和 j 的最小總和(上下不同兩條路徑) dp[N][N] 即為答案, 因為可以看成 1 走到 N, N 走到 1 轉移 要怎麼保證上下兩條路徑, 不會走到相同的點呢？ 針對每個點, 每次只會把它放到上面或下面的路徑 假設目前要加的點是 j 上面那條路的最後點有可能是 1 ~ j - 1 分為兩個 case 討論
i &amp;lt; j - 1 點 j 可以從 j - 1 推導過來 dp[i][j] = dp[i][j - 1] + dis[j - 1][j], for i &amp;lt; j - 1 2.</description></item><item><title>POJ 2677 Tour</title><link>https://ptzu.github.io/posts/poj2677/</link><pubDate>Thu, 08 Feb 2018 17:00:43 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2677/</guid><description>題目
input 含多筆測資, 每筆測資開頭輸入 n, 代表 n 個點 接著輸入 n 個點的 x, y 座標 x 座標為遞增
題解 從最左邊的點, 嚴格遞增走到右邊 然後再從最右邊嚴格遞減走回起點, 求這路程的最小距離
作法 Bitonic TSP 這題要注意, double 要用 %f 輸出而不是 %lf 才能過 猜測是精度的問題, 不影響題意理解
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;cmath&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 100; struct point{ double x, y; }; int n; point p[MAX_N]; double dis[MAX_N][MAX_N]; double dp[MAX_N][MAX_N]; double get_dis(point a, point b){ return sqrt((a.</description></item><item><title>ZJ b177 [TIOJ 1471] 山景 Skyline</title><link>https://ptzu.github.io/posts/zj-b177/</link><pubDate>Wed, 07 Feb 2018 14:38:51 +0000</pubDate><guid>https://ptzu.github.io/posts/zj-b177/</guid><description>題目
input 輸入 n, n必為偶數, n &amp;lt;= 3000
題解 一座山的山稜線由許多片段的45度斜坡構成，每一個片段不是上坡就是下坡。
/\ /\/ \ / \ 在我們眼前的所見的任何寬度為n個單位的山稜形狀，可以輕鬆地觀察到所有山頂的位置。
請問有多少種山稜線的形狀，使得所有山頂的位置由左而右非遞減呢？
所有的山稜線都必須完整，也就是說左右兩端都必須是高度為0的山腳，而且不能有任何山谷的位置隱沒在地平線底下。
這題在 2017中程盃 有出現類似題 這題的要求是山頂必須非遞減, 而中程盃那題是問 r 個高度為 k 的山頂有幾種畫法
作法 一開始想法是定義 dp[i][j] 為走 i 步高度為 j 有幾種畫法 而遞迴式是 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1] 不過這樣沒辦法保證山頂非遞減 後來參考 morris 的答案 想了整天, 最後畫圖才理解 首先定義 dp[i][j]: 第 i 條線, 高度 j 的點有幾種畫法 不難想像, 轉移方程式可以寫成 dp[i][j] = dp[i - 1][j - 1] 高度 j 當然可以從 j - 1 轉移過來 但還有個需要考慮的是, 同高度的也能轉移過來 而同高度的可以從不只一個地方轉移, 所以用 sum[j] 代表高度 j 的畫法 因此遞迴式變成這樣: dp[i][j] = dp[i - 1][j - 1] + sum[j] 我們稍微把圖畫得複雜一點: sum[j] 的遞迴方式是: sum[j] - dp[i - j][j] + dp[i][j] dp[i - j][j] 已經走到高度為 0 的路線 因此之後已經沒有路線可以走, 簡單來說就是被 dp[i][j] 取代掉 所以必須扣掉避免重複 而答案即是第 i 條線上面各種高度的總和</description></item><item><title>Uva 10032 - Tug of War</title><link>https://ptzu.github.io/posts/uva10032/</link><pubDate>Mon, 05 Feb 2018 15:07:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10032/</guid><description>題目
input 第一列輸入 T, 代表 T case 每筆測資開頭輸入 n, n 最多 100 接著輸入 n 個人的體重
題解 將人分成兩堆, 使兩隊的體重和相差最小 並且兩隊人數最多只能差 1
作法 這題類似 Uva 562, 分成兩堆, 使得總和差最小 但是多了一個限制是人數只能差 1 原本是 dp[人數][重量] = 0 or 1, 代表該重量能否組出 現在多一個條件 dp[人數][重量][目前人數] = 0 or 1 的三維DP 但是會超時 我們把第三維度利用位元操作, 轉為 64 bits 的資料 也就是 dp[人數][重量] = bitset 而那個 bitset 代表的是組出這個重量, 那一隊可以有幾人 例如 dp[人數][重量] = 1110(二進位) 就代表他可以用 1(2^1)、2(2^2)、3(2^3) 這些人數組成 最後只要看 n/2、n/2+1(偶數人數), n/2(奇數人數)的 bit 是否成立即可
AC code #include &amp;lt;bits/stdc++.</description></item><item><title>Floyd Warshall</title><link>https://ptzu.github.io/posts/template-floyd-warshall/</link><pubDate>Mon, 05 Feb 2018 12:55:12 +0000</pubDate><guid>https://ptzu.github.io/posts/template-floyd-warshall/</guid><description>全點對最短路徑 時間複雜度: {%math%}O(n^{3}){%endmath%}
Code void floyd(int V){ for(int k = 0; k &amp;lt; V; k++){ for(int i = 0; i &amp;lt; V; i++){ for(int j = 0; j &amp;lt; V; j++){ d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } }</description></item><item><title>HDU 5418 - Victor and World</title><link>https://ptzu.github.io/posts/hdu5418/</link><pubDate>Mon, 05 Feb 2018 12:49:00 +0000</pubDate><guid>https://ptzu.github.io/posts/hdu5418/</guid><description>題目
input 第一列輸入 T, 代表 T case 每筆測資開頭輸入 n, m, 1 &amp;lt;= n &amp;lt;= 16, 1 &amp;lt;= m &amp;lt;= 100000 代表 n 個點, m 條邊 每條邊都是無向邊 輸入 u, v, w 代表 u 到 v 花費 w
題解 Victor 想環遊世界, 求拜訪每個國家並回到起點的最少花費 每個國家可拜訪不只一次
作法 同 POJ 3311 只是這題的距離不是給相鄰矩陣 先用 floyd 求一下距離
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>位元DP</title><link>https://ptzu.github.io/posts/template-digit-dp/</link><pubDate>Sun, 04 Feb 2018 11:54:45 +0000</pubDate><guid>https://ptzu.github.io/posts/template-digit-dp/</guid><description>以 旅行推銷員問題(TSP) 為例 複雜度: {%math%} O(2^{n}n^{2}) {%endmath%}
BOTTOM UP 狀態 S代表目前已經走過的點集合, v為目前的點 dp[S][v]: 已經走完 S, 目前在 v, 所花費的最小權重和 轉移 找一點不在集合的點 u, 列舉集合的點 v 走到 u 的距離 {%math%}dp[S | (1 &amp;laquo; u)][u] = min\left { dp[S | (1 &amp;laquo; u)][i], dp[S][v] + d[v][u], u \notin S \right }{%endmath%}
Code for(int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; n); i++) fill(dp[i], dp[i] + n, INF); dp[1][0] = 0; for(int S = 1; S &amp;lt; (1 &amp;lt;&amp;lt; n); S++){ for(int i = 0; i &amp;lt; n; i++){ if((S &amp;amp; (1 &amp;lt;&amp;lt; i)) == 0){ for(int j = 0; j &amp;lt; n; j++){ if(S &amp;amp; (1 &amp;lt;&amp;lt; j)) dp[S | (1 &amp;lt;&amp;lt; i)][i] = min(dp[S | (1 &amp;lt;&amp;lt; i)][i], dp[S][j] + d[j][i]); } } } } TOP DOWN 作法 top-down 的作法, 我覺得有點難想, 要搭配圖案</description></item><item><title>POJ 3311 Hie with the Pie</title><link>https://ptzu.github.io/posts/poj3311/</link><pubDate>Sun, 04 Feb 2018 01:33:35 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3311/</guid><description>題目
input 含多筆測資, 每筆測資開頭輸入 n, 1 &amp;lt;= n &amp;lt;= 10 代表除了起點以外, 有幾個點 接著輸入相鄰矩陣代表點之間的距離
題解 這題規定每個點可不只經過一次 然後 TSP 是限定每個點只能有一次 需要做點小修改
作法 TSP裸題
AC code bottom up 作法
#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 11; int d[MAX_N][MAX_N]; int dp[1 &amp;lt;&amp;lt; MAX_N][MAX_N]; void floyd(int V){ for(int k = 0; k &amp;lt; V; k++){ for(int i = 0; i &amp;lt; V; i++){ for(int j = 0; j &amp;lt; V; j++){ d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } int main(){ int n; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Uva 562 - Dividing coins</title><link>https://ptzu.github.io/posts/uva562/</link><pubDate>Fri, 02 Feb 2018 19:16:02 +0000</pubDate><guid>https://ptzu.github.io/posts/uva562/</guid><description>題目
input 第一列輸入 Test Case 每筆測資開頭輸入 n, 表有 n 種硬幣 接著輸入 n 種硬幣
題解 兩人分錢
作法 要使差距最小, 那就是愈接近一半愈好 把金額當作背包, 使得背包裡的價值愈大愈好
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 60000; int n; int a[110]; int dp[50505]; int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(dp, 0, sizeof(dp)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); int sum = 0; for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); sum += a[i]; } int m = sum / 2; for(int i = 0; i &amp;lt; n; i++){ for(int j = m; j &amp;gt;= a[i]; j--) dp[j] = max(dp[j], dp[j - a[i]] + a[i]); } printf(&amp;#34;%d\n&amp;#34;, (sum - dp[m]) - dp[m]); } return 0; }</description></item><item><title>0/1 背包問題</title><link>https://ptzu.github.io/posts/template-01knaspack/</link><pubDate>Fri, 02 Feb 2018 17:11:55 +0000</pubDate><guid>https://ptzu.github.io/posts/template-01knaspack/</guid><description>狀態 dp[i] = 在背包容量 i 情況下的最大價值 轉移 dp[j] = max(dp[j - wi] + vi), for i &amp;lt; n Code 例題 Uva 10130 POJ 3624</description></item><item><title>主席樹 Chairman Tree</title><link>https://ptzu.github.io/posts/template-chairman-tree/</link><pubDate>Fri, 02 Feb 2018 16:33:45 +0000</pubDate><guid>https://ptzu.github.io/posts/template-chairman-tree/</guid><description>Code 例題 POJ 2104 帶修改: ZOJ 2112(記憶體限制很緊)</description></item><item><title>ZOJ 2112 Dynamic Rankings</title><link>https://ptzu.github.io/posts/zoj2112/</link><pubDate>Fri, 02 Feb 2018 12:16:07 +0000</pubDate><guid>https://ptzu.github.io/posts/zoj2112/</guid><description>題目
input 題解 作法 帶修改的主席樹
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 60000; int N, M, SZ, cnt; int a[MAX_N + 10]; vector &amp;lt;int&amp;gt; pool; struct node{ int l, r, val; }T[MAX_N * 40]; int root[MAX_N + 10], BIT[MAX_N + 10], use[MAX_N]; struct q{ int type, l, r, k; }Q[10010]; void init(){ cnt = 0; pool.</description></item><item><title>POJ 2104 K-th Number</title><link>https://ptzu.github.io/posts/poj2104/</link><pubDate>Sun, 28 Jan 2018 12:31:22 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2104/</guid><description>題目
input 給兩正整數 n, m, 1 &amp;lt;= n &amp;lt;= 100000, 1 &amp;lt;= m &amp;lt;= 5000 代表 n 個數字, m 個查詢 第二列輸入 n 個不超過 10^9 的數字 接著每個查詢輸入 l, r, k 代表問區間 [l, r] 的第 k 大數字
題解 給一序列, 然後不斷問不同區間的第 k 大數字 目前看到的作法有 歸併樹、劃分樹、可持久化線段樹(主席樹)、平方分解
作法 離散化 + 主席樹
AC Code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>樹狀數組 Binary Indexed Tree</title><link>https://ptzu.github.io/posts/template-bit/</link><pubDate>Wed, 24 Jan 2018 16:36:06 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bit/</guid><description>可做到:
單點更新 前綴和查詢(範圍查詢) 注意是 1-based index
Code const int MAX_N = 20000; int bit[MAX_N + 10]; int add(int i, int x){ while(i &amp;lt;= n){ bit[i] += x; i += i &amp;amp; -i; } } int sum(int i){ int ans = 0; while(i){ ans += bit[i]; i -= i &amp;amp; -i; } return ans; } 例題 POJ 1990</description></item><item><title>POJ 1990 MooFest</title><link>https://ptzu.github.io/posts/poj1990/</link><pubDate>Wed, 24 Jan 2018 16:13:21 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1990/</guid><description>題目
input 第一列輸入一正整數 N, 1 &amp;lt;= N &amp;lt;= 20000 代表 N 頭牛 接著輸入每頭牛的耳背值 v, 位置 x
題解 有 N 頭牛想互相交談 任兩頭牛交談產生的音量是 max(vi, vj) * 距離 求兩兩交談後產生的總音量是多少
作法 如果直接枚舉就炸了 那我們處理的時候一定是選耳背值最大的那個 所以就從耳背值小到大一個一個處理 在處理第 i 個的時候 我們想知道這頭牛, 左邊有幾頭, 右邊有幾頭？ 也想知道左邊的座標和是多少, 右邊的座標和是多少？ 這時候如果每次都去算一次, 那就跟直接枚舉一樣了 所以就交給 BIT 去算！ num_bit: 代表到 pos[i] 總共有幾頭牛 dis_bit: 代表到 pos[i] 的座標總和
每做完一頭牛記得要把他加入到 BIT 裡
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 3468 A Simple Problem with Integers</title><link>https://ptzu.github.io/posts/poj3468/</link><pubDate>Wed, 24 Jan 2018 10:58:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3468/</guid><description>題目
input 第一列含兩個正整數 N, Q, 1 ≤ N,Q ≤ 100000 分別代表 N 個正整數和 Q 個操作 輸入 N 個整數 A, -1000000000 ≤ A ≤ 1000000000 接著輸入 Q 個操作 有兩種操作
C a b c: 對 a ~ b 範圍加 c Q a b: 查詢 a ~ b 範圍的和 題解 不斷的對區間修改和查詢 跟著做一定會超時 所以用線段樹
作法 線段樹裸題
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>線段樹 Segment Tree</title><link>https://ptzu.github.io/posts/template-segment-tree/</link><pubDate>Wed, 24 Jan 2018 10:14:23 +0000</pubDate><guid>https://ptzu.github.io/posts/template-segment-tree/</guid><description>可做到:
範圍更新 範圍查詢 主要有兩種版本 一種是直接開 input 大小, 另一種是開滿 2 的倍數 陣列大小一定要開到 input 的 4 倍 原因是線段樹本身就需要 2 * N 的空間 樹高會是 {%math%}\left \lceil log_{2}N \right \rceil{%endmath%} 所以可能會多一層 (不管有沒有補滿 2 的倍數都會)
經過測試 update 的時候一定要 push 再 pull query 可以只做 push 就好
Code 這種寫法是直接開 input 大小 1-indexed, 閉區間 [l, r] 在時間上和空間上都比較優秀 缺點是要 trace 的時候不太好做
#define L(x) (x&amp;lt;&amp;lt;1) #define R(x) (1+(x&amp;lt;&amp;lt;1)) #define mid ((l+r)&amp;gt;&amp;gt;1) const int MAX_N = 101010; int seg[MAX_N * 4], lazy[MAX_N * 4]; int a[MAX_N]; void seg_build(int idx, int l, int r){ if(l == r){ seg[idx] = a[l]; return ; } seg_build(L(idx), l, mid); seg_build(R(idx), mid + 1, r); seg[idx] = seg[L(idx)] + seg[R(idx)]; } void seg_push(int idx, int l, int r){ if(lazy[idx]){ seg[L(idx)] += lazy[idx] * (mid - l + 1); seg[R(idx)] += lazy[idx] * (r - (mid + 1) + 1); lazy[L(idx)] += lazy[idx]; lazy[R(idx)] += lazy[idx]; lazy[idx] = 0; } } void seg_update(int a, int b, int x, int idx, int l, int r){ if(r &amp;lt; a || l &amp;gt; b) return ; if(a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b){ seg[idx] += (r - l + 1) * x; lazy[idx] += x; return ; } seg_push(idx, l, r); seg_update(a, b, x, L(idx), l, mid); seg_update(a, b, x, R(idx), mid + 1, r); seg[idx] = seg[L(idx)] + seg[R(idx)]; } int seg_query(int a, int b, int idx, int l, int r){ if(r &amp;lt; a || l &amp;gt; b) return 0; if(a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b) return seg[idx]; seg_push(idx, l, r); return seg_query(a, b, L(idx), l, mid) + seg_query(a, b, R(idx), mid + 1, r); } Code 這是開滿 2 的倍數版本 0-indexed, 開區間 [l, r)</description></item><item><title>Codeforces Hello 2018</title><link>https://ptzu.github.io/posts/cfhello2018/</link><pubDate>Sat, 13 Jan 2018 15:31:50 +0000</pubDate><guid>https://ptzu.github.io/posts/cfhello2018/</guid><description>目錄 取模 判斷樹的孩子數量 檸檬汁購買 A. Modular Exponentiation 題目
input 輸入兩個正整數 n, m, 1 &amp;lt;= n,m &amp;lt;= 10^8
題解 求 m mod 2^n
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 1010; int main(){ int n, m; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); int mod = 1; if(n &amp;gt;= 32){ printf(&amp;#34;%d\n&amp;#34;, m); } else{ for(int i = 1; i &amp;lt;= n; i++) mod &amp;lt;&amp;lt;= 1; printf(&amp;#34;%d\n&amp;#34;, m % mod); } return 0; } B.</description></item><item><title>Kruskal Algorithm</title><link>https://ptzu.github.io/posts/template-kruskal/</link><pubDate>Fri, 12 Jan 2018 13:23:37 +0000</pubDate><guid>https://ptzu.github.io/posts/template-kruskal/</guid><description>時間瓶頸在排序 複雜度： O(ElogV)
Code struct Union_Find { int par[1010], num[1010]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U; struct edge{ int u, v, w; bool operator &amp;lt;(const edge&amp;amp; e) const{ return w &amp;lt; e.</description></item><item><title>POJ 2421 Constructing Roads</title><link>https://ptzu.github.io/posts/poj2421/</link><pubDate>Fri, 12 Jan 2018 13:11:08 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2421/</guid><description>題目
input 第一行輸入正整數 N, 3 &amp;lt;= N &amp;lt;= 100 代表有 N 個村莊 接著輸入一個 N * N 的相鄰矩陣, 代表邊 然後輸入一個正整數 q 接著 q 行輸入 a, b 代表 a, b 之間已經有建好路
題解 建路需要成本, 已經有些路建好 求要連接所有村莊, 最小成本是多少？
作法 求 MST, 不過這題範圍比較小 所以我拿來測試 Sollin 演算法
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;climits&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Sollin Algorithm</title><link>https://ptzu.github.io/posts/template-sollin/</link><pubDate>Fri, 12 Jan 2018 12:59:18 +0000</pubDate><guid>https://ptzu.github.io/posts/template-sollin/</guid><description>求 MST, 不過速度有點慢
Code truct edge{ int u, v, w; }; struct Union_Find { int par[1010], num[1010]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U; edge edges[100000]; int V, E; int mn[1000]; int ComponentSize; // 一開始等於V int sollin(){ int ans = 0; while(ComponentSize &amp;gt; 1){ for(int i = 0; i &amp;lt; V; i++) mn[i] = INT_MAX; // 找出每個 Component 的最小邊是誰 for(int i = 0; i &amp;lt; E; i++){ edge e = edges[i]; int a = U.</description></item><item><title>String 切 Token</title><link>https://ptzu.github.io/posts/string-token/</link><pubDate>Fri, 12 Jan 2018 12:46:31 +0000</pubDate><guid>https://ptzu.github.io/posts/string-token/</guid><description>有兩種方法
將 string 轉為 c 字串, 然後用 strtok 利用 stringstream 第一種：
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; string s; int main(){ while(getline(cin, s)){ char cstr[10000]; strcpy(cstr, s.c_str()); char *token = strtok(cstr, &amp;#34; &amp;#34;); while(token != NULL){ printf(&amp;#34;%s &amp;#34;, token); token = strtok(NULL, &amp;#34; &amp;#34;); } puts(&amp;#34;&amp;#34;); } return 0; } 第二種:
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; string s; stringstream ss; int main(){ while(getline(cin, s)){ ss.str(&amp;#34;&amp;#34;); ss.clear(); // 上面兩行是清空 stringstream, 兩行都必加 ss &amp;lt;&amp;lt; s; int n; while(ss &amp;gt;&amp;gt; n){ cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; endl; } return 0; } 測試資料:</description></item><item><title>Bipartite Matching</title><link>https://ptzu.github.io/posts/template-bipartite-matching/</link><pubDate>Sat, 06 Jan 2018 16:19:43 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bipartite-matching/</guid><description>匈牙利演算法(Hungarian Algorithm) 時間複雜度: O({%math%}n^{3}{%endmath%})
Code const int MAX_V = 1010; int V; vector &amp;lt;int&amp;gt; g[MAX_V]; int match[MAX_V]; bool vis[MAX_V]; void add_edge(int u, int v){ g[u].pb(v); g[v].pb(u); } bool dfs(int u){ vis[u] = true; for(int i = 0; i &amp;lt; sz(g[u]); i++){ int v = g[u][i], w = match[v]; if(w &amp;lt; 0 || (!vis[w] &amp;amp;&amp;amp; dfs(w))){ match[u] = v; match[v] = u; return true; } } return false; } int bipartite_matching(){ int res = 0; memset(match, -1, sizeof(match)); for(int i = 0; i &amp;lt; V; i++){ if(match[i] &amp;lt; 0){ memset(vis, 0, sizeof(vis)); if(dfs(i)) res++; } } return res; }</description></item><item><title>POJ 3041 Asteroids</title><link>https://ptzu.github.io/posts/poj3041/</link><pubDate>Sat, 06 Jan 2018 11:24:59 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3041/</guid><description>題目
input 第一列輸入兩個正整數 N, K, 代表 N * N 的地圖, 和 K 顆行星
題解 現在你有兩種武器, 分別可以射出橫的或直的射線 被射線射到的行星就會被摧毀 現有 k 顆行星 請問最少要幾次射線才能摧毀全部行星
作法 最小點涵蓋
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 1010; int V; vector &amp;lt;int&amp;gt; g[MAX_V]; int match[MAX_V]; bool vis[MAX_V]; void add_edge(int u, int v){ g[u].</description></item><item><title>Max Flow</title><link>https://ptzu.github.io/posts/template-dinic/</link><pubDate>Thu, 04 Jan 2018 19:13:59 +0000</pubDate><guid>https://ptzu.github.io/posts/template-dinic/</guid><description>Dinic 演算法 時間複雜度: O({%math%}EV^{2}{%endmath%})
Code struct edge{ int to, cap, rev; }; vector &amp;lt;edge&amp;gt; g[MAX_V]; int iter[MAX_V]; int level[MAX_V]; void add_edge(int u, int v, int w){ g[u].pb((edge){v, w, sz(g[v])}); g[v].pb((edge){u, 0, sz(g[u]) - 1}); } void bfs(int S){ memset(level, -1, sizeof(level)); queue &amp;lt;int&amp;gt; q; level[S] = 0; q.push(S); while(!q.empty()){ int v = q.front(); q.pop(); for(int i = 0; i &amp;lt; sz(g[v]); i++){ edge&amp;amp; e = g[v][i]; if(e.cap &amp;gt; 0 &amp;amp;&amp;amp; level[e.</description></item><item><title>POJ 3281 Dining</title><link>https://ptzu.github.io/posts/poj3281/</link><pubDate>Thu, 04 Jan 2018 19:13:50 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3281/</guid><description>題目
input 第一列輸入3個正整數 N, F, D, 1 &amp;lt;= N, F, D &amp;lt;= 100 分別代表 N 頭牛, F 種食物, D 種飲料 接下來 N 行, 每列開頭有兩個正整數 f, d 分別代表那頭牛喜歡的食物, 飲料數量 緊接著輸入他喜歡的食物和飲料
題解 每頭牛有自己喜歡的食物, 飲料種類 若要填飽一頭牛, 他必須要有食物和飲料 每種食物和飲料只能被分配一次(也就是不能分給其他牛) 請問最多有幾頭牛被填飽
作法 最大流經典題 待補圖
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>XDoj 1077 - 循环节长度</title><link>https://ptzu.github.io/posts/xdoj1077/</link><pubDate>Thu, 04 Jan 2018 12:04:29 +0000</pubDate><guid>https://ptzu.github.io/posts/xdoj1077/</guid><description>題目
input 多筆測資, 輸入 a, b 0 &amp;lt;= a, b &amp;lt;= 10^9
題解 因為循環節長度最長不超過分母 而這題的分母很大, 不能用模擬除法 所以用 BSGS 來求離散對數
作法 根據定理 a / b 的循環節長度為: {% math %} \min { e\in N,10^{e}\equiv 1(mod\ b) } {% endmath %} 但要注意的是當 e == 0 的時候恆成立 所以我們需要小修改一下 BSGS 演算法
我們可以注意到當 e == 0 時, 是在列舉到 {% math %} a^{m} {% endmath %} 時相等 所以我們在建立 hash 表的時候, 只要建到 m - 1, 就可以避開這個 case 了</description></item><item><title>BSGS Algorithm</title><link>https://ptzu.github.io/posts/template-bsgs/</link><pubDate>Wed, 03 Jan 2018 23:08:32 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bsgs/</guid><description>求離散對數 時間複雜度: O({%math%}\sqrt {n}{%endmath%})
Code map &amp;lt;ll, int&amp;gt; mp; //value, idx int fastpow(ll a, ll b){ ll base = a, ans = 1; while(b){ if(b &amp;amp; 1) ans = ans * base % P; base = base * base % P; b &amp;gt;&amp;gt;= 1; } return ans; } int BSGS(int a, int b, int P){ mp.clear(); int m = ceil(sqrt(P)); ll value = b % P; // j = 0, value = b mp[value] = 0; for(int j = 1; j &amp;lt;= m; j++){ value = value * a % P; // a^j * b mp[value] = j; } ll t = fastpow(a, m, P); // a ^ m value = 1; for(int i = 1; i &amp;lt;= m; i++){ value = value * t % P; // a ^ (i*m) if(mp.</description></item><item><title>POJ 3259 Wormholes</title><link>https://ptzu.github.io/posts/poj3259/</link><pubDate>Sun, 31 Dec 2017 14:39:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3259/</guid><description>題目
input 含多筆測資, 第一列有一正整數代表接下來有幾筆測資 每筆測資開頭有 3 個正整數 1 &amp;lt;= N &amp;lt;= 500, 1 &amp;lt;= M &amp;lt;= 2500, 1 &amp;lt;= W &amp;lt;= 200 分別代表 N 個點, M 條邊, W 條負邊 接著輸入 M 條邊和 W 條負邊
題解 蟲洞是一條單向路徑, 可以回到過去的時間, 所以等於一條負邊 題目問是否能從一個點開始走, 然後走一走之後, 發現時間比開始的時候還早 那也就是圖中含有負環
作法 可以用 Bellman 或 SPFA 來偵測
AC code #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Codeforces Round 454</title><link>https://ptzu.github.io/posts/cf454/</link><pubDate>Sun, 24 Dec 2017 14:13:13 +0000</pubDate><guid>https://ptzu.github.io/posts/cf454/</guid><description>目錄 暴力列舉 大型 OOXX 猜字元 A. Masha and Bears 題目
input 給四正整數, V1, V2, V3, Vm, 1 &amp;lt;= V &amp;lt;= 100 分別代表 熊爸, 熊媽, 小熊, Masha 的大小
題解 設熊的尺寸 a, 車的尺寸 b 可以上車的條件為 a &amp;lt;= b 喜歡那台車的條件為 可以上車且 b &amp;lt;= 2 * a 熊爸喜歡最大的車, 熊媽喜歡中型的車, 小熊喜歡最小的車 Masha &amp;ldquo;只&amp;rdquo; 喜歡最小的車
作法 暴力列舉就好, 唯一要注意的是 Masha 只喜歡最小的車 所以中型車必須 b &amp;gt; 2 * a
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Prim Algorithm</title><link>https://ptzu.github.io/posts/template-prim/</link><pubDate>Fri, 22 Dec 2017 14:07:32 +0000</pubDate><guid>https://ptzu.github.io/posts/template-prim/</guid><description>基本上和 Dijkstra 一樣 只是 d[ ] 從到原點的距離改成到樹的距離
Code struct Edge{ int to, w; }; vector &amp;lt;Edge&amp;gt; g[MAX_V]; int d[MAX_V]; bool inTree[MAX_V]; int V, E; int prim(int S){ priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt;pq; fill(d, d + V, INF); memset(inTree, 0, sizeof(inTree)); d[S] = 0; pq.push((pii){0, S}); int res = 0, cnt = 0;; while(!pq.empty()){ pii top = pq.top(); pq.pop(); int u = top.nd; if(inTree[u] || d[u] &amp;lt; top.st) continue; inTree[u] = true; // 加到樹裡面 res += d[u]; cnt++; // 看是否有每個點都被連上 for(int i = 0; i &amp;lt; sz(g[u]); i++){ Edge e = g[u][i]; // 更新距離 if(e.</description></item><item><title>SPFA</title><link>https://ptzu.github.io/posts/template-spfa/</link><pubDate>Fri, 22 Dec 2017 14:07:27 +0000</pubDate><guid>https://ptzu.github.io/posts/template-spfa/</guid><description>可偵測負環 和 Dijkstra 差不多, 多用了 cnt 陣列去紀錄每個點被更新幾次 如果有個點被更新超過 V 次, 代表有負環
Code struct Edge { int to, w; }; const int MAX_V = ...; int V; vector&amp;lt;Edge&amp;gt; g[MAX_V]; int d[MAX_V]; int cnt[MAX_V]; bool SPFA(int S) { // 回傳有無負環 fill(d, d + V, INF); fill(cnt, cnt + V, 0); priority_queue&amp;lt; pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; pq; d[S] = 0; pq.push(pii(0, S)); cnt[S] = 1; while (!pq.empty()) { pii top = pq.top(); pq.</description></item><item><title>Bellman Ford</title><link>https://ptzu.github.io/posts/template-bellman-ford/</link><pubDate>Fri, 22 Dec 2017 14:07:15 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bellman-ford/</guid><description>Code struct Edge{ int from, to, w; }; int V, E; int d[MAX_V]; int cnt[MAX_V]; vector &amp;lt;Edge&amp;gt; edges; set &amp;lt;int&amp;gt; ring; // 紀錄負環 void bellman(int S){ fill(d, d + V, INF); d[S] = 0; // 因為邊的順序不一定, 所以負環不一定每輪都會被更新, 多跑幾次 for(int i = 0; i &amp;lt; V + 10; i++){ for(int j = 0; j &amp;lt; E; j++){ Edge e = edges[j]; if(d[e.from] + e.w &amp;lt; d[e.to]){ d[e.to] = d[e.from] + e.</description></item><item><title>Uva 10420 - List of Conquests</title><link>https://ptzu.github.io/posts/uva10420/</link><pubDate>Fri, 22 Dec 2017 13:22:06 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10420/</guid><description>題目
input 第一列有一正整數 n, n &amp;lt;= 2000 接下來有 n 列, 每列最多 75 字 每列第一個字為國家, 後面接著女生的名字
題解 統計每個國家有幾個人
作法 用 map 去對應國家和人數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX map &amp;lt;string, int&amp;gt; mp; int main(){ fio; int n; cin &amp;gt;&amp;gt; n; string s, name; for(int i = 0; i &amp;lt; n; i++){ cin &amp;gt;&amp;gt; s; getline(cin, name); mp[s]++; } for(auto it : mp){ cout &amp;lt;&amp;lt; it.</description></item><item><title>Uva 10101 - Bangla Numbers</title><link>https://ptzu.github.io/posts/uva10101/</link><pubDate>Fri, 22 Dec 2017 12:56:33 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10101/</guid><description>題目
input 含多筆測資, 每筆測資輸入一個 long long 範圍內的非負整數
題解 把數字轉為題目規定的單位 kuti: 10000000 lakh: 100000 hajar: 1000 shata: 100 要注意的是, 單位前面的數字可能也可以轉為單位
作法 模擬
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX void print(ll n){ if(n &amp;gt;= 10000000){ print(n / 10000000); printf(&amp;#34; kuti&amp;#34;); n %= 10000000; } if(n &amp;gt;= 100000){ print(n / 100000); printf(&amp;#34; lakh&amp;#34;); n %= 100000; } if(n &amp;gt;= 1000){ print(n / 1000); printf(&amp;#34; hajar&amp;#34;); n %= 1000; } if(n &amp;gt;= 100){ print(n / 100); printf(&amp;#34; shata&amp;#34;); n %= 100; } if(n !</description></item><item><title>Uva 10929 - You can say 11</title><link>https://ptzu.github.io/posts/uva10929/</link><pubDate>Fri, 22 Dec 2017 12:18:32 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10929/</guid><description>題目
input 含多筆測資, 每筆測資為 1000 位數的數字, 輸入 0 為結束 注意數字可能有前綴 0 (卡這種東西真的很無聊, 題目又沒講)
題解 輸入一個數字, 判斷是否為 11 的倍數
作法 因為有 1000 位, 用字串來處理 (奇位數和 - 偶位數和) 是 11 的倍數的話, 該數可被 11 整除
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX char s[2000]; int main(){ while(scanf(&amp;#34;%s&amp;#34;, s) !</description></item><item><title>Uva 100 - The 3n + 1 problem</title><link>https://ptzu.github.io/posts/uva100/</link><pubDate>Fri, 22 Dec 2017 11:54:04 +0000</pubDate><guid>https://ptzu.github.io/posts/uva100/</guid><description>題目
input 多筆測資, 每筆測資含兩個正整數 a, b 0 &amp;lt; a, b &amp;lt; 1000000 (題目寫10000是錯的)
題解 目前有一個猜測還未被證實 給任意一個數 n, 如果是奇數就 n * 3 + 1, 否則就 n / 2 則最後一定會變成 1 則中間變化的過程稱為 cycle length(包含自己) 給 a, b 兩數, 求之間的數最大的 cycle length 注意變化過程在 32 bits integer內 所以要用 unsigned
作法 模擬
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 10035 - Primary Arithmetic</title><link>https://ptzu.github.io/posts/uva10035/</link><pubDate>Fri, 22 Dec 2017 11:00:09 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10035/</guid><description>題目
input 多筆測資, 每筆輸入兩個 10 位的正整數 輸入 0 0 代表結束
題解 兩個數字相加, 求有幾次進位
作法 用大數加法去算有幾次進位
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ fio; string s1, s2; while(cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2){ if(s1 == &amp;#34;0&amp;#34; &amp;amp;&amp;amp; s2 == &amp;#34;0&amp;#34;) break; if(s1.</description></item><item><title>Uva 10041 - Vito's Family</title><link>https://ptzu.github.io/posts/uva10041/</link><pubDate>Fri, 22 Dec 2017 09:03:09 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10041/</guid><description>題目
input 含有多筆測資, 每筆測資開頭有一正整數 r, 0 &amp;lt; r &amp;lt;= 500 接著有 r 個正整數 s, 0 &amp;lt; s &amp;lt; 30000
題解 想找一間房子離其它親戚最近
作法 到其它點的距離和最小, 找中位數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int a[1000]; int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); } sort(a, a + n); int mid = a[n / 2]; int ans = 0; for(int i = 0; i &amp;lt; n; i++) ans += abs(mid - a[i]); printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; }</description></item><item><title>Uva 10004 - Bicoloring</title><link>https://ptzu.github.io/posts/uva10004/</link><pubDate>Mon, 18 Dec 2017 22:09:08 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10004/</guid><description>題目
input 含有多筆測資, 每筆測資開頭有一正整數 n, 表 n 個點 接著含一正整數 l, 表 l 條邊 每條邊輸入 u, v, 代表 u 和 v 之間相連
題解 在 1976 年證明任何一張圖可以用 4 個顏色塗完, 相鄰兩點必須為不同顏色 而你現在要判斷是否能用兩個顏色塗完
作法 判斷二分圖裸題, 用DFS下去著色 如果相鄰的點和自己顏色一樣 就不是二分圖
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 210; vector &amp;lt;int&amp;gt; g[MAX_N]; int color[MAX_N]; bool dfs(int x, int c){ color[x] = c; bool ok = true; for(int i = 0; i &amp;lt; sz(g[x]); i++){ int v = g[x][i]; if(color[v] == 0) ok = min(ok, dfs(v, -c)); else if(color[v] == color[x]) return false; } return ok; } int main(){ int V, E; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;V) &amp;amp;&amp;amp; V){ for(int i = 0; i &amp;lt; MAX_N; i++) g[i].</description></item><item><title>Uva 10057 - A mid-summer night's dream.</title><link>https://ptzu.github.io/posts/uva10057/</link><pubDate>Mon, 18 Dec 2017 21:40:11 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10057/</guid><description>題目
input 含有多筆測資, 每筆測資開頭有一正整數 N 接著有 N 個數, 每個數不超過65536
題解 找出一個數, 使它與其他數的絕對值差, 總和最小 輸出符合條件最小的數, 以及 input 中有幾個這樣的數, 還有所有符合條件的數(含input以外的數)
作法 找中位數, 當有偶數個的時候, 兩個中位數之間的數也都符合條件
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 1000000; int v[1000010]; int main(){ int n; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Uva 12019 - Doom's Day Algorithm</title><link>https://ptzu.github.io/posts/uva12019/</link><pubDate>Mon, 18 Dec 2017 20:06:57 +0000</pubDate><guid>https://ptzu.github.io/posts/uva12019/</guid><description>題目
input 第一列有一正整數 N, 代表 test case 接著有 N 列測資, 每筆測資有 M, D, 代表月份和日期
題解 求出 2011年日期的星期
作法 先看 2011/1/1 是星期幾 然後記他的前一天是星期幾 之後在根據日期加上去, 7取餘數就是答案
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 1000000; int ZERO = 5; int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; string days[] = {&amp;#34;Sunday&amp;#34;, &amp;#34;Monday&amp;#34;, &amp;#34;Tuesday&amp;#34;, &amp;#34;Wednesday&amp;#34;, &amp;#34;Thursday&amp;#34;, &amp;#34;Friday&amp;#34;, &amp;#34;Saturday&amp;#34;}; int main(){ int n; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Uva 481 - What Goes Up</title><link>https://ptzu.github.io/posts/uva481/</link><pubDate>Fri, 15 Dec 2017 09:09:05 +0000</pubDate><guid>https://ptzu.github.io/posts/uva481/</guid><description>題目
input 據說50萬個數字左右
題解 求 LIS 的最長長度 如果有多個, 印最後一個出現的LIS
作法 LIS裸題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 1000000; int v[MAX_N]; int dp[MAX_N]; int pos[MAX_N]; int main(){ int x, n = 0; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;x) !</description></item><item><title>POJ 1151 - Atlantis</title><link>https://ptzu.github.io/posts/poj1151/</link><pubDate>Sat, 09 Dec 2017 22:18:31 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1151/</guid><description>題目
input 1 &amp;lt;= n &amp;lt;= 100 0 &amp;lt;= x1 &amp;lt; x2 &amp;lt;= 100000, 0 &amp;lt;= y1 &amp;lt; y2 &amp;lt;= 100000
題解 給 n 個矩形, 求所有矩形覆蓋面積
作法 座標範圍有點大, 先離散化 y 軸 然後掃描線掃 x 軸 若掃到某個矩形的 x1, 就將 y1 ~ y2 區間 +1, 反之掃到 x2 就 -1 以每一段的 x 座標為一個區段, 則這一個區段的面積就是 (x軸變化 * y軸被覆蓋的長度) 將所有區段加起來就是答案
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 10130 - SuperSale</title><link>https://ptzu.github.io/posts/uva10130/</link><pubDate>Thu, 30 Nov 2017 11:51:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10130/</guid><description>題目
input 1 &amp;lt;= T, N &amp;lt;= 1000 1 &amp;lt;= P &amp;lt;= 100 1 &amp;lt;= W &amp;lt;= 30 1 &amp;lt;= 背包容量 &amp;lt;= 30
題解 給 n 個物品, 每個物品有價格和重量 每個人最多可以帶 MW 重量 每個人對某個物品最多只能拿一次 求全部人可以買多少價格的商品
作法 01背包問題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int V[1010], W[1010]; int dp[100], n; void solve(){ // 如果迴圈從重量開始, 會導致少算一些價值 // 例如求容量為 90 的最大價值, 可以放入重量 30, 60的物品 // 但是我們只會放入其中一個, 因為不管是 dp[90 - 30], dp[90 - 60] 都還沒計算 // 若迴圈從物品開始, 我們就可以計算每個容量的最大價值 // 可能有個疑問, 為什麼迴圈重量不從 0 開始跑就好, 這樣每個重量也都會被先計算阿？ // 因為這樣就變成多重背包問題(每個物品可以選不只一次)了=w= // for(int i = 99; i &amp;gt;= 0; i--){ // for(int j = 0; j &amp;lt; n; j++){ // if(i &amp;gt;= W[j]){ // dp[i] = max(dp[i], dp[i - W[j]] + V[j]); // } // } // } for(int i = 0; i &amp;lt; n; i++){ for(int j = 99; j &amp;gt;= W[i]; j--){ dp[j] = max(dp[j], dp[j - W[i]] + V[i]); } } } int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(dp, 0, sizeof(dp)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;V[i], &amp;amp;W[i]); } solve(); int G; scanf(&amp;#34;%d&amp;#34;, &amp;amp;G); int ans = 0; for(int i = 0; i &amp;lt; G; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); ans += dp[x]; } printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; }</description></item><item><title>POJ 2386 Lake Counting</title><link>https://ptzu.github.io/posts/poj2386/</link><pubDate>Sat, 18 Nov 2017 13:35:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2386/</guid><description>題目
input 1 &amp;lt;= N, M &amp;lt;= 100
題解 給一個 N X M 的地圖 &amp;lsquo;W&amp;rsquo; 代表有水, &amp;lsquo;.&amp;rsquo; 代表陸地 水的 8 個方向可以互相連接成水塘 請問有幾個水塘
作法 DFS可找出每一塊水塘
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INTf_MAX // const int MAX_N = 100010; char a[200][200]; int n, m; pii dir[] = {{1, 1}, {1, 0}, {1, -1}, {0, 1}, {0, -1}, {-1, 1}, {-1, 0}, {-1, -1}}; bool vis[200][200]; void dfs(int r, int c){ vis[r][c] = true; for(int i = 0; i &amp;lt; 8; i++){ int R = r + dir[i].</description></item><item><title>POJ 2417 Discrete Logging</title><link>https://ptzu.github.io/posts/poj2417/</link><pubDate>Sat, 28 Oct 2017 18:03:04 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2417/</guid><description>題目
input {% math %} 2\leq P&amp;lt; 2^{31},\ 2\leq B&amp;lt; P,\ 1\leq N&amp;lt; P {% endmath %}
題解 求 {%math%} B^{L} \equiv N (mod\ P) {%endmath%} 之 L
作法 BSGS 算法 裸題 這題時限卡蠻緊的, 如果用 int 去轉 long long 會超時 果斷全用 long long了
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;map&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 443</title><link>https://ptzu.github.io/posts/cf443/</link><pubDate>Fri, 27 Oct 2017 17:05:13 +0000</pubDate><guid>https://ptzu.github.io/posts/cf443/</guid><description>目錄 模擬題 模擬題 位元操作 A. Borya&amp;rsquo;s Diagnosis 題目
input 1 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= s, d &amp;lt;= 1000
題解 Borya 要依序看 n 個醫生 每個醫生只在 si, si + di &amp;hellip; 的日子營業 請問最快要幾天才能看完所有醫生
作法 模擬題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 369 - Combinations</title><link>https://ptzu.github.io/posts/uva369/</link><pubDate>Wed, 25 Oct 2017 19:44:07 +0000</pubDate><guid>https://ptzu.github.io/posts/uva369/</guid><description>題目
input 5 &amp;lt;= N &amp;lt;= M &amp;lt;= 100
題解 求 C N 取 M
作法 帕斯卡三角形
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; ll pascal[110][110]; void init(){ } int main(){ int N, M; pascal[1][0] = 1; pascal[1][1] = 1; for(int i = 2; i &amp;lt;= 100; i++){ pascal[i][0] = 1; for(int j = 1; j &amp;lt; i; j++){ pascal[i][j] = pascal[i - 1][j] + pascal[i - 1][j - 1]; } pascal[i][i] = 1; } while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;N, &amp;amp;M) !</description></item><item><title>Uva 374 - Big Mod</title><link>https://ptzu.github.io/posts/uva374/</link><pubDate>Wed, 25 Oct 2017 07:29:49 +0000</pubDate><guid>https://ptzu.github.io/posts/uva374/</guid><description>題目
input 0 &amp;lt;= B, P, M &amp;lt;= 2147483647
題解 求出 B^P % M
作法 利用快速冪即可, 可參考 求取指數完整題型 包含大數指數, 以及底數和指數都是大數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; void init(){ } ll fastpow(ll B, ll P, ll M){ ll base = B, ans = 1; while(P){ if(P &amp;amp; 1) ans = ans * base % M; base = base * base % M; P &amp;gt;&amp;gt;= 1; } return ans; } int main(){ ll B, P, M; while(scanf(&amp;#34;%lld%lld%lld&amp;#34;, &amp;amp;B, &amp;amp;P, &amp;amp;M) !</description></item><item><title>Uva 10107 - What is the Median?</title><link>https://ptzu.github.io/posts/uva10107/</link><pubDate>Wed, 25 Oct 2017 07:12:43 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10107/</guid><description>題目
input 0 &amp;lt;= X &amp;lt;= 2^31 N &amp;lt; 10000
題解 輸入一個數 X, 並將目前已輸入的數排序 根據每個輸入, 輸出當前的中位數
作法 若是每次讀進來一個都排序一次, 那肯定 TLE 所以我們可以利用 priority_queue, 每次進來只需要花 O(logn) 做調整
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; priority_queue &amp;lt;int, vector&amp;lt;int&amp;gt; &amp;gt; smaller; priority_queue &amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; bigger; void init(){ } int main(){ int x, mid = -1; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;x) !</description></item><item><title>Uva 10579 - Fibonacci Numbers</title><link>https://ptzu.github.io/posts/uva10579/</link><pubDate>Tue, 24 Oct 2017 23:35:40 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10579/</guid><description>題目
題解 求取 Fibonacci 數列
作法 這題是大數加法, 然後求取解就好了 N 沒給範圍, 不過根據結果, 是不需要用到矩陣快速冪的 有關 O(logn) 作法可以參考 矩陣快速冪
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; struct big{ vector &amp;lt;int&amp;gt; digit; big(){ } big(string s){ int len = s.</description></item><item><title>大數運算</title><link>https://ptzu.github.io/posts/template-bigint/</link><pubDate>Tue, 24 Oct 2017 23:31:43 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bigint/</guid><description>第三次寫大數了 在比賽裡面因為 JAVA 有內建大數 所以此類題目比較少出 不過刷題的時候還是會遇到
struct big{ vector &amp;lt;int&amp;gt; digit; big(){ } big(string s){ int len = s.length(); for(int i = 0; len - 1 - i &amp;gt;= 0; i++){ digit.push_back(s[len - 1 - i] - &amp;#39;0&amp;#39;); } } big operator +(const big&amp;amp; obj)const{ int carry = 0; int maxSize = max(digit.size(), obj.digit.size()), minSize = min(digit.size(), obj.digit.size()); big res; for(int i = 0; i &amp;lt; minSize; i++){ int num = digit[i] + obj.</description></item><item><title>Uva 12716 - GCD XOR</title><link>https://ptzu.github.io/posts/uva12716/</link><pubDate>Mon, 23 Oct 2017 23:13:31 +0000</pubDate><guid>https://ptzu.github.io/posts/uva12716/</guid><description>題目
input T &amp;lt;= 10000 1 &amp;lt;= N &amp;lt;= 30000000
題解 求所有 GCD(A,B) = A XOR B 的pair數量, 對於 1 &amp;lt;= B &amp;lt;= A &amp;lt;= N
作法 首先有幾點必須先知道:
a XOR b &amp;gt;= (a - b) 以二進位來說, 一個 bit 為0, 一個 bit 為1 在 XOR 時為 1, 但是減法卻還要借位 而其他情況都相同, 所以可以肯定 a XOR b &amp;gt;= (a - b) 令GCD(a,b) = a ^ b = c 因為 a, b 的最大公因數為 c 所以可以寫成 a = k1 * c, b = k2 * c, k1 &amp;gt;= k2 a - b = (k1 - k2) * c, 所以 a - b &amp;gt;= c 結合以上兩點, 可以得到 (a - b) &amp;lt;= c &amp;lt;= (a - b) 根據夾擠定理, c = a - b 接著我們要列舉所有可能 a - b = c, 又 GCD(a,b) = c, 所以 a 可以寫成 k * c (k &amp;gt;= 2) 而 b 可以從 a - c 得到 這樣就可以找出所有 pair</description></item><item><title>Uva 275 - Expanding Fractions</title><link>https://ptzu.github.io/posts/uva275/</link><pubDate>Mon, 23 Oct 2017 17:16:18 +0000</pubDate><guid>https://ptzu.github.io/posts/uva275/</guid><description>題目
input a, b不超過1000
題解 找循環小數和其長度
作法 詳解請見 uva202
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int save[3030]; vector &amp;lt;int&amp;gt; res; void init(){ } int main(){ int a, b; while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a, &amp;amp;b) !</description></item><item><title>Uva 202 - Repeating Decimals</title><link>https://ptzu.github.io/posts/uva202/</link><pubDate>Sun, 22 Oct 2017 23:18:53 +0000</pubDate><guid>https://ptzu.github.io/posts/uva202/</guid><description>題目
input a, b 不超過3000
題解 求出 a / b 的循環小數以及其長度
作法 首先要知道的是, 在做除法時, 如果有個餘數重複出現過 則一定有循環小數。 a / b 的餘數會是 0 ~ b-1, 所以當計算到 b 次的時候 根據鴿籠原理, 一定會有個餘數重複, 所以有理數必有循環小數 我們只要模擬除法, 並用 save 陣列紀錄每個餘數的出現位置 若有出現過則找到循環小數, 並可以知道他的起始位置
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int save[3030]; vector &amp;lt;int&amp;gt; res; void init(){ } int main(){ int a, b; while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a, &amp;amp;b) !</description></item><item><title>Uva 1368 - DNA Consensus String</title><link>https://ptzu.github.io/posts/uva1368/</link><pubDate>Sun, 22 Oct 2017 19:49:35 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1368/</guid><description>題目
input m 個 DNA 序列長度 n 4 &amp;lt;= m &amp;lt;= 50, 4 &amp;lt;= n &amp;lt;= 1000
題解 定義 Hamming distance 為兩字串在同個 index, 有幾個字元不同 定義 Consensus error, 對於一個字串 y, 和字串集合 S, 他們之間的 Hamming distance 總和 而 Consensus error 最小的字串稱為 Consensus string 求 m 個序列中的 Consensus string 和他的 error
作法 要使每個字元的 error 最小, 那就找 m 個序列中 針對每個位置出現最多次的那個字元 若有多個符合的字串, 找到字典序最小的那個
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 232 - Crossword Answers</title><link>https://ptzu.github.io/posts/uva232/</link><pubDate>Sun, 22 Oct 2017 18:16:39 +0000</pubDate><guid>https://ptzu.github.io/posts/uva232/</guid><description>題目
input 1 &amp;lt;= r,c &amp;lt;= 10
題解 給一個 r * c 的格子, 有黑白格, 黑格用 * 表示 一個白格的上方 or 右方若 &amp;lsquo;沒有格子&amp;rsquo; 或 &amp;lsquo;有黑色格子&amp;rsquo; 則稱該白格為 eligible 將所有 eligible 格子從左到右, 上到下依序編號 每個單字的開頭一定要放在 eligible 求 Across(橫向單字), Down(縱向單字) 有哪些
作法 題目非常長, 不過作法卻很簡單, 實作就好了
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 227 - Puzzle</title><link>https://ptzu.github.io/posts/uva227/</link><pubDate>Sun, 22 Oct 2017 12:49:12 +0000</pubDate><guid>https://ptzu.github.io/posts/uva227/</guid><description>題目
input 含多筆測資, 輸入 &amp;lsquo;Z&amp;rsquo; 代表測資結束 每筆測資輸入 5X5 方格的字母 接著輸入需要做的移動, 上下左右對應到 ABLR, 輸入 0 代表操作結束 注意操作可能有多行
PS: 5X5中的那個空格, 直接複製網站測資會沒有空格, 自行補上
題解 給一個 5X5 方格, 每個小方格都有一個字母, 但有一格是空的 針對那個空格, 有四種操作, 上下左右移動 如果有不合法的移動, 輸出 &amp;ldquo;This puzzle has no final configuration.&amp;rdquo; 否則輸出移動後的方格狀況
作法 方格移動題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 455 - Periodic Strings</title><link>https://ptzu.github.io/posts/uva455/</link><pubDate>Sun, 22 Oct 2017 11:02:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva455/</guid><description>題目
input 最多 80 字元的字串
題解 求字串裏面最短的重複週期 例如: HoHoHo, 有 Ho 週期為 2 輸出2
作法 暴力法列舉不同子字串
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; void init(){ } int main(){ int TC, n; string s; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); getline(cin, s); for(int tc = 0; tc &amp;lt; TC; tc++){ getline(cin, s); getline(cin, s); int len = s.</description></item><item><title>Uva 1225 - Digit Counting</title><link>https://ptzu.github.io/posts/uva1225/</link><pubDate>Sun, 22 Oct 2017 08:26:40 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1225/</guid><description> 題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int cnt[10]; void init(){ } int main(){ int TC, n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(cnt, 0, sizeof(cnt)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 1; i &amp;lt;= n; i++){ int tmp = i; while(tmp){ cnt[tmp % 10]++; tmp /= 10; } } for(int i = 0; i &amp;lt;= 9; i++){ if(i == 0) printf(&amp;#34;%d&amp;#34;, cnt[i]); else printf(&amp;#34; %d&amp;#34;, cnt[i]); } puts(&amp;#34;&amp;#34;); } return 0; }</description></item><item><title>uva1586</title><link>https://ptzu.github.io/posts/uva1586/</link><pubDate>Sun, 22 Oct 2017 08:21:36 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1586/</guid><description>題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; map &amp;lt;char, double&amp;gt; mp; void init(){ } int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); mp[&amp;#39;C&amp;#39;] = 12.</description></item><item><title>Uva 1585 - Score</title><link>https://ptzu.github.io/posts/uva1585/</link><pubDate>Sun, 22 Oct 2017 01:08:49 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1585/</guid><description>題目
input 給多行字串, 每行字串長度最多80
題解 一個字串含有 &amp;lsquo;O&amp;rsquo;, &amp;lsquo;X&amp;rsquo;, 分別代表該題目對或錯 該題的分數取決於是目前連續第幾個答對的 例如有 &amp;lsquo;OO&amp;rsquo;, 則第 1 題 1 分, 第 2 題 2 分 以此類推, 求全部拿多少分
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; void init(){ } int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ string s; cin &amp;gt;&amp;gt; s; int cnt = 0, ans = 0; for(int i = 0; i &amp;lt; s.</description></item><item><title>Uva 1584 - Circular Sequence</title><link>https://ptzu.github.io/posts/uva1584/</link><pubDate>Sat, 21 Oct 2017 22:43:09 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1584/</guid><description>題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int n; string s; void init(){ } bool cmp(int now, int ans){ for(int i = 0; i &amp;lt; s.</description></item><item><title>Uva 1583 - Digit Generator</title><link>https://ptzu.github.io/posts/uva1583/</link><pubDate>Sat, 21 Oct 2017 10:53:31 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1583/</guid><description> 題目
input 1 &amp;lt;= n &amp;lt;= 100000
題解 給一個數字, 求他的最小生成元 例如: 256 = 245 + 2 + 4 + 5, 則 245 是 256 的生成元 一個數字可能有 0 個或多個生成元 求最小的
作法 先建表, 把每個數字可以生成的數字記起來 在根據輸入去查表
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 101010; int ans[MAX_N]; void init(){ } int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 1; i &amp;lt;= 100000; i++){ int tmp = i, sum = 0; while(tmp &amp;gt; 0){ sum += tmp % 10; tmp /= 10; } if(ans[i + sum] == 0) ans[i + sum] = i; } for(int i = 0; i &amp;lt; n; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); printf(&amp;#34;%d\n&amp;#34;, ans[x]); } return 0; }</description></item><item><title>Uva 340 - Master-Mind Hints</title><link>https://ptzu.github.io/posts/uva340/</link><pubDate>Sat, 21 Oct 2017 10:30:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva340/</guid><description>題目
input 含多筆測資, 每筆測資開頭有一正整數 N, N &amp;lt;= 1000, 代表密碼的長度 第二列有N個1到9的數字，代表密碼 接著有多組猜測, 每組猜測為 N 個 1~9 的數字, 全為 0 代表猜測結束 N = 0 代表測資結束
題解 如果有猜中數字, 位置也對, 則會得到一個 A 若是有猜中數字, 但位置不對, 則會得到一個 B 輸出幾A幾B
作法 我們可以先計算, 到底有幾個數字被猜中了 也就是針對 1~9 取 min(在密碼出現的次數, 猜測出現的次數) 然後我們可以找出, 有幾個數字是在正確位置 猜中次數扣掉正確位置的, 剩餘的都是在不正確位置, 也就是 B
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 401 - Palindromes</title><link>https://ptzu.github.io/posts/uva401/</link><pubDate>Fri, 20 Oct 2017 23:15:53 +0000</pubDate><guid>https://ptzu.github.io/posts/uva401/</guid><description>題目
input 給多行字串
題解 迴文字串定義：從左邊或右邊讀過來都長一樣 鏡像字串定義：以字型來看, 他是左右對稱的
作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX map &amp;lt;char, char&amp;gt; mp; void init(){ } int main(){ string s; char s1[] = {&amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;8&amp;#39;}; char s2[] = {&amp;#39;A&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;8&amp;#39;}; int len = strlen(s1); for(int i = 0; i &amp;lt; len; i++) mp[s1[i]] = s2[i]; while(cin &amp;gt;&amp;gt; s){ string tmp = s; reverse(tmp.</description></item><item><title>大數取 MOD</title><link>https://ptzu.github.io/posts/bigint-mod/</link><pubDate>Mon, 09 Oct 2017 08:40:40 +0000</pubDate><guid>https://ptzu.github.io/posts/bigint-mod/</guid><description>Code ll getMod(string s, ll mod){ ll r = 0; for(char c : s) r = (r * 10 + c - &amp;#39;0&amp;#39;) % mod; return r; }</description></item><item><title>Mod Inverse 模板</title><link>https://ptzu.github.io/posts/template-mod-inverse/</link><pubDate>Mon, 09 Oct 2017 08:30:52 +0000</pubDate><guid>https://ptzu.github.io/posts/template-mod-inverse/</guid><description>AC code int mod_inverse(int a, int m){ int x, y; // x 是所求 extgcd(a, m, x, y); return (m + x % m) % m; }</description></item><item><title>POJ 1258 Agri-Net</title><link>https://ptzu.github.io/posts/poj1258/</link><pubDate>Sun, 01 Oct 2017 17:01:36 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1258/</guid><description>題目
input 含有多筆測資, 每筆測資開頭輸入一正整數 N, 3 &amp;lt;= N &amp;lt;= 100 代表有 N 個農場 接著輸入一個 N * N 的相鄰矩陣, 代表邊
題解 農夫 John 要在農場建立網路, 連接網路電纜需要成本 求連接所有農場的最小成本
作法 Kruskal 裸題
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX struct Union_Find { int par[1010], num[1010]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U; struct edge{ int u, v, w; bool operator &amp;lt;(const edge&amp;amp; e) const{ return w &amp;lt; e.</description></item><item><title>Dijkstra Algorithm</title><link>https://ptzu.github.io/posts/template-dijkstra/</link><pubDate>Sun, 01 Oct 2017 11:16:22 +0000</pubDate><guid>https://ptzu.github.io/posts/template-dijkstra/</guid><description>Code struct edge{ int to, w; }; int d[MAX_N]; vector &amp;lt;edge&amp;gt; g[MAX_N]; int dijkstra(int S){ priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; pq; //d, v fill(d, d + n, INF); d[S] = 0; pq.push((pii){0, S}); while(!pq.empty()){ pii top = pq.top(); pq.pop(); int u = top.nd; if(d[u] &amp;lt; top.st) continue; for(int i = 0; i &amp;lt; sz(g[u]); i++){ edge e = g[u][i]; if(d[u] + e.w &amp;lt; d[e.to]){ d[e.to] = d[u] + e.w; pq.</description></item><item><title>Uva 10986 - Sending email</title><link>https://ptzu.github.io/posts/uva10986/</link><pubDate>Sun, 01 Oct 2017 10:34:39 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10986/</guid><description>目錄 題目
題解 有 n 台 server, 之間用 cable 連結 每條 cable 有傳送延遲 請問從 server S to server T 最少需要多少時間？
作法 Dijkstra 裸題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX struct edge{ int to, w; }; int n, m, S, T; int d[20010]; vector &amp;lt;edge&amp;gt; g[20010]; int dijkstra(){ priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; pq; //d, v fill(d, d + n, INF); d[S] = 0; pq.</description></item><item><title>POJ 2342 Anniversary party</title><link>https://ptzu.github.io/posts/poj2342/</link><pubDate>Wed, 27 Sep 2017 18:34:56 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2342/</guid><description>題解 派對中有 n 個員工, 老闆不希望對於某個員工, 他的上司和下屬出現在派對, 每個人都有一個歡樂值, 請問派對中最大的歡樂值總和為多少？
作法 樹型DP, bottom-up dp[i][0] 表第 i 個員工不出席的歡樂值 dp[i][1] 表第 i 個員工出席的歡樂值
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX vector &amp;lt;int&amp;gt; g[6060]; int conviviality[6060]; bool point[6060] ;// 判斷是否有被指向 int n; int dp[6060][2]; void DFS(int x){ for(int i = 0; i &amp;lt; sz(g[x]); i++){ int son = g[x][i]; DFS(son); dp[x][0] += max(dp[son][0], dp[son][1]); dp[x][1] += dp[son][0]; } } int main(){ // fio; // #ifdef DEBUG // printf (&amp;#34;TEST\n&amp;#34;); // #else // printf(&amp;#34;FAIL\n&amp;#34;); // #endif cin &amp;gt;&amp;gt; n; for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;conviviality[i]); dp[i][1] = conviviality[i]; } for(int i = 0; i &amp;lt; n; i++){ int u, v; scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;u, &amp;amp;v); u--;v--; g[v].</description></item><item><title>POJ 3061 Subsequence</title><link>https://ptzu.github.io/posts/poj3061/</link><pubDate>Mon, 18 Sep 2017 11:56:32 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3061/</guid><description>題解 給 n 個元素, 求連續子序列和, 滿足大於等於 S 的最小序列長度
作法 先向右不斷爬行直到和大於等於 S 在和滿足條件的情況下, 減少左端長度 並不斷更新最短長度 如此可在 O(n) 時間內求解
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX vector &amp;lt;int&amp;gt; v; int solve(int N, int S){ int mn = INF; int s = 0, t = 0, sum = 0; for(;;){ while(t &amp;lt; N &amp;amp;&amp;amp; sum &amp;lt; S){ sum += v[t++]; } if(sum &amp;lt; S) break; mn = min(mn, t - s); sum -= v[s++]; } if(mn &amp;gt; N) mn = 0; return mn; } int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ v.</description></item><item><title>快速冪(FastPow) 模板</title><link>https://ptzu.github.io/posts/template-fastpow/</link><pubDate>Mon, 18 Sep 2017 01:06:00 +0000</pubDate><guid>https://ptzu.github.io/posts/template-fastpow/</guid><description>在 log(N) 時間內求取冪次方
code int fastpow(int a,int b) { int ans = 1,base = a; while(b!=0) { if(b&amp;amp;1) ans *= base; base *= base; b&amp;gt;&amp;gt;=1; } return ans; }</description></item><item><title>Eratosthenes 模板</title><link>https://ptzu.github.io/posts/template-eratosthenes/</link><pubDate>Sun, 17 Sep 2017 22:39:17 +0000</pubDate><guid>https://ptzu.github.io/posts/template-eratosthenes/</guid><description>求取小於 n 的質數
code const int MAX_N = 1e5; vector &amp;lt;int&amp;gt; prime; bool is_prime[MAX_N + 10]; int sieve(int n){ fill(is_prime, is_prime + n, true); is_prime[0] = is_prime[1] = false; for(int i = 2; i &amp;lt;= n; i++){ if(is_prime[i]){ //紀錄質數 prime.push_back(i); // 消除 i 的倍數 for(int j = i * 2; j &amp;lt;= n; j += i){ is_prime[j] = false; } } } return (int)prime.size(); }</description></item><item><title>Extgcd 模板</title><link>https://ptzu.github.io/posts/template-extgcd/</link><pubDate>Sun, 17 Sep 2017 15:23:05 +0000</pubDate><guid>https://ptzu.github.io/posts/template-extgcd/</guid><description>求取 ax + by = gcd(a, b) 此方程式之解 並回傳 gcd(a, b)
code int extgcd(int a, int b, int &amp;amp;x, int &amp;amp;y){ int d = a; if(b != 0){ d = extgcd(b, a % b, y, x); y -= (a / b) * x; } else{ x = 1; y = 0; } return d; }</description></item><item><title>ITSA第五屆桂冠賽 挑戰組</title><link>https://ptzu.github.io/posts/itsachallenge-5/</link><pubDate>Mon, 01 May 2017 09:41:49 +0000</pubDate><guid>https://ptzu.github.io/posts/itsachallenge-5/</guid><description>目錄 [A1] Extended Absolute Mode 題目
input 題解 作法 AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX vector &amp;lt;int&amp;gt; v; int cnt[200]; int pre[200]; int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ int n, d; v.</description></item><item><title>Uva 10684 - The jackpot</title><link>https://ptzu.github.io/posts/uva10684/</link><pubDate>Thu, 30 Mar 2017 22:45:00 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10684/</guid><description>題目
input n 個數: n &amp;lt;= 10000 數字 x: 0 &amp;lt; x &amp;lt; 1000
題解 Manuel 想要快速變有錢, 所以他決定去賭博 他精心計劃了贏錢的策略 每個下注可能贏錢或輸錢 求一段連續的下注最多可以獲得多少錢 ps: 題目說負值輸出 losing, 但根據測資, 0 也算 losing
作法 最大連續區間和裸題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int dp[10101]; int n; int main(){ while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Codeforces Round 407</title><link>https://ptzu.github.io/posts/cf407/</link><pubDate>Thu, 30 Mar 2017 16:32:28 +0000</pubDate><guid>https://ptzu.github.io/posts/cf407/</guid><description>目錄 微動腦實作 math 最大連續區間和變形 A. Anastasia and pebbles 題目
input n 種石頭, 口袋能放 k 個: 1 ≤ n ≤ 10^5, 1 ≤ k ≤ 10^9 石頭數量 w1&amp;hellip;wn: 1 ≤ wi ≤ 10^4
題解 Anastasia 決定在公園裡蒐集石頭 他有兩個口袋, 每個口袋可以放 k 個石頭 公園裡有 n 種石頭, 第 i 種石頭有 wi 個 在同一個口袋不能放不同種類的石頭 她一天只能來公園蒐集一次石頭(兩個口袋滿) 請問要幾天才能蒐集完公園裡全部石頭？
作法 由於每次只能裝 k 個, 而且不能混別種石頭 所以就每 k 個當作一堆, 每天能裝 2 堆 看要幾天
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Educational Codeforces Round 18</title><link>https://ptzu.github.io/posts/cfedu18/</link><pubDate>Thu, 30 Mar 2017 16:32:26 +0000</pubDate><guid>https://ptzu.github.io/posts/cfedu18/</guid><description>目錄 距離 sort 使用 vector erase 數字 digit 總於除 3 A. New Bus Route 題目
input n 個城市: 2 ≤ n ≤ 2·10^5 城市座標: - 10^9 ≤ a ≤ 10^9
題解 有 n 座城市, 要規劃新的公車路線 所以要求出任兩城市的最短距離, 以及符合該距離的 pair 有幾個？
作法 sort
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 406</title><link>https://ptzu.github.io/posts/cf406/</link><pubDate>Fri, 24 Mar 2017 22:35:41 +0000</pubDate><guid>https://ptzu.github.io/posts/cf406/</guid><description>目錄 A. The Monster 題目
input 1 ≤ a, b, c, d ≤ 100
題解 b, b + a, b + 2a, &amp;hellip; b 以這樣成長著 d, d + c, d + 2c, &amp;hellip; d 以這樣成長著 求 b 和 d 何時會相同, 輸出第一個相同的數 沒有這樣的數就輸出 -1
作法 我的作法是讓迴圈跑 100 次 想法是這樣 b, d的範圍是 100 假設極端測資, b = 100, d = 1 a = 1, c = 2 差距 99, 每次拉近 1 跑 100 次該重疊的也要重疊了吧？ 不過沒有嚴謹的證明, 只是憑感覺 但似乎大家都是這麼做的</description></item><item><title>Codeforces Round 405</title><link>https://ptzu.github.io/posts/cf405/</link><pubDate>Sun, 19 Mar 2017 15:08:22 +0000</pubDate><guid>https://ptzu.github.io/posts/cf405/</guid><description>目錄 模擬題 DFS 區間元素不重複&amp;amp;重複 A. Bear and Big Brother 題目
input 1 ≤ a ≤ b ≤ 10
題解 a 每天變為 3 倍, b 每天變為 2 倍 問幾天後, a 會嚴格大於 b
作法 模擬題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; int cnt = 0; while(1){ if(a &amp;gt; b) break; a *= 3; b *= 2; cnt++; } cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; return 0; } B.</description></item><item><title>Uva 10066 - The Twin Towers</title><link>https://ptzu.github.io/posts/uva10066/</link><pubDate>Fri, 17 Mar 2017 11:23:38 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10066/</guid><description>題目
input 牆磚: 1 ≤ N1, N2 ≤ 100 N1 個牆磚半徑 N2 個牆磚半徑
題解 在一個古帝國, 有兩座形狀不一樣的塔, 它們是由不同半徑的圓形牆磚疊合而成。 數千年後, 皇帝要求工匠移除某些牆磚, 使得兩座塔變得一樣, 當然牆磚的順序必須和原本的塔一樣 請問若要使塔的高度最高, 它有幾塊牆磚?
作法 要使塔最高, 就代表相同的牆磚要愈多愈好, 而且順序不能變 那就是 LCS 解了！ 輸出記得空一行
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int a[200], b[200]; int main(){ int cnt = 1; int n, m; while(scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;m) !</description></item><item><title>Uva 531 - Compromise</title><link>https://ptzu.github.io/posts/uva531/</link><pubDate>Fri, 17 Mar 2017 10:23:45 +0000</pubDate><guid>https://ptzu.github.io/posts/uva531/</guid><description>題目
input 有很多 test case, 每個 case 有兩人的提議, 而且分別以 # 做結尾 每個人的提議最多 100 字, 每字最多 30 字元
題解 再幾個月, 歐洲貨幣聯盟就要成立, 要加入他們必須滿足馬斯垂克條約, 這並不是一件簡單的事, 為了讓德國滿足條約, 政府有好幾個方法(增稅, 賣股票&amp;hellip;), 但是難以決定。 兩位政治人物分別提出了建議, 你的任務是從他們兩個的建議中, 找出最多相同的提議, 並輸出那些提議。
作法 LCS + 回溯 用 pre 陣列來紀錄目前這個解是從哪裡來, 回推回去 ps: 感覺 udebug 有幾個測資有錯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 111 - History Grading</title><link>https://ptzu.github.io/posts/uva111/</link><pubDate>Thu, 16 Mar 2017 22:31:01 +0000</pubDate><guid>https://ptzu.github.io/posts/uva111/</guid><description>題目
input n 個歷史事件: 2 ≤ n ≤ 20 接下一行是正確答案的事件rank 後面每行都是學生答案的rank
題解 在一個歷史考試中, 學生被要求根據歷史事件發生年代做排序 全部排對可以得到全部分數, 而部分給分規則如下
根據每個事件, 排在正確位置就得 1 分 根據每個事件, 只要他的相對順序是正確就得 1 分 而我們接下來要採用第 2 個規則 給一串序列, c1&amp;hellip;cn, 代表第 i 個事件排的&amp;quot;位置(rank)&amp;quot; 例如: 3, 1, 2, 則真實順序為 2, 3, 1 求每個學生的得分 作法 LCS 要注意的是 input 所代表的意義 另外我覺得範例怪怪的, 那應該是代表兩筆測資 因為我只對 n 做一次輸入就AC了 應該不用做到多筆測資 當然學生的input是多筆沒錯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>LCS 模板</title><link>https://ptzu.github.io/posts/template-lcs/</link><pubDate>Thu, 16 Mar 2017 10:34:32 +0000</pubDate><guid>https://ptzu.github.io/posts/template-lcs/</guid><description>定義 dp[i][j]: s1&amp;hellip;si 和 t1&amp;hellip;tj 的最長共同子序列
string s1, s2; int dp[100][100]; int main(){ cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2; int len1 = s1.length(); int len2 = s2.length(); for(int i = 0; i &amp;lt; len1; i++){ for(int j = 0; j &amp;lt; len2; j++){ if(s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j] + 1; else dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]); } } cout &amp;lt;&amp;lt; dp[len1][len2] &amp;lt;&amp;lt; endl; return 0; }</description></item><item><title>Uva 10003 - Cutting Sticks</title><link>https://ptzu.github.io/posts/uva10003/</link><pubDate>Mon, 13 Mar 2017 16:23:33 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10003/</guid><description>題目
input 棍子長度 L: 0 &amp;lt; L &amp;lt; 1000 切點數量 n: n &amp;lt; 50 切點位置: 0 &amp;lt; c &amp;lt; L 當 L = 0時結束輸入
題解 給一根棍子以及 n 個切點 切棍子的費用是, 要切的棍子長度 求切完 n 個點, 最小的花費
作法 O(N^3) 第二次做這題目, 看到原本的code卻一直想不通 是對切點做DP, 而不是棍子的長度！ 定義 dp[i][j]: 完成第 i 個點 &amp;hellip; 第 j 個點所花的最小費用 在頭尾新增兩個切點, cut[0] = 0, cut[n + 1] = L 作用是如果沒有切點在兩端, 就不好算當前棍子長度了
根據不同的 i &amp;hellip; j 範圍, 選擇一個 k 點切下去
DP遞迴式 dp[i][j] = {dp[i][k] + dp[k][j] + (cut[j] - cut[i]) | for i &amp;lt; k &amp;lt; j} AC code #include &amp;lt;bits/stdc++.</description></item><item><title>Codeforces Round 403</title><link>https://ptzu.github.io/posts/cf403/</link><pubDate>Wed, 08 Mar 2017 23:48:14 +0000</pubDate><guid>https://ptzu.github.io/posts/cf403/</guid><description>目錄 實作題 平均最大化變形 樹著色 A. Andryusha and Socks 題目
input n 雙襪子: 1 ≤ n ≤ 10^5 接著 2 * n 個輸入, 從袋子拿出編號 i 的襪子
題解 從袋子裡拿出襪子, 如果襪子還沒成雙, 就放在桌上 成雙就放進衣櫥, 求桌上最多幾隻襪子？
作法 實作題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int cnt[101010]; int main(){ ios::sync_with_stdio(false); cin.</description></item><item><title>題單</title><link>https://ptzu.github.io/posts/%E9%A1%8C%E5%96%AE/</link><pubDate>Wed, 01 Mar 2017 10:59:54 +0000</pubDate><guid>https://ptzu.github.io/posts/%E9%A1%8C%E5%96%AE/</guid><description>DP: 矩型嵌套(經典題): NYOJ 16 兩人分錢: Uva 562 分兩隊並限制數量: Uva 10032 TSP: POJ 3311 MTSP、位元DP: HDU 4281 雙調TSP: POJ 2677 山稜線DP: ZJ b177
逆序數對: POJ 2299
單調隊列: POJ 2823
滑動視窗: CF452 B 判斷日曆
循環小數: Uva 275, XDoj 1077
字串刪除: CF452 E,F、CF455 D
無向圖求關節點: POJ 1144 無向圖求橋: Uva 796
CF 推薦: round 452
多版本的POJ分类
流传最广的一种分类：
初期:
一.基本算法:
(1)枚举. (poj1753,poj2965) (2)贪心(poj1328,poj2109,poj2586) (3)递归和分治法. (4)递推. (5)构造法.(poj3295) (6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996) 二.图算法:
(1)图的深度优先遍历和广度优先遍历. (2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra) (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240) (3)最小生成树算法(prim,kruskal) (poj1789,poj2485,poj1258,poj3026) (4)拓扑排序 (poj1094) (5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020) (6)最大流的增广路算法(KM算法).</description></item><item><title>二分搜</title><link>https://ptzu.github.io/posts/template-binary-search/</link><pubDate>Wed, 01 Mar 2017 00:13:45 +0000</pubDate><guid>https://ptzu.github.io/posts/template-binary-search/</guid><description>0, 1型 bool C(int x){ } int sol(){ int l = 0, u = N; if(C(l)) return l; if(!C(u)) return -1; while(u - l &amp;gt; 1){ int mid = (u + l) / 2; if(C(mid)) l = mid; else u = mid; } return u; } 1, 0型 bool C(int x){ } int sol(){ int l = 0, u = N; if(!C(l)) return -1; if(C(u)) return u; while(u - l &amp;gt; 1){ int mid = (u + l) / 2; if(C(mid)) u = mid; else l = mid; } return l; }</description></item><item><title>Codeforces Round 402</title><link>https://ptzu.github.io/posts/cf402/</link><pubDate>Tue, 28 Feb 2017 23:27:35 +0000</pubDate><guid>https://ptzu.github.io/posts/cf402/</guid><description>目錄 分配相等 被 10^k 整除 greedy 買東西 字串二分搜 A. Pupils Redistribution 題目
input 每組 n 人： 1 &amp;lt;= n &amp;lt;= 100 學業值 a: 1 &amp;lt;= a &amp;lt;= 5
題解 每個人的學業表現值為1~5 在學校裡分為 A,B 兩組, 每組有 n 人 今要使兩組在各表現值的人數相同 兩組的人員可以交換, 求最少要交換幾次？
作法 要使兩組人數相同, 就代表一組在該值的人數為 2 / n 算出總交換次數, 再除以 2 為答案
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>ICM Technex 2017 and Codeforces Round 400</title><link>https://ptzu.github.io/posts/cf400/</link><pubDate>Fri, 24 Feb 2017 19:30:50 +0000</pubDate><guid>https://ptzu.github.io/posts/cf400/</guid><description>目錄 實作題 判斷質數 組出多個數字的區間和有幾個 A. A Serial Killer 題目
input 兩個名字： s1, s2 n: 接下來有幾天 字串a, b: a 代表誰被殺, b 代表誰去取代被殺人的位置
題解 有個連續殺人魔, 一開始鎖定了兩個人 接下來 n 天, 他都會殺了 a, 並再找一個 b 請問每天他可以選擇的人名有誰？
作法 簡單實作題, 不斷替換字串就好
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ ios::sync_with_stdio(false); cin.</description></item><item><title>Codeforces Round 380 (Div. 2)</title><link>https://ptzu.github.io/posts/cf380/</link><pubDate>Thu, 16 Feb 2017 23:54:05 +0000</pubDate><guid>https://ptzu.github.io/posts/cf380/</guid><description>A. Interview with Oleg 題目
input n: 字串長度 s: 一字串
題解 把字串中有出現 &amp;lsquo;ogo&amp;rsquo; 的替換成 *** 另外,如果 ogo 後面接上 go 也算是一起的例如 &amp;lsquo;ogogo&amp;rsquo;
作法 O(n) 掃過一次即可
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ // ios::sync_with_stdio(false); // cin.</description></item><item><title>Codeforces Round 382 (Div. 2)</title><link>https://ptzu.github.io/posts/cf382/</link><pubDate>Wed, 15 Feb 2017 23:25:08 +0000</pubDate><guid>https://ptzu.github.io/posts/cf382/</guid><description>目錄 A. 實作題 B. greedy C. fibunacci D. 哥德巴赫猜想
A. Ostap and Grasshopper 題目
input n 個 cell: 2 &amp;lt;= n &amp;lt;= 100 蚱蜢一次跳 k 步： 1 &amp;lt;= k &amp;lt;= n - 1
題解 &amp;ldquo;.&amp;rdquo; 代表空的cell, &amp;ldquo;#&amp;rdquo; 代表障礙, &amp;ldquo;G&amp;rdquo; 代表蚱蜢, &amp;ldquo;T&amp;rdquo; 代表目標 問能否達到目標
作法 實作題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int n, k; int main(){ // ios::sync_with_stdio(false); // cin.</description></item><item><title>Codeforces Round 381 (Div. 2)</title><link>https://ptzu.github.io/posts/cf381/</link><pubDate>Wed, 15 Feb 2017 23:25:00 +0000</pubDate><guid>https://ptzu.github.io/posts/cf381/</guid><description>A. Alyona and copybooks 題目
input 1 &amp;lt;= n,a,b,c &amp;lt;= 10^9
題解 Alyona 有4個科目, 他想替每個科目買數量相同的習字本目前他已經有 n 本商店有三種包裝, 一本賣 a 盧布, 兩本賣 b 盧布, 三本賣 c 盧布他還需要買 k 本使得 n + k 是4的倍數請問買 k 本最少需要花多少錢？
作法 把每一種包裝的組合可能列舉出來, 找出花最少錢的組合
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ // ios::sync_with_stdio(false); // cin.</description></item><item><title>Codeforces Round 395 (Div. 2)</title><link>https://ptzu.github.io/posts/cf395/</link><pubDate>Fri, 03 Feb 2017 23:56:45 +0000</pubDate><guid>https://ptzu.github.io/posts/cf395/</guid><description>目錄 GCD/LCM 實作序列翻轉 子樹不能有相同顏色 奇數邊長長方形上色 A. Taymyr is calling you 題目
input 數字 n, m, z: 1 ≤ n, m, z ≤ 10^4
題解 一天長 z 分鐘, Ilia-alpinist 每 n, 2n, 3n&amp;hellip;分鐘會打電話 Artists 每 m, 2m, 3m 會來房間 求要殺掉幾個人, 才能使打電話時, 房間沒有人 奇怪的題目敘述(?
作法 求LCM就好
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ // ios::sync_with_stdio(false); // cin.</description></item><item><title>Codeforces Round 389 (Div. 2)</title><link>https://ptzu.github.io/posts/cf389/</link><pubDate>Thu, 02 Feb 2017 20:24:08 +0000</pubDate><guid>https://ptzu.github.io/posts/cf389/</guid><description>C. Santa Claus and Robot 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ int n; char dir1 = 0, dir2 = 0; scanf(&amp;#34;%d\n&amp;#34;, &amp;amp;n); int cnt = 0; for(int i = 0; i &amp;lt; n; i++){ char c; scanf(&amp;#34;%c&amp;#34;, &amp;amp;c); if(c == &amp;#39;U&amp;#39; || c == &amp;#39;D&amp;#39;){ if(dir1 == 0){ dir1 = c; continue; } if(c !</description></item><item><title>Codeforces Round 388 (Div. 2)</title><link>https://ptzu.github.io/posts/cf388/</link><pubDate>Thu, 02 Feb 2017 20:24:01 +0000</pubDate><guid>https://ptzu.github.io/posts/cf388/</guid><description>C. Voting 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX deque &amp;lt;int&amp;gt; D; deque &amp;lt;int&amp;gt; R; char a[202020]; int main(){ // ios::sync_with_stdio(false); // cin.tie(0); int n; scanf(&amp;#34;%d\n&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%c&amp;#34;, &amp;amp;a[i]); if(a[i] == &amp;#39;D&amp;#39;) D.</description></item><item><title>Codeforces Round 387 (Div. 2)</title><link>https://ptzu.github.io/posts/cf387/</link><pubDate>Thu, 02 Feb 2017 20:23:51 +0000</pubDate><guid>https://ptzu.github.io/posts/cf387/</guid><description>C. Servers 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; server; vector &amp;lt;int&amp;gt; can; int main(){ int n, q; scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;q); for(int i = 0; i &amp;lt; n; i++) can.</description></item><item><title>Codeforces Round 386 (Div. 2)</title><link>https://ptzu.github.io/posts/cf386/</link><pubDate>Thu, 02 Feb 2017 20:23:43 +0000</pubDate><guid>https://ptzu.github.io/posts/cf386/</guid><description>C. Tram 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;%d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int s, x1, x2, v1, v2, p, d; int main(){ scanf(&amp;#34;%d %d %d %d %d %d %d&amp;#34;, &amp;amp;s, &amp;amp;x1, &amp;amp;x2, &amp;amp;v1, &amp;amp;v2, &amp;amp;p, &amp;amp;d); //opposite direction int dis = 0; int ans = abs(x2 - x1) * v2; if((x2 - x1) * d &amp;lt; 0){ if(d &amp;gt; 0) dis = s - p + abs(x2 - s); else dis = p + x2; } else{ if(d &amp;gt; 0 &amp;amp;&amp;amp; p &amp;gt; x1) dis = (s - p) + s + x2; else if(d &amp;lt; 0 &amp;amp;&amp;amp; p &amp;lt; x1) dis = p + s + abs(s - x2); else dis = abs(x2 - p); } printf(&amp;#34;%d\n&amp;#34;, min(ans, dis * v1)); return 0; } E.</description></item><item><title>Codeforces Round 384 (Div. 2)</title><link>https://ptzu.github.io/posts/cf384/</link><pubDate>Thu, 02 Feb 2017 20:21:21 +0000</pubDate><guid>https://ptzu.github.io/posts/cf384/</guid><description>C. Vladik and fractions 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); if(n == 1){ printf(&amp;#34;-1\n&amp;#34;); return 0; } for(int i = 1; i &amp;lt;= 1e8; i++){ ll up = 2 * i - 1; ll down = n * i; ll x, y; if(up % 2 == 1){ x = up / 2; y = up / 2 + 1; } if(x &amp;gt; 1e9 || y &amp;gt; 1e9 || down &amp;gt; 1e9) break; if(x * y == down){ printf(&amp;#34;%lld %lld %lld\n&amp;#34;, x, y, down); return 0; } } printf(&amp;#34;-1\n&amp;#34;); return 0; }</description></item><item><title>併查集 Disjoint set</title><link>https://ptzu.github.io/posts/template-dsu/</link><pubDate>Thu, 02 Feb 2017 18:22:18 +0000</pubDate><guid>https://ptzu.github.io/posts/template-dsu/</guid><description>code const int MAX_N = ...; struct Union_Find { int par[MAX_N], num[MAX_N]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U;</description></item><item><title>Codeforces Round 385 (Div. 2)</title><link>https://ptzu.github.io/posts/cf385/</link><pubDate>Wed, 25 Jan 2017 11:08:09 +0000</pubDate><guid>https://ptzu.github.io/posts/cf385/</guid><description>A. Hongcow Learns the Cyclic Shift 題目
input 題解 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX map &amp;lt;string, bool&amp;gt; m; int main(){ string s; cin &amp;gt;&amp;gt; s; int len = s.length(); int cnt = 0; for(int i = 0; i &amp;lt; len; i++){ string ss = s.</description></item><item><title>POJ 3624 Charm Bracelet</title><link>https://ptzu.github.io/posts/poj3624/</link><pubDate>Wed, 18 Jan 2017 18:08:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3624/</guid><description>題解 01背包問題裸題, 但需要空間優化
作法 dp陣列開成兩條一維, 交替使用
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, m; int dp[2][13000]; int w[3500], d[3500]; int main(){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;m); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;w[i], &amp;amp;d[i]); } for(int i = 0; i &amp;lt; n; i++){ for(int j = 0; j &amp;lt;= m; j++){ if(j &amp;lt; w[i]) dp[(i + 1) &amp;amp; 1][j] = dp[i &amp;amp; 1][j]; else dp[(i + 1) &amp;amp; 1][j] = max(dp[i &amp;amp; 1][j], dp[i &amp;amp; 1][j - w[i]] + d[i]); } } printf(&amp;#34;%d\n&amp;#34;, dp[n &amp;amp; 1][m]); return 0; }</description></item><item><title>POJ 2155 Matrix</title><link>https://ptzu.github.io/posts/poj2155/</link><pubDate>Sun, 11 Dec 2016 23:40:53 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2155/</guid><description>AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; const int MAX_N = 1000; int bit[MAX_N + 10][MAX_N + 10]; int N, T; void add(int a, int b){ for(int i = a; i &amp;lt;= N; i += (i &amp;amp; -i)){ for(int j = b; j &amp;lt;= N; j += (j &amp;amp; -j)){ bit[i][j]++; } } } int sum(int a, int b){ int s = 0; for(int i = a; i &amp;gt; 0; i -= (i &amp;amp; -i)){ for(int j = b; j &amp;gt; 0; j -= (j &amp;amp; -j)){ s += bit[i][j]; } } return s; } int main(){ int TC; scanf(&amp;#34;%d\n&amp;#34;, &amp;amp;TC); while(TC--){ memset(bit, 0, sizeof(bit)); scanf(&amp;#34;%d %d\n&amp;#34;, &amp;amp;N, &amp;amp;T); for(int i = 0; i &amp;lt; T; i++){ char c[3]; scanf(&amp;#34;%s&amp;#34;, c); if(c[0] == &amp;#39;C&amp;#39;){ int x1, y1, x2, y2; scanf(&amp;#34;%d %d %d %d&amp;#34;, &amp;amp;x1, &amp;amp;y1, &amp;amp;x2, &amp;amp;y2); add(x1, y1); add(x2 + 1, y1); add(x1, y2 + 1); add(x2 + 1, y2 + 1); } else{ int x, y; scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;x, &amp;amp;y); printf(&amp;#34;%d\n&amp;#34;, sum(x, y) % 2); } } puts(&amp;#34;&amp;#34;); } return 0; }</description></item><item><title>Codeforces Round 383 (Div. 2)</title><link>https://ptzu.github.io/posts/cf383/</link><pubDate>Wed, 07 Dec 2016 23:13:55 +0000</pubDate><guid>https://ptzu.github.io/posts/cf383/</guid><description>A. Arpa’s hard exam and Mehrdad’s naive cheat 題目
input 0 &amp;lt;= n &amp;lt;= 10^9
題解 求1378的 n 次方
解法 直接列舉 8 次方的可能 或是快速冪(需要mod)
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int fast_pow(int a,int b) { ll ans = 1,base = a; while(b!</description></item><item><title>Codeforces Round 366 (Div. 2)</title><link>https://ptzu.github.io/posts/cf366/</link><pubDate>Wed, 05 Oct 2016 21:22:50 +0000</pubDate><guid>https://ptzu.github.io/posts/cf366/</guid><description>A. Hulk 題目
題解 簡單字串處理
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int n; string s; int main(){ ios::sync_with_stdio(false); cin.tie(0); cin &amp;gt;&amp;gt; n; for(int i = 1; i &amp;lt;= n; i++){ if(i % 2 == 1){ s += &amp;#34;I hate &amp;#34;; } else if(i % 2 == 0){ s += &amp;#34;I love &amp;#34;; } if(i !</description></item><item><title>Codeforces Round 365 (Div. 2)</title><link>https://ptzu.github.io/posts/cf365/</link><pubDate>Wed, 05 Oct 2016 20:00:52 +0000</pubDate><guid>https://ptzu.github.io/posts/cf365/</guid><description>A. Mishka and Game 題目
題解 水題 判斷誰猜拳贏的次數多
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ ios::sync_with_stdio(false); cin.tie(0); int n; cin &amp;gt;&amp;gt; n; int num1 = 0; int num2 = 0; for(int i = 0; i &amp;lt; n; i++){ int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; if(a &amp;gt; b) num1++; else if(a &amp;lt; b) num2++; } if(num1 &amp;gt; num2) cout &amp;lt;&amp;lt; &amp;#34;Mishka\n&amp;#34;; else if(num2 &amp;gt; num1) cout &amp;lt;&amp;lt; &amp;#34;Chris\n&amp;#34;; else cout &amp;lt;&amp;lt; &amp;#34;Friendship is magic!</description></item><item><title>POJ 1988 Cube Stacking</title><link>https://ptzu.github.io/posts/poj1988/</link><pubDate>Tue, 09 Aug 2016 23:07:00 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1988/</guid><description>題解 現在有 N 個 cube, 每個一開始都是自己一個堆疊 編號為 1 ~ N input 有兩種指令
M a b: 將含有 a 的堆疊放到含有 b 的堆疊上面 C a: 計算在編號 a cube 之下有幾個 cube 作法 算是併查集進階一點的應用 首先定義兩個陣列
num[i]: 以 i 為 root 的集合有幾個 cube under[i]: 在 i 之下有幾個 cube 接著在 unite 中 M 1 2 -&amp;gt; unite(1, 2) 是將 1 加到 2 的集合中 就很當然的 under[a] += num[b] 而 b 集合也會增加數量 num[b] += num[a] 而在 find 中 under+= under[temp] 似乎有點不直覺, 但只要想想一串接很長的集合 這些都是還未經過壓縮的(par不是根) 所以大家的 under 值都是 1 加起來便沒問題了 如果還是不清楚就畫一下圖吧 AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 2236 Wireless Network</title><link>https://ptzu.github.io/posts/poj2236/</link><pubDate>Tue, 09 Aug 2016 21:29:53 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2236/</guid><description>題解 有 N 台壞掉的電腦, 要使他們能重新連通 A 和 B 能連通必須在距離 d 之內, 不過可以透過第三者連接 input 會給每台電腦座標 接著有兩種指令：
O a: 代表修復 a 電腦 S a b: 代表測試 a 和 b 是否連通 作法 用 bool 陣列紀錄哪台電腦已經修復 接著迴圈掃其他電腦, 假如距離 &amp;lt; d 且該電腦已修復 就將他們加到同個集合(併查集, Disjoint Set Union) 當要查詢時就能直接看他們是否在同一個集合啦
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>Codeforces Beta Round 93 (Div. 1 Only)</title><link>https://ptzu.github.io/posts/cf93/</link><pubDate>Mon, 01 Aug 2016 21:10:58 +0000</pubDate><guid>https://ptzu.github.io/posts/cf93/</guid><description>B. Password # string 題目
題解 給一字串 尋找是否有一子字串 出現在前綴(開頭), 中間, 以及後綴 輸出符合條件的最長子字串 如果沒有就輸出 Just a legend
作法 字串搜尋類型的題目 暴力搜尋會花上 O(nm) 的時間 為了這題, 又去重新理解一次KMP 果然這東西還是很難記住啊~~
這題有兩種作法
用failure function 的特性 用rolling hash(尚未研究) 如果還不懂何謂KMP 先去看看演算法教學吧~~ &amp;mdash;-以下開始&amp;mdash;- 當建好 f 函數時 把所有有匹配到的字元, 做上標記(不標記最後一字元) 然後看字串最後一個字元的 f 函數值是多少 假如前綴和後綴都有, 那我們就要來看中間是否有出現過啦 作法就是以最後一字元的函數值做回溯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>KTUcamp2</title><link>https://ptzu.github.io/posts/cfktucamp2/</link><pubDate>Tue, 26 Jul 2016 22:46:21 +0000</pubDate><guid>https://ptzu.github.io/posts/cfktucamp2/</guid><description>C. Rating Shuffle # binary_search 題目
題解 給 n 個人, 每個人都有評分(rating) 每場比賽每個人的評分可以上升或下降 d 分 求需要最少幾場可以使第 i 人, 評分第 i 大 也就是大到小
作法 可以觀察到愈多場次, 愈容易達成 所以可以用二分搜, 是否能使用 k 場來完成需求
想法： 先將第一人直接加到最大 接著看第二人需要幾場可以最接近第一人 但不超過他, 以此類推
需要注意的是奇偶數的判定 例如： 我們需要上升(或下降) 3 場, 而二分搜的場次為 4 場 但這樣不可能達成, 因為需要 +3 場, 則剩下那個一定是 -1 場 結果就為 +2 場
所以當有奇偶數場的差別時, 可以退而求其次, 不那麼接近 prev 也就是 need&amp;ndash;
而判斷函式回傳 false 的條件: abs(need) &amp;gt; mid 可分為兩部份討論
需要加上 +need 場數: 這種情況不影響, 因為可以不那麼接近, 而且會和 mid 取 min</description></item><item><title>Codeforces Round 364</title><link>https://ptzu.github.io/posts/cf364/</link><pubDate>Sun, 24 Jul 2016 22:58:53 +0000</pubDate><guid>https://ptzu.github.io/posts/cf364/</guid><description>C. They Are Everywhere 類似題目請參考 cfedu11 C 題 題目
題解 現有 n 間房間, 每間房間有不同類型的pokemon: a ~ z, A ~ Z 還真是趕的上流行的一題阿 哈哈 每間房間只能連到 n + 1 間, 意即只能往右走 求最少要經過幾間房間, 才能捉到所有類型的pokemon(input給的)
作法 又是一樣的兩端點區間的題目 用二分搜, 長度為 x 能不能捉到所有類型的pokemon 判斷函式寫法, 在長度 x 下用 map 記載類型數量 看能否達到題目要求的數量
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>Educational Codeforces Round 11</title><link>https://ptzu.github.io/posts/cfedu11/</link><pubDate>Sun, 24 Jul 2016 22:12:59 +0000</pubDate><guid>https://ptzu.github.io/posts/cfedu11/</guid><description>C. Hard Process # binary_search # two points 題目
題解 給定長度為 n 只有 0, 1 的數列現有 k 次機會可將 0 轉換成 1求可連續的 1 最長是多少作法 可利用二分搜, 假設長度 x 是否能在 k 次轉換得到由於觀察到長度愈長, 愈難達成有此單調性, 故可用二分搜是 1 1 1 1 0 0 0 0 類型AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f // LLONG_MIN LLONG_MaX INT_MIN INT_MaX int n, k; int a[303030]; bool C(int x, int &amp;amp;pos){ int block_1 = 0; for(int i=0; i&amp;lt;x; i++){ if(a[i] == 1) block_1++; } int need = x - block_1; for(int i=1; i + x - 1 &amp;lt; n; i++){ if(a[i - 1] == 1) block_1--; if(a[i + x - 1] == 1) block_1++; if(x - block_1 &amp;lt; need){ need = x - block_1; pos = i; } } return need &amp;lt;= k; } int binary_search(int &amp;amp;pos){ //[0,n], 1 1 1 1 0 0 0 0 type int lb = 0; int ub = n; if(C(lb, pos) == 0) return 0; if(C(ub, pos) == 1) return n; while(ub - lb &amp;gt; 1){ int mid = (lb + ub) / 2; if(C(mid, pos)) lb = mid; else ub = mid; } //Make the pos in the right place C(lb, pos); return lb; } int main(){ ios::sync_with_stdio(false); cin.</description></item><item><title>Codeforces Beta Round 89 (Div. 2) (not finished)</title><link>https://ptzu.github.io/posts/cf89/</link><pubDate>Fri, 15 Jul 2016 16:34:29 +0000</pubDate><guid>https://ptzu.github.io/posts/cf89/</guid><description>D. Caesar&amp;rsquo;s Legions 題目
題解 給 n1, n2, k1, k2 現有一排軍隊, n1 個步兵, n2個騎兵 步兵不能連續站在一起超過 k1 個, 騎兵不能超過 k2 個 求有多少種排法符合條件
作法 一開始想到的DP定義 dp[i][j][k] : i 位士兵, 最後一串連續的士兵為 j: 0 是步兵, 1 是騎兵, 連續的長度為k
但這樣會有個問題,用了 i 位士兵,無法判定那兩種士兵各用了幾位(可能會超過(n1 or n2)
所以改成 dp[i][j][k][l] : i, j 分別代表步兵和騎兵各有幾位 其他定義相同
答案為dp[n1][n2][0][1~k1] + dp[n1][n2][1][1~k2] 總和 % 100000000
DP遞迴 if(連續長度 &amp;gt; 1) //直接補上一個數字,方法數等同前一長度的方法數 dp[i][j][k][l] = dp[i][j][k][l - 1] else if(連續長度 == 1) //選擇另一種士兵,連續長度為 1 &amp;lt;= s &amp;lt;= (k1 or k2)的總和, 要注意 s 不能超過 i 或 j, 不然會多算 dp[i][j][k][l] = sum(dp[i][j][!</description></item><item><title>POJ 3046 Ant Counting</title><link>https://ptzu.github.io/posts/poj3046/</link><pubDate>Sat, 09 Jul 2016 23:26:56 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3046/</guid><description>題解 多重背包變形 給定有 T 個不同的家族,及有 A 隻螞蟻(屬於哪個家族) 求利用 T 個家族,及總共S&amp;hellip;B隻螞蟻的情況下 能組出不同組合的數量
作法 分割成子問題,只用前i家族的螞蟻,慢慢推到全部 定義dp[i][j] ： 用前i個家族共j隻螞蟻,能組出不同組合的數量 題目要求只輸出6位數,所以還要取餘數
DP遞迴 dp[i][j] = sum(dp[i-1][j-k]), k為目前i家族所有的螞蟻數量 概念類似排列組合的選取,選i家族：0隻、1隻&amp;hellip;、num[i]隻 那i-1就要用j-k隻(不然怎麼有j隻嘛)
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 1742 Coins</title><link>https://ptzu.github.io/posts/poj1742/</link><pubDate>Sat, 09 Jul 2016 10:11:43 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1742/</guid><description>題解 給定硬幣面額及數量,求在金額 m 以內,可以組出的額度數量作法 可以用多重背包,三層迴圈去解,但會TLE所以我們先把它當成無限背包解,再用一個陣列num去紀錄已使用的硬幣數量時間複雜度：O(nm)兩種DP表格建法 1.若j金額可以,則推廣到j + A[i]
for (int i = 0; i &amp;lt; N; ++i) { fill(num, num+M+1, 0); for (int j = 0; j+A[i] &amp;lt;= M; ++j) if (dp[j] == true &amp;amp;&amp;amp; !dp[j+A[i]] &amp;amp;&amp;amp; num[j] &amp;lt; C[i]) { dp[j+A[i]] = true; num[j+A[i]] = num[j] + 1; } } 2.若j - A[i]可以組出,則金額j也可組出
for(int i = 0; i &amp;lt; n; i++){ memset(num, 0, sizeof(num)); //j從A[i]開始,因為小於A[i]不可能組出 for(int j = A[i]; j &amp;lt;= m; j++){ if(dp[j] == false &amp;amp;&amp;amp; dp[j - A[i]] &amp;amp;&amp;amp; num[j - A[i]] &amp;lt; C[i]){ dp[j] = true; num[j] = num[j - A[i]] + 1; } } } AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 3280 Cheapest Palindrome</title><link>https://ptzu.github.io/posts/poj3280/</link><pubDate>Wed, 06 Jul 2016 19:29:49 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3280/</guid><description>題解 迴文最小成本問題給定字符增添及刪除成本求將字串變成迴文的最小成本作法 字符的增添及刪除本質上是一樣的所以只要存下該字符的增添或刪除成本取最小的dp[i][j]： 代表字串i&amp;hellip;j變成迴文的最小成本遞迴式爲 dp[i][j] = min(dp[i+1][j] + cost, dp[i][j-1] + cost)看處理左邊或右邊哪個好當左右字符一樣時 s[i] == s[j]: 看dp[i+1][j-1] 是否能更小AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int N,M; int cost[30]; int dp[2048][2048]; int main(){ ios::sync_with_stdio(false); cin.</description></item><item><title>Codeforces Round 340 (Div. 2)</title><link>https://ptzu.github.io/posts/cf340/</link><pubDate>Sat, 28 May 2016 23:48:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf340/</guid><description>A. Elephant 題目
題解 簡單題 一次可走 1~5 求到終點最少要走幾次
作法 終點座標除以 5 再看是否整除
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define make_pair mp #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f // LLONG_MIN LLONG_MaX INT_MIN INT_MaX int main(){ int x; cin &amp;gt;&amp;gt; x; int ans = x / 5; if(x % 5 != 0) ans++; cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0; } B.</description></item></channel></rss>
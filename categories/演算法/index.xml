<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>演算法 on Ptzu's blog</title><link>https://ptzu.github.io/categories/%E6%BC%94%E7%AE%97%E6%B3%95/</link><description>Recent content in 演算法 on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 12 Jan 2018 15:12:43 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/%E6%BC%94%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>二分匹配</title><link>https://ptzu.github.io/posts/bipartite-matching/</link><pubDate>Fri, 12 Jan 2018 15:12:43 +0000</pubDate><guid>https://ptzu.github.io/posts/bipartite-matching/</guid><description>問題描述 給一張二分圖, 我們想要求取他的最大匹配 那什麼是匹配呢？ 匹配就是一個 &amp;ldquo;邊的集合&amp;rdquo; 裡面蒐集的邊有這個性質 &amp;ldquo;任兩條邊的端點必不相同&amp;rdquo; 我們想要的就是讓這個集合愈大愈好 而在二分圖上的最大匹配就是二分匹配
名詞解釋 匹配點, 非匹配點, 匹配邊, 非匹配邊: 最大匹配: 匹配邊數最多的匹配 完美匹配: 圖中的每一個點都是匹配點 交替路徑: 從未匹配點出發, 依序走未匹配邊, 匹配邊, 交錯下去的路徑 增廣路徑: 從未匹配點出發, 走交替路徑, 然後可以抵達另一個未匹配點的路徑
演算法過程 這裡介紹匈牙利演算法, 請搭配模版理解 一開始我們只要一遇到未匹配點, 那就將兩點匹配 接著從點3出發, 發現有一條增廣路徑 然後將剛剛那條路徑的顏色交換, 也就是非匹配邊和匹配邊互換身份 最後都沒有增廣路徑了, 結束演算法 匹配數 = 3
延伸主題 名詞 邊涵蓋: 一個邊集合 F, 使圖中的任意一點都至少與 F 的邊相連 點涵蓋: 一個點集合 S, 使圖中的任意一條邊都至少與 S 的點相連 獨立集合: 一個點集合 S, S 中的任意兩點在圖中都不相連 定理 對沒有孤立點的圖, |最大匹配| + |最小邊涵蓋| = |V| |最大獨立集合| + |最小點涵蓋| = |V| |最大匹配| = |最小點涵蓋| (König定理) 證明待補</description></item><item><title>KMP Algorithm 探討</title><link>https://ptzu.github.io/posts/kmp/</link><pubDate>Thu, 28 Jul 2016 13:06:36 +0000</pubDate><guid>https://ptzu.github.io/posts/kmp/</guid><description>關於KMP 一般再搜尋字串時, 暴力搜尋將每個位置都搜尋一次 同時比對要搜尋的字串(pattern) 時間複雜度為O(nm)
KMP演算法改進了一些不必要的搜尋 使得時間複雜度為O(n + m)
名詞定義 失敗函數(failure function): 當比對失敗時, pattern需位移幾位才能成為前綴, 一般用在字串比對失敗時查找, 故稱失敗函數
建立 F 函數 這邊放上網路上常見兩種寫法 不變的是 j 代表的是目前比對的字元的 &amp;lsquo;前一個字&amp;rsquo; f[i] 代表比對失敗時, j 要變成的位置
字串從 0 開始存, 沒匹配字元時, f 值為 -1 void getF(string s){ f[0] = -1; for(int i = 1; i &amp;lt; s.length(); i++){ int j = f[i - 1]; //如果不相等, 先位移到適合位置 while(j &amp;gt;= 0 &amp;amp;&amp;amp; s[j + 1] != s[i]) j = f[j]; if(s[j + 1] == s[i]) f[i] = j + 1; //還是不相等, 此時 j = -1 else f[i] = j; } } 字串從 1 開始存, 沒匹配字元時, f 值為 0 void getF(string s) { for (int i = 2; i &amp;lt;= s.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>演算法 on Ptzu's blog</title><link>https://ptzu.github.io/categories/%E6%BC%94%E7%AE%97%E6%B3%95/</link><description>Recent content in 演算法 on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 12 Jan 2018 15:12:43 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/%E6%BC%94%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>二分匹配</title><link>https://ptzu.github.io/posts/bipartite-matching/</link><pubDate>Fri, 12 Jan 2018 15:12:43 +0000</pubDate><guid>https://ptzu.github.io/posts/bipartite-matching/</guid><description>問題描述 給一張二分圖, 我們想要求取他的最大匹配 那什麼是匹配呢？ 匹配就是一個 &amp;ldquo;邊的集合&amp;rdquo; 裡面蒐集的邊有這個性質 &amp;ldquo;任兩條邊的端點必不相同&amp;rdquo; 我們想要的就是讓這個集合愈大愈好 而在二分圖上的最大匹配就是二分匹配
名詞解釋 匹配點, 非匹配點, 匹配邊, 非匹配邊: 最大匹配: 匹配邊數最多的匹配 完美匹配: 圖中的每一個點都是匹配點 交替路徑: 從未匹配點出發, 依序走未匹配邊, 匹配邊, 交錯下去的路徑 增廣路徑: 從未匹配點出發, 走交替路徑, 然後可以抵達另一個未匹配點的路徑
演算法過程 這裡介紹匈牙利演算法, 請搭配模版理解 一開始我們只要一遇到未匹配點, 那就將兩點匹配 接著從點3出發, 發現有一條增廣路徑 然後將剛剛那條路徑的顏色交換, 也就是非匹配邊和匹配邊互換身份 最後都沒有增廣路徑了, 結束演算法 匹配數 = 3
延伸主題 名詞 邊涵蓋: 一個邊集合 F, 使圖中的任意一點都至少與 F 的邊相連 點涵蓋: 一個點集合 S, 使圖中的任意一條邊都至少與 S 的點相連 獨立集合: 一個點集合 S, S 中的任意兩點在圖中都不相連 定理 對沒有孤立點的圖, |最大匹配| + |最小邊涵蓋| = |V| |最大獨立集合| + |最小點涵蓋| = |V| |最大匹配| = |最小點涵蓋| (König定理) 證明待補</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data Structure on Ptzu's blog</title><link>https://ptzu.github.io/categories/data-structure/</link><description>Recent content in Data Structure on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 02 Feb 2018 16:33:45 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/data-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>主席樹 Chairman Tree</title><link>https://ptzu.github.io/posts/template-chairman-tree/</link><pubDate>Fri, 02 Feb 2018 16:33:45 +0000</pubDate><guid>https://ptzu.github.io/posts/template-chairman-tree/</guid><description>Code 例題 POJ 2104 帶修改: ZOJ 2112(記憶體限制很緊)</description></item><item><title>樹狀數組 Binary Indexed Tree</title><link>https://ptzu.github.io/posts/template-bit/</link><pubDate>Wed, 24 Jan 2018 16:36:06 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bit/</guid><description>可做到:
單點更新 前綴和查詢(範圍查詢) 注意是 1-based index
Code const int MAX_N = 20000; int bit[MAX_N + 10]; int add(int i, int x){ while(i &amp;lt;= n){ bit[i] += x; i += i &amp;amp; -i; } } int sum(int i){ int ans = 0; while(i){ ans += bit[i]; i -= i &amp;amp; -i; } return ans; } 例題 POJ 1990</description></item><item><title>線段樹 Segment Tree</title><link>https://ptzu.github.io/posts/template-segment-tree/</link><pubDate>Wed, 24 Jan 2018 10:14:23 +0000</pubDate><guid>https://ptzu.github.io/posts/template-segment-tree/</guid><description>可做到:
範圍更新 範圍查詢 主要有兩種版本 一種是直接開 input 大小, 另一種是開滿 2 的倍數 陣列大小一定要開到 input 的 4 倍 原因是線段樹本身就需要 2 * N 的空間 樹高會是 {%math%}\left \lceil log_{2}N \right \rceil{%endmath%} 所以可能會多一層 (不管有沒有補滿 2 的倍數都會)
經過測試 update 的時候一定要 push 再 pull query 可以只做 push 就好
Code 這種寫法是直接開 input 大小 1-indexed, 閉區間 [l, r] 在時間上和空間上都比較優秀 缺點是要 trace 的時候不太好做
#define L(x) (x&amp;lt;&amp;lt;1) #define R(x) (1+(x&amp;lt;&amp;lt;1)) #define mid ((l+r)&amp;gt;&amp;gt;1) const int MAX_N = 101010; int seg[MAX_N * 4], lazy[MAX_N * 4]; int a[MAX_N]; void seg_build(int idx, int l, int r){ if(l == r){ seg[idx] = a[l]; return ; } seg_build(L(idx), l, mid); seg_build(R(idx), mid + 1, r); seg[idx] = seg[L(idx)] + seg[R(idx)]; } void seg_push(int idx, int l, int r){ if(lazy[idx]){ seg[L(idx)] += lazy[idx] * (mid - l + 1); seg[R(idx)] += lazy[idx] * (r - (mid + 1) + 1); lazy[L(idx)] += lazy[idx]; lazy[R(idx)] += lazy[idx]; lazy[idx] = 0; } } void seg_update(int a, int b, int x, int idx, int l, int r){ if(r &amp;lt; a || l &amp;gt; b) return ; if(a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b){ seg[idx] += (r - l + 1) * x; lazy[idx] += x; return ; } seg_push(idx, l, r); seg_update(a, b, x, L(idx), l, mid); seg_update(a, b, x, R(idx), mid + 1, r); seg[idx] = seg[L(idx)] + seg[R(idx)]; } int seg_query(int a, int b, int idx, int l, int r){ if(r &amp;lt; a || l &amp;gt; b) return 0; if(a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b) return seg[idx]; seg_push(idx, l, r); return seg_query(a, b, L(idx), l, mid) + seg_query(a, b, R(idx), mid + 1, r); } Code 這是開滿 2 的倍數版本 0-indexed, 開區間 [l, r)</description></item><item><title>併查集 Disjoint set</title><link>https://ptzu.github.io/posts/template-dsu/</link><pubDate>Thu, 02 Feb 2017 18:22:18 +0000</pubDate><guid>https://ptzu.github.io/posts/template-dsu/</guid><description>code const int MAX_N = ...; struct Union_Find { int par[MAX_N], num[MAX_N]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U;</description></item></channel></rss>
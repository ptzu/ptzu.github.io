<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>其他 on Ptzu's blog</title><link>https://ptzu.github.io/categories/%E5%85%B6%E4%BB%96/</link><description>Recent content in 其他 on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 14 Apr 2018 17:02:34 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/%E5%85%B6%E4%BB%96/index.xml" rel="self" type="application/rss+xml"/><item><title>TIOJ 1072 A.誰先晚餐</title><link>https://ptzu.github.io/posts/tioj1072/</link><pubDate>Sat, 14 Apr 2018 17:02:34 +0000</pubDate><guid>https://ptzu.github.io/posts/tioj1072/</guid><description>題目
input 輸入檔包含多組測試資料，每一組測試資料的第一行有一個整數N (1 ≤ N ≤ 10000)，代表跟小尹去吃飯的人數，接下來的N行每行有兩個以空白字元分隔的整數Ci Ei ( 1 ≤ i ≤ N, 1 ≤ Ci, Ei ≤ 1000)，其中Ci代表烹煮第i個人點的餐點所需要的時間，Ei代表第i個人把他點的餐點吃完所需要的時間。讀到N = 0的時候代表測試檔案的結尾，不需要對於這個數字作任何輸出。
題解 有 N 個人要吃飯 因為有人吃的快，有人吃的慢 每道餐點做的時間也不一樣 老闆只有一個廚具 要如何安排順序 使飯局結束時間最早
作法 由於不管怎麼排，老闆都是一直做菜 所以做完所有餐點的總時間都是一樣的 而結束時間就會是最後一道菜 加上那個人吃的時間 要使結束時間最短 最後一個人必須吃最快
以這樣的想法去 greedy 即可 另外也有可能最早吃的人 吃太久而超過最後一個人 所以每個人吃的時間都要維護最大值
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>工作排程問題統整</title><link>https://ptzu.github.io/posts/job-scheduling/</link><pubDate>Fri, 13 Apr 2018 20:58:24 +0000</pubDate><guid>https://ptzu.github.io/posts/job-scheduling/</guid><description>Job Scheduling 1 題目
input 第一列輸入 T, 代表 T cases 每筆測資開頭輸入 n (1 &amp;lt;= N &amp;lt;= 100) 代表 n 個工作 每個工作輸入 id, deadline, profit
題解 有 n 個工作 每個工作花費 1 單位時間完成 只要在 deadline 前完成就可以 求最大的 profit 為多少
作法 紀錄最大的 deadline profit 大到小排序後 每次從 max deadline 往前掃, 若有空間就放 時間複雜度: {%math%}O(n^2){%endmath%}
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>TIOJ 1224 矩形覆蓋面積計算</title><link>https://ptzu.github.io/posts/tioj1224/</link><pubDate>Wed, 28 Mar 2018 21:10:33 +0000</pubDate><guid>https://ptzu.github.io/posts/tioj1224/</guid><description>題目
input 輸入檔只包含一筆測試資料。 第一列有一個正整數n(1&amp;lt;=n&amp;lt;=100,000)，代表有n個矩形。 接下來有n列，每列有四個整數 L,R,D,U(0&amp;lt;=L&amp;lt;R&amp;lt;=1,000,000；0&amp;lt;=D&amp;lt;U&amp;lt;=1,000,000)代表矩形的左、右、下、上四個邊界座標。
題解 給你很多平面上的矩形，請求出它們覆蓋的總表面積。
作法 和 POJ 1151相同
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX struct line{ int pos, y1, y2, type; bool operator &amp;lt;(const line&amp;amp; a)const{ return pos &amp;lt; a.</description></item><item><title>HDU 1466 计算直线的交点数</title><link>https://ptzu.github.io/posts/hdu1466/</link><pubDate>Sat, 10 Mar 2018 20:59:25 +0000</pubDate><guid>https://ptzu.github.io/posts/hdu1466/</guid><description>題目
input 输入数据包含多个测试实例,每个测试实例占一行,每行包含一个正整数n（n&amp;lt;=20）,n表示直线的数量.
題解 平面上有n条直线，且无三线共点，问这些直线能有多少种不同交点数。 比如,如果n=2,则可能的交点数量为0(平行)或者1(不平行)。
作法 自己畫了幾個例子, 只覺得好亂 那麼多種直線, 找不到轉移式&amp;hellip;
只好上網找題解 首先將線分為兩種, 自由線以及平行線 所謂自由線就是那條線可以是任何方向, 只要不和平行線平行就好 平行線是彼此間互相平行的線, 定義180度水平的為平行線好了 接著我們試著畫看看 假設有 5 條自由線, 方向任意(甚至他們之間平行也沒差, 只要不和平行線平行就好) 然後我們加上一條水平線, 發現增加 5 個交點 再加上一條, 也是增加 5 個交點 於是假設現在有 i 條自由線, 加上 j 條平行線 增加的點為 i * j 個點
最後我們定義 dp[i][j]: 總共有 i 條線, j 個交點這種狀況是否成立 列舉不同數量的自由線和交點數量 若該狀態成立 dp[all][k + 平行線數 * 自由線數] 也會成立
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>UOJ 146.【NOIP2015】信息传递</title><link>https://ptzu.github.io/posts/uoj146/</link><pubDate>Thu, 01 Mar 2018 17:07:05 +0000</pubDate><guid>https://ptzu.github.io/posts/uoj146/</guid><description>題目
input 第一列輸入 n (n &amp;lt;= 200000) 代表 n 個人 接著輸入每個人的傳遞對象
題解 有 n 个同学（编号为 1 到 n ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 i 的同学的信息传递对象是编号为 Ti 的同学。
游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？
作法 求 SCC 個數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 200010; int V, E; vector &amp;lt;int&amp;gt; g[MAX_V]; int dfn[MAX_V], low[MAX_V], tot, ans; bool vis[MAX_V]; stack &amp;lt;int&amp;gt; S; void dfs(int x){ dfn[x] = low[x] = ++tot; vis[x] = true; S.</description></item><item><title>常用技巧篇</title><link>https://ptzu.github.io/posts/template-tricks/</link><pubDate>Tue, 20 Feb 2018 13:32:22 +0000</pubDate><guid>https://ptzu.github.io/posts/template-tricks/</guid><description>列舉因數 判斷後綴字串 a 是否為 b 的後綴字串
bool Suf(string a, string b){ if(a.length() &amp;gt; b.length()) return false; return a == b.substr(b.length() - a.length(), a.length()); } 分堆 離散化 平移視窗 浮點數 Graph linked list const int MAX_N = 50010; struct node{ int to, w; node* next; }*g[MAX_N], edges[MAX_N * 3]; int tot; inline void addEdge(int a, int b, int c){ node *e = &amp;amp;edges[tot++]; e-&amp;gt;to = b; e-&amp;gt;w = c; e-&amp;gt;next = g[a]; g[a] = e; }</description></item><item><title>NYOJ 16 矩形嵌套</title><link>https://ptzu.github.io/posts/nyoj16/</link><pubDate>Mon, 12 Feb 2018 01:33:06 +0000</pubDate><guid>https://ptzu.github.io/posts/nyoj16/</guid><description>題目
input 第一行是一个正正数N(0&amp;lt;N&amp;lt;10)，表示测试数据组数， 每组测试数据的第一行是一个正正数n，表示该组测试数据中含有矩形的个数(n&amp;lt;=1000) 随后的n行，每行有两个数a,b(0&amp;lt;a,b&amp;lt;100)，表示矩形的长和宽
題解 描述 有n个矩形，每个矩形可以用a,b来描述，表示长和宽。矩形X(a,b)可以嵌套在矩形Y(c,d)中当且仅当a&amp;lt;c,b&amp;lt;d或者b&amp;lt;c,a&amp;lt;d（相当于旋转X90度）。例如（1,5）可以嵌套在（6,2）内，但不能嵌套在（3,4）中。你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。
输出 每组测试数据都输出一个数，表示最多符合条件的矩形数目，每组输出占一行
作法 DAG 上 DP, 求最長路徑 若矩型 a, 可嵌套在矩型 b, 則 a 連一條邊到 b 形成一 DAG
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 16; pii p[1010]; int dp[1010]; vector &amp;lt;int&amp;gt; g[1010]; bool ok(pii a, pii b){ if((a.</description></item><item><title>位元操作 Bit Operation</title><link>https://ptzu.github.io/posts/template-bit-operation/</link><pubDate>Sun, 11 Feb 2018 23:34:06 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bit-operation/</guid><description>待補
https://blog.kuoe0.tw/posts/2012/01/28/bitwise-operation-set-operation/</description></item><item><title>HDU 4281 - Judges' response (2012天津網路賽)</title><link>https://ptzu.github.io/posts/hdu4281/</link><pubDate>Sun, 11 Feb 2018 20:13:14 +0000</pubDate><guid>https://ptzu.github.io/posts/hdu4281/</guid><description>題目
input 多筆測資, 每筆測資輸入 N, M, 2 &amp;lt;= N &amp;lt;= 16, 0 &amp;lt;= M &amp;lt;= 100000 代表 N - 1 位參賽者舉手發問, 裁判的耐心 M 接著輸入 N 個座標, 第一個座標為所有裁判的位置, 其餘為參賽者位置 再輸入 N 個解答問題所需要的時間, 同樣第一個為裁判
題解 現有一場比賽, 有 N - 1 位參賽者同時舉手發問 我們知道解答某參賽者的問題, 需要耗費的時間 但是每位裁判有固定 M 的耐心, 也就是他最多只願意花 M 分鐘解答 因此需要多位裁判去替選手解答 現有兩個問題:(第一次遇到一次問兩題的XD)
至少需要多少位裁判才能解答所有問題？ 假如裁判數量充足, 求一條路線使得所有裁判行走的時間總和最短 距離採歐基里得距離取 ceil, 且每位裁判的行走速度為 1 注意所有裁判的起始位置都一樣 作法 第一題可視為 n 個物品, 至少需要幾個箱子才能裝完(位元DP, 01背包(?)) 第二題是 MTSP, 上面那題我們已經將一個集合視為一個箱子, 也就是一位裁判負責的狀況 接著稍微解說一下作法:</description></item><item><title>ZJ b177 [TIOJ 1471] 山景 Skyline</title><link>https://ptzu.github.io/posts/zj-b177/</link><pubDate>Wed, 07 Feb 2018 14:38:51 +0000</pubDate><guid>https://ptzu.github.io/posts/zj-b177/</guid><description>題目
input 輸入 n, n必為偶數, n &amp;lt;= 3000
題解 一座山的山稜線由許多片段的45度斜坡構成，每一個片段不是上坡就是下坡。
/\ /\/ \ / \ 在我們眼前的所見的任何寬度為n個單位的山稜形狀，可以輕鬆地觀察到所有山頂的位置。
請問有多少種山稜線的形狀，使得所有山頂的位置由左而右非遞減呢？
所有的山稜線都必須完整，也就是說左右兩端都必須是高度為0的山腳，而且不能有任何山谷的位置隱沒在地平線底下。
這題在 2017中程盃 有出現類似題 這題的要求是山頂必須非遞減, 而中程盃那題是問 r 個高度為 k 的山頂有幾種畫法
作法 一開始想法是定義 dp[i][j] 為走 i 步高度為 j 有幾種畫法 而遞迴式是 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1] 不過這樣沒辦法保證山頂非遞減 後來參考 morris 的答案 想了整天, 最後畫圖才理解 首先定義 dp[i][j]: 第 i 條線, 高度 j 的點有幾種畫法 不難想像, 轉移方程式可以寫成 dp[i][j] = dp[i - 1][j - 1] 高度 j 當然可以從 j - 1 轉移過來 但還有個需要考慮的是, 同高度的也能轉移過來 而同高度的可以從不只一個地方轉移, 所以用 sum[j] 代表高度 j 的畫法 因此遞迴式變成這樣: dp[i][j] = dp[i - 1][j - 1] + sum[j] 我們稍微把圖畫得複雜一點: sum[j] 的遞迴方式是: sum[j] - dp[i - j][j] + dp[i][j] dp[i - j][j] 已經走到高度為 0 的路線 因此之後已經沒有路線可以走, 簡單來說就是被 dp[i][j] 取代掉 所以必須扣掉避免重複 而答案即是第 i 條線上面各種高度的總和</description></item><item><title>HDU 5418 - Victor and World</title><link>https://ptzu.github.io/posts/hdu5418/</link><pubDate>Mon, 05 Feb 2018 12:49:00 +0000</pubDate><guid>https://ptzu.github.io/posts/hdu5418/</guid><description>題目
input 第一列輸入 T, 代表 T case 每筆測資開頭輸入 n, m, 1 &amp;lt;= n &amp;lt;= 16, 1 &amp;lt;= m &amp;lt;= 100000 代表 n 個點, m 條邊 每條邊都是無向邊 輸入 u, v, w 代表 u 到 v 花費 w
題解 Victor 想環遊世界, 求拜訪每個國家並回到起點的最少花費 每個國家可拜訪不只一次
作法 同 POJ 3311 只是這題的距離不是給相鄰矩陣 先用 floyd 求一下距離
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>ZOJ 2112 Dynamic Rankings</title><link>https://ptzu.github.io/posts/zoj2112/</link><pubDate>Fri, 02 Feb 2018 12:16:07 +0000</pubDate><guid>https://ptzu.github.io/posts/zoj2112/</guid><description>題目
input 題解 作法 帶修改的主席樹
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 60000; int N, M, SZ, cnt; int a[MAX_N + 10]; vector &amp;lt;int&amp;gt; pool; struct node{ int l, r, val; }T[MAX_N * 40]; int root[MAX_N + 10], BIT[MAX_N + 10], use[MAX_N]; struct q{ int type, l, r, k; }Q[10010]; void init(){ cnt = 0; pool.</description></item><item><title>String 切 Token</title><link>https://ptzu.github.io/posts/string-token/</link><pubDate>Fri, 12 Jan 2018 12:46:31 +0000</pubDate><guid>https://ptzu.github.io/posts/string-token/</guid><description>有兩種方法
將 string 轉為 c 字串, 然後用 strtok 利用 stringstream 第一種：
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; string s; int main(){ while(getline(cin, s)){ char cstr[10000]; strcpy(cstr, s.c_str()); char *token = strtok(cstr, &amp;#34; &amp;#34;); while(token != NULL){ printf(&amp;#34;%s &amp;#34;, token); token = strtok(NULL, &amp;#34; &amp;#34;); } puts(&amp;#34;&amp;#34;); } return 0; } 第二種:
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; string s; stringstream ss; int main(){ while(getline(cin, s)){ ss.str(&amp;#34;&amp;#34;); ss.clear(); // 上面兩行是清空 stringstream, 兩行都必加 ss &amp;lt;&amp;lt; s; int n; while(ss &amp;gt;&amp;gt; n){ cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; endl; } return 0; } 測試資料:</description></item><item><title>XDoj 1077 - 循环节长度</title><link>https://ptzu.github.io/posts/xdoj1077/</link><pubDate>Thu, 04 Jan 2018 12:04:29 +0000</pubDate><guid>https://ptzu.github.io/posts/xdoj1077/</guid><description>題目
input 多筆測資, 輸入 a, b 0 &amp;lt;= a, b &amp;lt;= 10^9
題解 因為循環節長度最長不超過分母 而這題的分母很大, 不能用模擬除法 所以用 BSGS 來求離散對數
作法 根據定理 a / b 的循環節長度為: {% math %} \min { e\in N,10^{e}\equiv 1(mod\ b) } {% endmath %} 但要注意的是當 e == 0 的時候恆成立 所以我們需要小修改一下 BSGS 演算法
我們可以注意到當 e == 0 時, 是在列舉到 {% math %} a^{m} {% endmath %} 時相等 所以我們在建立 hash 表的時候, 只要建到 m - 1, 就可以避開這個 case 了</description></item><item><title>大數運算</title><link>https://ptzu.github.io/posts/template-bigint/</link><pubDate>Tue, 24 Oct 2017 23:31:43 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bigint/</guid><description>第三次寫大數了 在比賽裡面因為 JAVA 有內建大數 所以此類題目比較少出 不過刷題的時候還是會遇到
struct big{ vector &amp;lt;int&amp;gt; digit; big(){ } big(string s){ int len = s.length(); for(int i = 0; len - 1 - i &amp;gt;= 0; i++){ digit.push_back(s[len - 1 - i] - &amp;#39;0&amp;#39;); } } big operator +(const big&amp;amp; obj)const{ int carry = 0; int maxSize = max(digit.size(), obj.digit.size()), minSize = min(digit.size(), obj.digit.size()); big res; for(int i = 0; i &amp;lt; minSize; i++){ int num = digit[i] + obj.</description></item><item><title>關於 '\n' 的各種輸入</title><link>https://ptzu.github.io/posts/aboutnewline/</link><pubDate>Sun, 22 Oct 2017 10:20:09 +0000</pubDate><guid>https://ptzu.github.io/posts/aboutnewline/</guid><description>在 C/C++ 輸入字串的時候 輸入一個整數 n, 接著讀取 n 個字串 常常會發生下面這種問題
咦！！我的第 5 行勒？？ 不用懷疑, 絕對不是你的電腦壞掉, 而是你不夠了解程式內部的細節 事實上, 當我們每按一次 enter(換行) 的時候 他其實是輸入換行符號 在 Windows 上是 CR+LF, 在 Linux 上是 LF(也就是'\n'), 在 MAC OS 上是 CR 所以當我們進行輸入的時候, 資料會先被放在 buffer(暫存區) 而像 scanf 這些 input 函數會去 buffer 將資料讀取到記憶體 所以當 scanf 讀取一個數字時, 其實有個 &amp;lsquo;\n&amp;rsquo; 被遺留在 buffer 就像如此: 而這個時候 fgets 讀取就會讀到 &amp;lsquo;\n&amp;rsquo;, 理所當然的就少一行資料
以下就來分析各種 input 函數對於 &amp;lsquo;\n&amp;rsquo; 的處理方式
scanf(&amp;quot;%s&amp;quot;) 遇到 &amp;lsquo;\n&amp;rsquo; 就中止, 不讀入 &amp;lsquo;\n&amp;rsquo; fgets 遇到 &amp;lsquo;\n&amp;rsquo; 就中止, 讀入 &amp;lsquo;\n&amp;rsquo;, 會放到子串裡面 cin &amp;raquo; s 遇到 &amp;lsquo;\n&amp;rsquo; 就中止, 不讀入 &amp;lsquo;\n&amp;rsquo; getline 遇到 &amp;lsquo;\n&amp;rsquo; 就中止, 讀入 &amp;lsquo;\n&amp;rsquo;, 不會放到子串裡面 scanf(&amp;quot;%d\n&amp;quot;) 其實 scanf 是一個匹配函數, 甚至好幾個 &amp;lsquo;\n&amp;rsquo; 都被處理掉了 看完以上的例子, 應該會更清楚要怎麼處理這種 input 了！</description></item><item><title>ITSA第五屆桂冠賽 挑戰組</title><link>https://ptzu.github.io/posts/itsachallenge-5/</link><pubDate>Mon, 01 May 2017 09:41:49 +0000</pubDate><guid>https://ptzu.github.io/posts/itsachallenge-5/</guid><description>目錄 [A1] Extended Absolute Mode 題目
input 題解 作法 AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX vector &amp;lt;int&amp;gt; v; int cnt[200]; int pre[200]; int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ int n, d; v.</description></item><item><title>題單</title><link>https://ptzu.github.io/posts/%E9%A1%8C%E5%96%AE/</link><pubDate>Wed, 01 Mar 2017 10:59:54 +0000</pubDate><guid>https://ptzu.github.io/posts/%E9%A1%8C%E5%96%AE/</guid><description>DP: 矩型嵌套(經典題): NYOJ 16 兩人分錢: Uva 562 分兩隊並限制數量: Uva 10032 TSP: POJ 3311 MTSP、位元DP: HDU 4281 雙調TSP: POJ 2677 山稜線DP: ZJ b177
逆序數對: POJ 2299
單調隊列: POJ 2823
滑動視窗: CF452 B 判斷日曆
循環小數: Uva 275, XDoj 1077
字串刪除: CF452 E,F、CF455 D
無向圖求關節點: POJ 1144 無向圖求橋: Uva 796
CF 推薦: round 452
多版本的POJ分类
流传最广的一种分类：
初期:
一.基本算法:
(1)枚举. (poj1753,poj2965) (2)贪心(poj1328,poj2109,poj2586) (3)递归和分治法. (4)递推. (5)构造法.(poj3295) (6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996) 二.图算法:
(1)图的深度优先遍历和广度优先遍历. (2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra) (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240) (3)最小生成树算法(prim,kruskal) (poj1789,poj2485,poj1258,poj3026) (4)拓扑排序 (poj1094) (5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020) (6)最大流的增广路算法(KM算法).</description></item><item><title>二分搜</title><link>https://ptzu.github.io/posts/template-binary-search/</link><pubDate>Wed, 01 Mar 2017 00:13:45 +0000</pubDate><guid>https://ptzu.github.io/posts/template-binary-search/</guid><description>0, 1型 bool C(int x){ } int sol(){ int l = 0, u = N; if(C(l)) return l; if(!C(u)) return -1; while(u - l &amp;gt; 1){ int mid = (u + l) / 2; if(C(mid)) l = mid; else u = mid; } return u; } 1, 0型 bool C(int x){ } int sol(){ int l = 0, u = N; if(!C(l)) return -1; if(C(u)) return u; while(u - l &amp;gt; 1){ int mid = (u + l) / 2; if(C(mid)) u = mid; else l = mid; } return l; }</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tree on Ptzu's blog</title><link>https://ptzu.github.io/categories/tree/</link><description>Recent content in Tree on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 17 Mar 2018 16:11:19 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/tree/index.xml" rel="self" type="application/rss+xml"/><item><title>重心分解 Tree Decomposition</title><link>https://ptzu.github.io/posts/template-tree-decomposition/</link><pubDate>Sat, 17 Mar 2018 16:11:19 +0000</pubDate><guid>https://ptzu.github.io/posts/template-tree-decomposition/</guid><description>又稱為重心剖分、點分治
由於重心有個特性是, 子樹大小不超過 n / 2 n 為整顆樹的大小
所以每次找重心可以將時間複雜度壓到 O(logn)
Code struct edge{ int to, w; }; int V, k; vector &amp;lt;edge&amp;gt; g[10010]; bool vis[10010]; int son[10010], centroid, balance_size; int dis[10010]; void tree_centroid(int x, int fa, const int size){ int mx_son = 0; son[x] = 1; for(int i = 0; i &amp;lt; sz(g[x]); i++){ int v = g[x][i].to; if(v == fa || vis[v]) continue; tree_centroid(v, x, size); son[x] += son[v]; mx_son = max(mx_son, son[v]); } mx_son = max(mx_son, size - son[x]); if(mx_son &amp;lt; balance_size){ balance_size = mx_son; centroid = x; } } void tree_decomposition(int x, const int size){ balance_size = INF; tree_centroid(x, -1, size); int cent = centroid; vis[cent] = true; do something.</description></item><item><title>樹重心 Tree Centroid</title><link>https://ptzu.github.io/posts/template-tree-centroid/</link><pubDate>Wed, 14 Mar 2018 14:42:43 +0000</pubDate><guid>https://ptzu.github.io/posts/template-tree-centroid/</guid><description>將樹的一點移除, 會產生許多子樹 其中使子樹中最大數量最小的點為重心
方法為跑一次 DFS, 紀錄每個點的子樹數量 同時也更新最小值
Code vector &amp;lt;int&amp;gt; g[20010]; int son[20010], centroid, balance_size; int V; void dfs(int x, int pa){ int mx_son = 0; void tree_centroid(int x, int fa, const int size){ int mx_son = 0; son[x] = 1; for(int i = 0; i &amp;lt; sz(g[x]); i++){ int v = g[x][i]; if(v == fa) continue; tree_centroid(v, x, size); son[x] += son[v]; mx_son = max(mx_son, son[v]); } mx_son = max(mx_son, size - son[x]); if(mx_son &amp;lt; balance_size || (mx_son == balance_size &amp;amp;&amp;amp; x &amp;lt; centroid)){ balance_size = mx_son; centroid = x; } } 例題 POJ 1655</description></item><item><title>LCA (Lowest Common Ancestor)</title><link>https://ptzu.github.io/posts/template-lca/</link><pubDate>Fri, 16 Feb 2018 19:57:50 +0000</pubDate><guid>https://ptzu.github.io/posts/template-lca/</guid><description>待學方法: Tarjan 離線O(n), RMQ在線
使用倍增法(binary lifting)求 LCA par[v][k] 為點 v 往上走 {%math%}2^{k}{%endmath%} 次的點 首先跑一次 DFS 求出各點的深度 接著跑 LCA 時, 先將比較深的那個點, 往上走到相同高度 由於 LCA 那個點往上走, 每個點都是共同祖先 所以可以用二分搜尋的概念
0 0 0 0 1 1 1 1 ^ ^ 走 2^0 次 走 2^7 次 0 代表不是祖先 1 代表是祖先 一開始走最大步, 接著逐漸縮小 如果該點不是祖先, 就往上走 是祖先就不動, 最後停下來的地方就是邊界
可求任意點對的 LCA 注意: 點是 0-indexed, 需先求好每個點走 1 步的 par 複雜度: {%math%}O(NlogN){%endmath%}
Code const int MAX_N = 10000; const int MAX_LOG_N = 14; int N, root; int depth[MAX_N]; int par[MAX_N][MAX_LOG_N]; vector &amp;lt;int&amp;gt; g[MAX_N]; void init(){ memset(par, -1, sizeof(par)); memset(g, 0, sizeof(g)); } void dfs(int u, int p, int d){ depth[u] = d; for(int i = 0; i &amp;lt; sz(g[u]); i++){ int v = g[u][i]; if(v !</description></item></channel></rss>
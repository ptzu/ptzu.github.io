<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Uva on Ptzu's blog</title><link>https://ptzu.github.io/categories/uva/</link><description>Recent content in Uva on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 14 Apr 2018 19:42:12 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/uva/index.xml" rel="self" type="application/rss+xml"/><item><title>Uva 11269 - Setting Problems</title><link>https://ptzu.github.io/posts/uva11269/</link><pubDate>Sat, 14 Apr 2018 19:42:12 +0000</pubDate><guid>https://ptzu.github.io/posts/uva11269/</guid><description>題目
input 多筆測資, 每筆開頭輸入 n (1 &amp;lt;= n &amp;lt;= 20) 代表有 n 道題目 下一列輸入 Sultan 準備這道題目要花多久 再下一列輸入 GolapiBaba 準備這道題目要花多久
題解 Sultan 和 GolapiBaba 想準備 N 道題目 兩人分工準備一道題目, 分別花上不同的時間 Sultan 做完他的部份, GolapiBaba 才可以接著做 每個人都不能同時準備兩道以上的題目 問最少要花多少時間
作法 完全想不到&amp;hellip; 這似乎叫作相鄰交換法 一次考慮兩個任務 a, b 我們想知道 ab, ba 這兩種順序 何者花的時間比較少 若是 a 先做, 花的時間為 a.st + max(a.nd, b.st) + b.nd 反之一樣 排序好之後, 去計算時間即可
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 11389 - The Bus Driver Problem</title><link>https://ptzu.github.io/posts/uva11389/</link><pubDate>Sat, 14 Apr 2018 16:38:26 +0000</pubDate><guid>https://ptzu.github.io/posts/uva11389/</guid><description>題目
input 多筆測資, 每筆測資開頭輸入 n, d, r (1 &amp;lt;= n &amp;lt;= 100)(1 &amp;lt;= d &amp;lt;= 10000)(1 &amp;lt;= r &amp;lt;= 5) 下一列輸入 n 個早上路徑 再下一列輸入 n 個下午路徑
題解 有 n 位司機, 每位司機會被分配到一個早上和下午路徑 若是一天的總路程超過 d, 則每一單位長度要付 r 元 求如何安排使加班費最少
作法 大的配小的
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 684 - Integral Determinant</title><link>https://ptzu.github.io/posts/uva684/</link><pubDate>Mon, 12 Mar 2018 01:00:56 +0000</pubDate><guid>https://ptzu.github.io/posts/uva684/</guid><description>題目
input 多筆測資, 每筆測資開頭輸入 n (n &amp;lt;= 30) 代表矩陣大小 接著輸入 n x n 矩陣
題解 求行列式
作法 求行列式
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX typedef vector&amp;lt;ll&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; ll determinant(mat m){ int n = m.</description></item><item><title>Uva 10285 - Longest Run on a Snowboard</title><link>https://ptzu.github.io/posts/uva10285/</link><pubDate>Thu, 08 Mar 2018 21:37:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10285/</guid><description>題目
input 第一列輸入 T, 代表 T cases 每筆測資輸入 name, row, col 接著輸入每個點的高度
題解 現在要滑雪, 從平地到目前高度的步數是 1 接下來只能選比目前低的&amp;quot;周圍點&amp;quot;滑下去 每滑一個點算一步, 求最長路徑
作法 非常水的一題&amp;hellip; 每個點 dfs 一次就好了 dp 陣列只是紀錄跑過的不要跑, 加快而已
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 10010; int a[200][200]; int dp[200][200]; pii dir[] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int r, c; int ans; void solve(pii s, int len){ dp[s.</description></item><item><title>Uva 10056 - What is the Probability ?</title><link>https://ptzu.github.io/posts/uva10056/</link><pubDate>Thu, 08 Mar 2018 20:41:17 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10056/</guid><description>題目
input 第一列輸入 T (T &amp;lt;= 1000), 代表 T cases 每筆測資輸入 n, p, k 代表 n 個玩家, 抽到勝利的機率, 第 k 個玩家
題解 一群人在玩骰子, 非傳統骰子, 只要骰到某個數字他就贏 骰到某個數字的機率為 p, 求第 k 個人贏的機率
作法 模擬算機率 贏的機率為 p, 輸的機率為 1 - p = q 但由於沒有說要玩幾輪 所以不斷累加 全輸的機率 * 某一輪贏的機率 因為後面的機率已經太小了, 不會影響答案, 所以設個中斷點即可
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 10319 - Manhattan</title><link>https://ptzu.github.io/posts/uva10319/</link><pubDate>Thu, 08 Mar 2018 12:02:59 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10319/</guid><description>題目
input 含多筆測資, 輸入 T, 代表 T 座城市 每筆測資開頭輸入 r, c, m (0 &amp;lt;= r,c &amp;lt;= 20)(0 &amp;lt;= m &amp;lt;= 200) 代表 street, avenue, route 數量 接著 m 條 route 輸入起點與終點
題解 每座城市有 r 條 street(東西向), c 條 avenue(南北向) 替每條路指定方向(只能往東南西北一個方向) 定義一條合法的 route 為起點走到終點, 走的路都為指定方向 而一條 simple route, 就是路程中最多一次轉向
給 M 對起點終點, 若有至少一條 simple route 就輸出 Yes 反之 No
作法 判斷 2-SAT 是否為 true
將一條路當成一個邏輯變數 先定義向東以及向南為 True 假設起點為 (r1, c1), 終點為 (r2, c2)</description></item><item><title>Uva 796 - Critical Links</title><link>https://ptzu.github.io/posts/uva796/</link><pubDate>Sun, 04 Mar 2018 21:01:42 +0000</pubDate><guid>https://ptzu.github.io/posts/uva796/</guid><description>題目
input 含多筆測資 每筆測資第一列輸入 n, 代表有幾台伺服器 接著輸入 n 台伺服器所連接的伺服器 格式: u (num) v1, v2&amp;hellip; 伺服器 u 連接到 v
題解 在電腦網路中, 若移除某條網路 會造成某兩台伺服器不連通 則稱此條網路為 critical 求有哪些 critical network
作法 求橋裸題 橋的輸出必須升序, 並且由小的編號連到大的(題目沒看到哪裡有講= =)
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 10010; int V, E; vector &amp;lt;int&amp;gt; g[MAX_V]; int dfn[MAX_V], low[MAX_V], tot; vector &amp;lt;pii&amp;gt; ans; void init(){ for(int i = 0; i &amp;lt; V; i++) g[i].</description></item><item><title>Uva 11069 - A Graph Problem</title><link>https://ptzu.github.io/posts/uva11069/</link><pubDate>Sun, 25 Feb 2018 00:46:36 +0000</pubDate><guid>https://ptzu.github.io/posts/uva11069/</guid><description>題目
input 多筆測資, 輸入 n (1 ≤ n ≤ 76)
題解 你的任務是：給你 n ，請算出這個圖形有以下性質的節點子集合共有多少個
集合裡不能有兩個相鄰的點。例如圖形中有 n = 3 個節點，則集合 {1,2} 是違法的，而集合 {1,3} 是合法的 當這個集合能再加入任一節點，卻可以不和其它節點相鄰，則這個集合是違法的。例如圖形中有 n = 5個節點，則集合 {1,5} 是違法的，因為這個集合再加入節點 3 仍不和其它節點相鄰，而集合 {1,3,5} 則是合法的 所以，當圖形有 n = 5 個節點時，應該有 4 個合法的集合：{1,3,5},{2,4},{2,5},{1,4}.
作法 對於 n = i 來說 i - 2 的所有組合必定可以加入 i 而 i - 1 必定不可加, 所以保留原樣轉移到 i 然而 i - 1 有些組合是從 i - 2 轉移過去 所以這樣會重複 因此分開紀錄 定義 dp[i][0] = dp[i - 2][0] + dp[i - 2][1] 從 i - 2 轉移過來的, 必定可以加 i dp[i][1] = dp[i - 1][0] 從 i - 1 轉移過來, 不能包含從 i - 2 過來的</description></item><item><title>Uva 10007 - Count the Trees</title><link>https://ptzu.github.io/posts/uva10007/</link><pubDate>Fri, 09 Feb 2018 22:17:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10007/</guid><description>題目
input 多筆測資, 每筆測資輸入 n, 1 &amp;lt;= n &amp;lt;= 300 代表 n 個結點 輸入 0 測資結束
題解 給 n 個點求有幾種不同結構的二元樹 因為不同數字也算不同, 所以再乘上 n!
作法 卡塔蘭數 + 大數
AC code import java.util.Scanner; import java.math.BigInteger; import java.util.*; public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); BigInteger[] fac = new BigInteger[601]; fac[0] = fac[1] = BigInteger.ONE; for(int i = 2; i &amp;lt;= 600; i++) fac[i] = fac[i - 1].</description></item><item><title>Uva 10032 - Tug of War</title><link>https://ptzu.github.io/posts/uva10032/</link><pubDate>Mon, 05 Feb 2018 15:07:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10032/</guid><description>題目
input 第一列輸入 T, 代表 T case 每筆測資開頭輸入 n, n 最多 100 接著輸入 n 個人的體重
題解 將人分成兩堆, 使兩隊的體重和相差最小 並且兩隊人數最多只能差 1
作法 這題類似 Uva 562, 分成兩堆, 使得總和差最小 但是多了一個限制是人數只能差 1 原本是 dp[人數][重量] = 0 or 1, 代表該重量能否組出 現在多一個條件 dp[人數][重量][目前人數] = 0 or 1 的三維DP 但是會超時 我們把第三維度利用位元操作, 轉為 64 bits 的資料 也就是 dp[人數][重量] = bitset 而那個 bitset 代表的是組出這個重量, 那一隊可以有幾人 例如 dp[人數][重量] = 1110(二進位) 就代表他可以用 1(2^1)、2(2^2)、3(2^3) 這些人數組成 最後只要看 n/2、n/2+1(偶數人數), n/2(奇數人數)的 bit 是否成立即可
AC code #include &amp;lt;bits/stdc++.</description></item><item><title>Uva 562 - Dividing coins</title><link>https://ptzu.github.io/posts/uva562/</link><pubDate>Fri, 02 Feb 2018 19:16:02 +0000</pubDate><guid>https://ptzu.github.io/posts/uva562/</guid><description>題目
input 第一列輸入 Test Case 每筆測資開頭輸入 n, 表有 n 種硬幣 接著輸入 n 種硬幣
題解 兩人分錢
作法 要使差距最小, 那就是愈接近一半愈好 把金額當作背包, 使得背包裡的價值愈大愈好
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 60000; int n; int a[110]; int dp[50505]; int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(dp, 0, sizeof(dp)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); int sum = 0; for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); sum += a[i]; } int m = sum / 2; for(int i = 0; i &amp;lt; n; i++){ for(int j = m; j &amp;gt;= a[i]; j--) dp[j] = max(dp[j], dp[j - a[i]] + a[i]); } printf(&amp;#34;%d\n&amp;#34;, (sum - dp[m]) - dp[m]); } return 0; }</description></item><item><title>Uva 10420 - List of Conquests</title><link>https://ptzu.github.io/posts/uva10420/</link><pubDate>Fri, 22 Dec 2017 13:22:06 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10420/</guid><description>題目
input 第一列有一正整數 n, n &amp;lt;= 2000 接下來有 n 列, 每列最多 75 字 每列第一個字為國家, 後面接著女生的名字
題解 統計每個國家有幾個人
作法 用 map 去對應國家和人數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX map &amp;lt;string, int&amp;gt; mp; int main(){ fio; int n; cin &amp;gt;&amp;gt; n; string s, name; for(int i = 0; i &amp;lt; n; i++){ cin &amp;gt;&amp;gt; s; getline(cin, name); mp[s]++; } for(auto it : mp){ cout &amp;lt;&amp;lt; it.</description></item><item><title>Uva 10101 - Bangla Numbers</title><link>https://ptzu.github.io/posts/uva10101/</link><pubDate>Fri, 22 Dec 2017 12:56:33 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10101/</guid><description>題目
input 含多筆測資, 每筆測資輸入一個 long long 範圍內的非負整數
題解 把數字轉為題目規定的單位 kuti: 10000000 lakh: 100000 hajar: 1000 shata: 100 要注意的是, 單位前面的數字可能也可以轉為單位
作法 模擬
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX void print(ll n){ if(n &amp;gt;= 10000000){ print(n / 10000000); printf(&amp;#34; kuti&amp;#34;); n %= 10000000; } if(n &amp;gt;= 100000){ print(n / 100000); printf(&amp;#34; lakh&amp;#34;); n %= 100000; } if(n &amp;gt;= 1000){ print(n / 1000); printf(&amp;#34; hajar&amp;#34;); n %= 1000; } if(n &amp;gt;= 100){ print(n / 100); printf(&amp;#34; shata&amp;#34;); n %= 100; } if(n !</description></item><item><title>Uva 10929 - You can say 11</title><link>https://ptzu.github.io/posts/uva10929/</link><pubDate>Fri, 22 Dec 2017 12:18:32 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10929/</guid><description>題目
input 含多筆測資, 每筆測資為 1000 位數的數字, 輸入 0 為結束 注意數字可能有前綴 0 (卡這種東西真的很無聊, 題目又沒講)
題解 輸入一個數字, 判斷是否為 11 的倍數
作法 因為有 1000 位, 用字串來處理 (奇位數和 - 偶位數和) 是 11 的倍數的話, 該數可被 11 整除
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX char s[2000]; int main(){ while(scanf(&amp;#34;%s&amp;#34;, s) !</description></item><item><title>Uva 100 - The 3n + 1 problem</title><link>https://ptzu.github.io/posts/uva100/</link><pubDate>Fri, 22 Dec 2017 11:54:04 +0000</pubDate><guid>https://ptzu.github.io/posts/uva100/</guid><description>題目
input 多筆測資, 每筆測資含兩個正整數 a, b 0 &amp;lt; a, b &amp;lt; 1000000 (題目寫10000是錯的)
題解 目前有一個猜測還未被證實 給任意一個數 n, 如果是奇數就 n * 3 + 1, 否則就 n / 2 則最後一定會變成 1 則中間變化的過程稱為 cycle length(包含自己) 給 a, b 兩數, 求之間的數最大的 cycle length 注意變化過程在 32 bits integer內 所以要用 unsigned
作法 模擬
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 10035 - Primary Arithmetic</title><link>https://ptzu.github.io/posts/uva10035/</link><pubDate>Fri, 22 Dec 2017 11:00:09 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10035/</guid><description>題目
input 多筆測資, 每筆輸入兩個 10 位的正整數 輸入 0 0 代表結束
題解 兩個數字相加, 求有幾次進位
作法 用大數加法去算有幾次進位
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ fio; string s1, s2; while(cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2){ if(s1 == &amp;#34;0&amp;#34; &amp;amp;&amp;amp; s2 == &amp;#34;0&amp;#34;) break; if(s1.</description></item><item><title>Uva 10041 - Vito's Family</title><link>https://ptzu.github.io/posts/uva10041/</link><pubDate>Fri, 22 Dec 2017 09:03:09 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10041/</guid><description>題目
input 含有多筆測資, 每筆測資開頭有一正整數 r, 0 &amp;lt; r &amp;lt;= 500 接著有 r 個正整數 s, 0 &amp;lt; s &amp;lt; 30000
題解 想找一間房子離其它親戚最近
作法 到其它點的距離和最小, 找中位數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int a[1000]; int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); } sort(a, a + n); int mid = a[n / 2]; int ans = 0; for(int i = 0; i &amp;lt; n; i++) ans += abs(mid - a[i]); printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; }</description></item><item><title>Uva 10004 - Bicoloring</title><link>https://ptzu.github.io/posts/uva10004/</link><pubDate>Mon, 18 Dec 2017 22:09:08 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10004/</guid><description>題目
input 含有多筆測資, 每筆測資開頭有一正整數 n, 表 n 個點 接著含一正整數 l, 表 l 條邊 每條邊輸入 u, v, 代表 u 和 v 之間相連
題解 在 1976 年證明任何一張圖可以用 4 個顏色塗完, 相鄰兩點必須為不同顏色 而你現在要判斷是否能用兩個顏色塗完
作法 判斷二分圖裸題, 用DFS下去著色 如果相鄰的點和自己顏色一樣 就不是二分圖
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 210; vector &amp;lt;int&amp;gt; g[MAX_N]; int color[MAX_N]; bool dfs(int x, int c){ color[x] = c; bool ok = true; for(int i = 0; i &amp;lt; sz(g[x]); i++){ int v = g[x][i]; if(color[v] == 0) ok = min(ok, dfs(v, -c)); else if(color[v] == color[x]) return false; } return ok; } int main(){ int V, E; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;V) &amp;amp;&amp;amp; V){ for(int i = 0; i &amp;lt; MAX_N; i++) g[i].</description></item><item><title>Uva 10057 - A mid-summer night's dream.</title><link>https://ptzu.github.io/posts/uva10057/</link><pubDate>Mon, 18 Dec 2017 21:40:11 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10057/</guid><description>題目
input 含有多筆測資, 每筆測資開頭有一正整數 N 接著有 N 個數, 每個數不超過65536
題解 找出一個數, 使它與其他數的絕對值差, 總和最小 輸出符合條件最小的數, 以及 input 中有幾個這樣的數, 還有所有符合條件的數(含input以外的數)
作法 找中位數, 當有偶數個的時候, 兩個中位數之間的數也都符合條件
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 1000000; int v[1000010]; int main(){ int n; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Uva 12019 - Doom's Day Algorithm</title><link>https://ptzu.github.io/posts/uva12019/</link><pubDate>Mon, 18 Dec 2017 20:06:57 +0000</pubDate><guid>https://ptzu.github.io/posts/uva12019/</guid><description>題目
input 第一列有一正整數 N, 代表 test case 接著有 N 列測資, 每筆測資有 M, D, 代表月份和日期
題解 求出 2011年日期的星期
作法 先看 2011/1/1 是星期幾 然後記他的前一天是星期幾 之後在根據日期加上去, 7取餘數就是答案
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 1000000; int ZERO = 5; int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; string days[] = {&amp;#34;Sunday&amp;#34;, &amp;#34;Monday&amp;#34;, &amp;#34;Tuesday&amp;#34;, &amp;#34;Wednesday&amp;#34;, &amp;#34;Thursday&amp;#34;, &amp;#34;Friday&amp;#34;, &amp;#34;Saturday&amp;#34;}; int main(){ int n; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Uva 481 - What Goes Up</title><link>https://ptzu.github.io/posts/uva481/</link><pubDate>Fri, 15 Dec 2017 09:09:05 +0000</pubDate><guid>https://ptzu.github.io/posts/uva481/</guid><description>題目
input 據說50萬個數字左右
題解 求 LIS 的最長長度 如果有多個, 印最後一個出現的LIS
作法 LIS裸題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 1000000; int v[MAX_N]; int dp[MAX_N]; int pos[MAX_N]; int main(){ int x, n = 0; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;x) !</description></item><item><title>Uva 10130 - SuperSale</title><link>https://ptzu.github.io/posts/uva10130/</link><pubDate>Thu, 30 Nov 2017 11:51:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10130/</guid><description>題目
input 1 &amp;lt;= T, N &amp;lt;= 1000 1 &amp;lt;= P &amp;lt;= 100 1 &amp;lt;= W &amp;lt;= 30 1 &amp;lt;= 背包容量 &amp;lt;= 30
題解 給 n 個物品, 每個物品有價格和重量 每個人最多可以帶 MW 重量 每個人對某個物品最多只能拿一次 求全部人可以買多少價格的商品
作法 01背包問題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int V[1010], W[1010]; int dp[100], n; void solve(){ // 如果迴圈從重量開始, 會導致少算一些價值 // 例如求容量為 90 的最大價值, 可以放入重量 30, 60的物品 // 但是我們只會放入其中一個, 因為不管是 dp[90 - 30], dp[90 - 60] 都還沒計算 // 若迴圈從物品開始, 我們就可以計算每個容量的最大價值 // 可能有個疑問, 為什麼迴圈重量不從 0 開始跑就好, 這樣每個重量也都會被先計算阿？ // 因為這樣就變成多重背包問題(每個物品可以選不只一次)了=w= // for(int i = 99; i &amp;gt;= 0; i--){ // for(int j = 0; j &amp;lt; n; j++){ // if(i &amp;gt;= W[j]){ // dp[i] = max(dp[i], dp[i - W[j]] + V[j]); // } // } // } for(int i = 0; i &amp;lt; n; i++){ for(int j = 99; j &amp;gt;= W[i]; j--){ dp[j] = max(dp[j], dp[j - W[i]] + V[i]); } } } int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(dp, 0, sizeof(dp)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;V[i], &amp;amp;W[i]); } solve(); int G; scanf(&amp;#34;%d&amp;#34;, &amp;amp;G); int ans = 0; for(int i = 0; i &amp;lt; G; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); ans += dp[x]; } printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; }</description></item><item><title>Uva 369 - Combinations</title><link>https://ptzu.github.io/posts/uva369/</link><pubDate>Wed, 25 Oct 2017 19:44:07 +0000</pubDate><guid>https://ptzu.github.io/posts/uva369/</guid><description>題目
input 5 &amp;lt;= N &amp;lt;= M &amp;lt;= 100
題解 求 C N 取 M
作法 帕斯卡三角形
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; ll pascal[110][110]; void init(){ } int main(){ int N, M; pascal[1][0] = 1; pascal[1][1] = 1; for(int i = 2; i &amp;lt;= 100; i++){ pascal[i][0] = 1; for(int j = 1; j &amp;lt; i; j++){ pascal[i][j] = pascal[i - 1][j] + pascal[i - 1][j - 1]; } pascal[i][i] = 1; } while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;N, &amp;amp;M) !</description></item><item><title>Uva 374 - Big Mod</title><link>https://ptzu.github.io/posts/uva374/</link><pubDate>Wed, 25 Oct 2017 07:29:49 +0000</pubDate><guid>https://ptzu.github.io/posts/uva374/</guid><description>題目
input 0 &amp;lt;= B, P, M &amp;lt;= 2147483647
題解 求出 B^P % M
作法 利用快速冪即可, 可參考 求取指數完整題型 包含大數指數, 以及底數和指數都是大數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; void init(){ } ll fastpow(ll B, ll P, ll M){ ll base = B, ans = 1; while(P){ if(P &amp;amp; 1) ans = ans * base % M; base = base * base % M; P &amp;gt;&amp;gt;= 1; } return ans; } int main(){ ll B, P, M; while(scanf(&amp;#34;%lld%lld%lld&amp;#34;, &amp;amp;B, &amp;amp;P, &amp;amp;M) !</description></item><item><title>Uva 10107 - What is the Median?</title><link>https://ptzu.github.io/posts/uva10107/</link><pubDate>Wed, 25 Oct 2017 07:12:43 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10107/</guid><description>題目
input 0 &amp;lt;= X &amp;lt;= 2^31 N &amp;lt; 10000
題解 輸入一個數 X, 並將目前已輸入的數排序 根據每個輸入, 輸出當前的中位數
作法 若是每次讀進來一個都排序一次, 那肯定 TLE 所以我們可以利用 priority_queue, 每次進來只需要花 O(logn) 做調整
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; priority_queue &amp;lt;int, vector&amp;lt;int&amp;gt; &amp;gt; smaller; priority_queue &amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; bigger; void init(){ } int main(){ int x, mid = -1; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;x) !</description></item><item><title>Uva 10579 - Fibonacci Numbers</title><link>https://ptzu.github.io/posts/uva10579/</link><pubDate>Tue, 24 Oct 2017 23:35:40 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10579/</guid><description>題目
題解 求取 Fibonacci 數列
作法 這題是大數加法, 然後求取解就好了 N 沒給範圍, 不過根據結果, 是不需要用到矩陣快速冪的 有關 O(logn) 作法可以參考 矩陣快速冪
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; struct big{ vector &amp;lt;int&amp;gt; digit; big(){ } big(string s){ int len = s.</description></item><item><title>Uva 12716 - GCD XOR</title><link>https://ptzu.github.io/posts/uva12716/</link><pubDate>Mon, 23 Oct 2017 23:13:31 +0000</pubDate><guid>https://ptzu.github.io/posts/uva12716/</guid><description>題目
input T &amp;lt;= 10000 1 &amp;lt;= N &amp;lt;= 30000000
題解 求所有 GCD(A,B) = A XOR B 的pair數量, 對於 1 &amp;lt;= B &amp;lt;= A &amp;lt;= N
作法 首先有幾點必須先知道:
a XOR b &amp;gt;= (a - b) 以二進位來說, 一個 bit 為0, 一個 bit 為1 在 XOR 時為 1, 但是減法卻還要借位 而其他情況都相同, 所以可以肯定 a XOR b &amp;gt;= (a - b) 令GCD(a,b) = a ^ b = c 因為 a, b 的最大公因數為 c 所以可以寫成 a = k1 * c, b = k2 * c, k1 &amp;gt;= k2 a - b = (k1 - k2) * c, 所以 a - b &amp;gt;= c 結合以上兩點, 可以得到 (a - b) &amp;lt;= c &amp;lt;= (a - b) 根據夾擠定理, c = a - b 接著我們要列舉所有可能 a - b = c, 又 GCD(a,b) = c, 所以 a 可以寫成 k * c (k &amp;gt;= 2) 而 b 可以從 a - c 得到 這樣就可以找出所有 pair</description></item><item><title>Uva 275 - Expanding Fractions</title><link>https://ptzu.github.io/posts/uva275/</link><pubDate>Mon, 23 Oct 2017 17:16:18 +0000</pubDate><guid>https://ptzu.github.io/posts/uva275/</guid><description>題目
input a, b不超過1000
題解 找循環小數和其長度
作法 詳解請見 uva202
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int save[3030]; vector &amp;lt;int&amp;gt; res; void init(){ } int main(){ int a, b; while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a, &amp;amp;b) !</description></item><item><title>Uva 202 - Repeating Decimals</title><link>https://ptzu.github.io/posts/uva202/</link><pubDate>Sun, 22 Oct 2017 23:18:53 +0000</pubDate><guid>https://ptzu.github.io/posts/uva202/</guid><description>題目
input a, b 不超過3000
題解 求出 a / b 的循環小數以及其長度
作法 首先要知道的是, 在做除法時, 如果有個餘數重複出現過 則一定有循環小數。 a / b 的餘數會是 0 ~ b-1, 所以當計算到 b 次的時候 根據鴿籠原理, 一定會有個餘數重複, 所以有理數必有循環小數 我們只要模擬除法, 並用 save 陣列紀錄每個餘數的出現位置 若有出現過則找到循環小數, 並可以知道他的起始位置
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int save[3030]; vector &amp;lt;int&amp;gt; res; void init(){ } int main(){ int a, b; while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a, &amp;amp;b) !</description></item><item><title>Uva 1368 - DNA Consensus String</title><link>https://ptzu.github.io/posts/uva1368/</link><pubDate>Sun, 22 Oct 2017 19:49:35 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1368/</guid><description>題目
input m 個 DNA 序列長度 n 4 &amp;lt;= m &amp;lt;= 50, 4 &amp;lt;= n &amp;lt;= 1000
題解 定義 Hamming distance 為兩字串在同個 index, 有幾個字元不同 定義 Consensus error, 對於一個字串 y, 和字串集合 S, 他們之間的 Hamming distance 總和 而 Consensus error 最小的字串稱為 Consensus string 求 m 個序列中的 Consensus string 和他的 error
作法 要使每個字元的 error 最小, 那就找 m 個序列中 針對每個位置出現最多次的那個字元 若有多個符合的字串, 找到字典序最小的那個
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 232 - Crossword Answers</title><link>https://ptzu.github.io/posts/uva232/</link><pubDate>Sun, 22 Oct 2017 18:16:39 +0000</pubDate><guid>https://ptzu.github.io/posts/uva232/</guid><description>題目
input 1 &amp;lt;= r,c &amp;lt;= 10
題解 給一個 r * c 的格子, 有黑白格, 黑格用 * 表示 一個白格的上方 or 右方若 &amp;lsquo;沒有格子&amp;rsquo; 或 &amp;lsquo;有黑色格子&amp;rsquo; 則稱該白格為 eligible 將所有 eligible 格子從左到右, 上到下依序編號 每個單字的開頭一定要放在 eligible 求 Across(橫向單字), Down(縱向單字) 有哪些
作法 題目非常長, 不過作法卻很簡單, 實作就好了
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 227 - Puzzle</title><link>https://ptzu.github.io/posts/uva227/</link><pubDate>Sun, 22 Oct 2017 12:49:12 +0000</pubDate><guid>https://ptzu.github.io/posts/uva227/</guid><description>題目
input 含多筆測資, 輸入 &amp;lsquo;Z&amp;rsquo; 代表測資結束 每筆測資輸入 5X5 方格的字母 接著輸入需要做的移動, 上下左右對應到 ABLR, 輸入 0 代表操作結束 注意操作可能有多行
PS: 5X5中的那個空格, 直接複製網站測資會沒有空格, 自行補上
題解 給一個 5X5 方格, 每個小方格都有一個字母, 但有一格是空的 針對那個空格, 有四種操作, 上下左右移動 如果有不合法的移動, 輸出 &amp;ldquo;This puzzle has no final configuration.&amp;rdquo; 否則輸出移動後的方格狀況
作法 方格移動題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 455 - Periodic Strings</title><link>https://ptzu.github.io/posts/uva455/</link><pubDate>Sun, 22 Oct 2017 11:02:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva455/</guid><description>題目
input 最多 80 字元的字串
題解 求字串裏面最短的重複週期 例如: HoHoHo, 有 Ho 週期為 2 輸出2
作法 暴力法列舉不同子字串
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; void init(){ } int main(){ int TC, n; string s; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); getline(cin, s); for(int tc = 0; tc &amp;lt; TC; tc++){ getline(cin, s); getline(cin, s); int len = s.</description></item><item><title>Uva 1225 - Digit Counting</title><link>https://ptzu.github.io/posts/uva1225/</link><pubDate>Sun, 22 Oct 2017 08:26:40 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1225/</guid><description> 題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int cnt[10]; void init(){ } int main(){ int TC, n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(cnt, 0, sizeof(cnt)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 1; i &amp;lt;= n; i++){ int tmp = i; while(tmp){ cnt[tmp % 10]++; tmp /= 10; } } for(int i = 0; i &amp;lt;= 9; i++){ if(i == 0) printf(&amp;#34;%d&amp;#34;, cnt[i]); else printf(&amp;#34; %d&amp;#34;, cnt[i]); } puts(&amp;#34;&amp;#34;); } return 0; }</description></item><item><title>uva1586</title><link>https://ptzu.github.io/posts/uva1586/</link><pubDate>Sun, 22 Oct 2017 08:21:36 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1586/</guid><description>題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; map &amp;lt;char, double&amp;gt; mp; void init(){ } int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); mp[&amp;#39;C&amp;#39;] = 12.</description></item><item><title>Uva 1585 - Score</title><link>https://ptzu.github.io/posts/uva1585/</link><pubDate>Sun, 22 Oct 2017 01:08:49 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1585/</guid><description>題目
input 給多行字串, 每行字串長度最多80
題解 一個字串含有 &amp;lsquo;O&amp;rsquo;, &amp;lsquo;X&amp;rsquo;, 分別代表該題目對或錯 該題的分數取決於是目前連續第幾個答對的 例如有 &amp;lsquo;OO&amp;rsquo;, 則第 1 題 1 分, 第 2 題 2 分 以此類推, 求全部拿多少分
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; void init(){ } int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ string s; cin &amp;gt;&amp;gt; s; int cnt = 0, ans = 0; for(int i = 0; i &amp;lt; s.</description></item><item><title>Uva 1584 - Circular Sequence</title><link>https://ptzu.github.io/posts/uva1584/</link><pubDate>Sat, 21 Oct 2017 22:43:09 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1584/</guid><description>題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int n; string s; void init(){ } bool cmp(int now, int ans){ for(int i = 0; i &amp;lt; s.</description></item><item><title>Uva 1583 - Digit Generator</title><link>https://ptzu.github.io/posts/uva1583/</link><pubDate>Sat, 21 Oct 2017 10:53:31 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1583/</guid><description> 題目
input 1 &amp;lt;= n &amp;lt;= 100000
題解 給一個數字, 求他的最小生成元 例如: 256 = 245 + 2 + 4 + 5, 則 245 是 256 的生成元 一個數字可能有 0 個或多個生成元 求最小的
作法 先建表, 把每個數字可以生成的數字記起來 在根據輸入去查表
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 101010; int ans[MAX_N]; void init(){ } int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 1; i &amp;lt;= 100000; i++){ int tmp = i, sum = 0; while(tmp &amp;gt; 0){ sum += tmp % 10; tmp /= 10; } if(ans[i + sum] == 0) ans[i + sum] = i; } for(int i = 0; i &amp;lt; n; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); printf(&amp;#34;%d\n&amp;#34;, ans[x]); } return 0; }</description></item><item><title>Uva 340 - Master-Mind Hints</title><link>https://ptzu.github.io/posts/uva340/</link><pubDate>Sat, 21 Oct 2017 10:30:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva340/</guid><description>題目
input 含多筆測資, 每筆測資開頭有一正整數 N, N &amp;lt;= 1000, 代表密碼的長度 第二列有N個1到9的數字，代表密碼 接著有多組猜測, 每組猜測為 N 個 1~9 的數字, 全為 0 代表猜測結束 N = 0 代表測資結束
題解 如果有猜中數字, 位置也對, 則會得到一個 A 若是有猜中數字, 但位置不對, 則會得到一個 B 輸出幾A幾B
作法 我們可以先計算, 到底有幾個數字被猜中了 也就是針對 1~9 取 min(在密碼出現的次數, 猜測出現的次數) 然後我們可以找出, 有幾個數字是在正確位置 猜中次數扣掉正確位置的, 剩餘的都是在不正確位置, 也就是 B
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 401 - Palindromes</title><link>https://ptzu.github.io/posts/uva401/</link><pubDate>Fri, 20 Oct 2017 23:15:53 +0000</pubDate><guid>https://ptzu.github.io/posts/uva401/</guid><description>題目
input 給多行字串
題解 迴文字串定義：從左邊或右邊讀過來都長一樣 鏡像字串定義：以字型來看, 他是左右對稱的
作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX map &amp;lt;char, char&amp;gt; mp; void init(){ } int main(){ string s; char s1[] = {&amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;8&amp;#39;}; char s2[] = {&amp;#39;A&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;8&amp;#39;}; int len = strlen(s1); for(int i = 0; i &amp;lt; len; i++) mp[s1[i]] = s2[i]; while(cin &amp;gt;&amp;gt; s){ string tmp = s; reverse(tmp.</description></item><item><title>Uva 10986 - Sending email</title><link>https://ptzu.github.io/posts/uva10986/</link><pubDate>Sun, 01 Oct 2017 10:34:39 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10986/</guid><description>目錄 題目
題解 有 n 台 server, 之間用 cable 連結 每條 cable 有傳送延遲 請問從 server S to server T 最少需要多少時間？
作法 Dijkstra 裸題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX struct edge{ int to, w; }; int n, m, S, T; int d[20010]; vector &amp;lt;edge&amp;gt; g[20010]; int dijkstra(){ priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; pq; //d, v fill(d, d + n, INF); d[S] = 0; pq.</description></item><item><title>Uva 10684 - The jackpot</title><link>https://ptzu.github.io/posts/uva10684/</link><pubDate>Thu, 30 Mar 2017 22:45:00 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10684/</guid><description>題目
input n 個數: n &amp;lt;= 10000 數字 x: 0 &amp;lt; x &amp;lt; 1000
題解 Manuel 想要快速變有錢, 所以他決定去賭博 他精心計劃了贏錢的策略 每個下注可能贏錢或輸錢 求一段連續的下注最多可以獲得多少錢 ps: 題目說負值輸出 losing, 但根據測資, 0 也算 losing
作法 最大連續區間和裸題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int dp[10101]; int n; int main(){ while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Uva 10066 - The Twin Towers</title><link>https://ptzu.github.io/posts/uva10066/</link><pubDate>Fri, 17 Mar 2017 11:23:38 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10066/</guid><description>題目
input 牆磚: 1 ≤ N1, N2 ≤ 100 N1 個牆磚半徑 N2 個牆磚半徑
題解 在一個古帝國, 有兩座形狀不一樣的塔, 它們是由不同半徑的圓形牆磚疊合而成。 數千年後, 皇帝要求工匠移除某些牆磚, 使得兩座塔變得一樣, 當然牆磚的順序必須和原本的塔一樣 請問若要使塔的高度最高, 它有幾塊牆磚?
作法 要使塔最高, 就代表相同的牆磚要愈多愈好, 而且順序不能變 那就是 LCS 解了！ 輸出記得空一行
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int a[200], b[200]; int main(){ int cnt = 1; int n, m; while(scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;m) !</description></item><item><title>Uva 531 - Compromise</title><link>https://ptzu.github.io/posts/uva531/</link><pubDate>Fri, 17 Mar 2017 10:23:45 +0000</pubDate><guid>https://ptzu.github.io/posts/uva531/</guid><description>題目
input 有很多 test case, 每個 case 有兩人的提議, 而且分別以 # 做結尾 每個人的提議最多 100 字, 每字最多 30 字元
題解 再幾個月, 歐洲貨幣聯盟就要成立, 要加入他們必須滿足馬斯垂克條約, 這並不是一件簡單的事, 為了讓德國滿足條約, 政府有好幾個方法(增稅, 賣股票&amp;hellip;), 但是難以決定。 兩位政治人物分別提出了建議, 你的任務是從他們兩個的建議中, 找出最多相同的提議, 並輸出那些提議。
作法 LCS + 回溯 用 pre 陣列來紀錄目前這個解是從哪裡來, 回推回去 ps: 感覺 udebug 有幾個測資有錯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 111 - History Grading</title><link>https://ptzu.github.io/posts/uva111/</link><pubDate>Thu, 16 Mar 2017 22:31:01 +0000</pubDate><guid>https://ptzu.github.io/posts/uva111/</guid><description>題目
input n 個歷史事件: 2 ≤ n ≤ 20 接下一行是正確答案的事件rank 後面每行都是學生答案的rank
題解 在一個歷史考試中, 學生被要求根據歷史事件發生年代做排序 全部排對可以得到全部分數, 而部分給分規則如下
根據每個事件, 排在正確位置就得 1 分 根據每個事件, 只要他的相對順序是正確就得 1 分 而我們接下來要採用第 2 個規則 給一串序列, c1&amp;hellip;cn, 代表第 i 個事件排的&amp;quot;位置(rank)&amp;quot; 例如: 3, 1, 2, 則真實順序為 2, 3, 1 求每個學生的得分 作法 LCS 要注意的是 input 所代表的意義 另外我覺得範例怪怪的, 那應該是代表兩筆測資 因為我只對 n 做一次輸入就AC了 應該不用做到多筆測資 當然學生的input是多筆沒錯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 10003 - Cutting Sticks</title><link>https://ptzu.github.io/posts/uva10003/</link><pubDate>Mon, 13 Mar 2017 16:23:33 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10003/</guid><description>題目
input 棍子長度 L: 0 &amp;lt; L &amp;lt; 1000 切點數量 n: n &amp;lt; 50 切點位置: 0 &amp;lt; c &amp;lt; L 當 L = 0時結束輸入
題解 給一根棍子以及 n 個切點 切棍子的費用是, 要切的棍子長度 求切完 n 個點, 最小的花費
作法 O(N^3) 第二次做這題目, 看到原本的code卻一直想不通 是對切點做DP, 而不是棍子的長度！ 定義 dp[i][j]: 完成第 i 個點 &amp;hellip; 第 j 個點所花的最小費用 在頭尾新增兩個切點, cut[0] = 0, cut[n + 1] = L 作用是如果沒有切點在兩端, 就不好算當前棍子長度了
根據不同的 i &amp;hellip; j 範圍, 選擇一個 k 點切下去
DP遞迴式 dp[i][j] = {dp[i][k] + dp[k][j] + (cut[j] - cut[i]) | for i &amp;lt; k &amp;lt; j} AC code #include &amp;lt;bits/stdc++.</description></item></channel></rss>
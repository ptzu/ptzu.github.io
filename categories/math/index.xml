<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Math on Ptzu's blog</title><link>https://ptzu.github.io/categories/math/</link><description>Recent content in Math on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 13 Mar 2018 16:32:04 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/math/index.xml" rel="self" type="application/rss+xml"/><item><title>高斯消去法</title><link>https://ptzu.github.io/posts/template-gauss-elimination/</link><pubDate>Tue, 13 Mar 2018 16:32:04 +0000</pubDate><guid>https://ptzu.github.io/posts/template-gauss-elimination/</guid><description>Code typedef vector&amp;lt;int&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; int tot; // 自由變數量 void gauss(mat &amp;amp;m){ int n = m.size(); tot = 0; for(int col = 0; col &amp;lt; n; col++){ int tmp = tot; for(; tmp &amp;lt; n; tmp++) if(m[tmp][col]) break; if(tmp != n &amp;amp;&amp;amp; m[tmp][col]){ // 找到開頭是 1 的列, 有可能不在當前位置, 做列交換 for(int k = 0; k &amp;lt;= n; k++) swap(m[tot][k], m[tmp][k]); for(int row = 0; row &amp;lt; n; row++){ // 做消去 if(row !</description></item><item><title>矩陣行列式 Matrix Determinant</title><link>https://ptzu.github.io/posts/template-matrix-determinant/</link><pubDate>Sun, 11 Mar 2018 16:44:05 +0000</pubDate><guid>https://ptzu.github.io/posts/template-matrix-determinant/</guid><description>Code typedef vector&amp;lt;ll&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; ll determinant(mat m){ int n = m.size(); ll det = 1; for(int col = 0; col &amp;lt; n; col++){ for(int row = col + 1; row &amp;lt; n; row++){ int x = col, y = row; // 目前列, 下一列 while(m[y][col]){ // 下一列不為 0 就繼續做 ll q = m[x][col] / m[y][col]; for(int k = 0; k &amp;lt; n; k++){ m[x][k] -= m[y][k] * q; } swap(x, y); } if(x !</description></item><item><title>逆序數對 Inversion</title><link>https://ptzu.github.io/posts/template-inversion/</link><pubDate>Thu, 15 Feb 2018 21:23:46 +0000</pubDate><guid>https://ptzu.github.io/posts/template-inversion/</guid><description>若有一個 N 個數的數列 A 針對 index i &amp;lt; j, A[i] &amp;gt; A[j], 則 &amp;lt;A[i], A[j]&amp;gt; 稱為一個逆序數對 可用 Merge sort, BIT&amp;hellip; 等求出 詳細見:維基百科
例題 POJ 2299</description></item><item><title>快速傅利葉轉換 FFT</title><link>https://ptzu.github.io/posts/template-fft/</link><pubDate>Fri, 09 Feb 2018 21:03:48 +0000</pubDate><guid>https://ptzu.github.io/posts/template-fft/</guid><description>Code const int N = 500005; const double PI = acos(-1.0); struct Virt{ double r,i; Virt(double r=0.0,double i=0.0){ this-&amp;gt;r=r; this-&amp;gt;i=i; } Virt operator+(const Virt &amp;amp;x){ return Virt(r+x.r,i+x.i); } Virt operator-(const Virt &amp;amp;x){ return Virt(r-x.r,i-x.i); } Virt operator*(const Virt &amp;amp;x){ return Virt(r*x.r-i*x.i,i*x.r+r*x.i); } }; //雷德算法--倒位序 void Rader(Virt F[],int len){ int j=len&amp;gt;&amp;gt;1; for(int i=1;i&amp;lt;len-1;i++){ if(i&amp;lt;j)swap(F[i],F[j]); int k = len &amp;gt;&amp;gt; 1; while(j&amp;gt;=k){ j-=k; k&amp;gt;&amp;gt;=1; } if(j&amp;lt;k)j+=k; } } //FFT实现 void FFT(Virt F[],int len,int on){ Rader(F, len); for(int h=2;h&amp;lt;=len;h&amp;lt;&amp;lt;=1) //分治后计算长度为h的DFT { Virt wn(cos(-on*2*PI/h),sin(-on*2*PI/h)); //单位复根e^(2*PI/m)用欧拉公式展开 for(int j=0; j&amp;lt;len; j+=h) { Virt w(1,0); //旋转因子 for(int k=j;k&amp;lt;j+h/2;k++) { Virt u=F[k]; Virt t=w*F[k+h/2]; F[k]=u+t; //蝴蝶合并操作 F[k+h/2]=u-t; w=w*wn; //更新旋转因子 } } } if(on==-1) for(int i=0;i&amp;lt;len;i++) F[i].</description></item><item><title>BSGS Algorithm</title><link>https://ptzu.github.io/posts/template-bsgs/</link><pubDate>Wed, 03 Jan 2018 23:08:32 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bsgs/</guid><description>求離散對數 時間複雜度: O({%math%}\sqrt {n}{%endmath%})
Code map &amp;lt;ll, int&amp;gt; mp; //value, idx int fastpow(ll a, ll b){ ll base = a, ans = 1; while(b){ if(b &amp;amp; 1) ans = ans * base % P; base = base * base % P; b &amp;gt;&amp;gt;= 1; } return ans; } int BSGS(int a, int b, int P){ mp.clear(); int m = ceil(sqrt(P)); ll value = b % P; // j = 0, value = b mp[value] = 0; for(int j = 1; j &amp;lt;= m; j++){ value = value * a % P; // a^j * b mp[value] = j; } ll t = fastpow(a, m, P); // a ^ m value = 1; for(int i = 1; i &amp;lt;= m; i++){ value = value * t % P; // a ^ (i*m) if(mp.</description></item><item><title>大數取 MOD</title><link>https://ptzu.github.io/posts/bigint-mod/</link><pubDate>Mon, 09 Oct 2017 08:40:40 +0000</pubDate><guid>https://ptzu.github.io/posts/bigint-mod/</guid><description>Code ll getMod(string s, ll mod){ ll r = 0; for(char c : s) r = (r * 10 + c - &amp;#39;0&amp;#39;) % mod; return r; }</description></item><item><title>Mod Inverse 模板</title><link>https://ptzu.github.io/posts/template-mod-inverse/</link><pubDate>Mon, 09 Oct 2017 08:30:52 +0000</pubDate><guid>https://ptzu.github.io/posts/template-mod-inverse/</guid><description>AC code int mod_inverse(int a, int m){ int x, y; // x 是所求 extgcd(a, m, x, y); return (m + x % m) % m; }</description></item><item><title>快速冪(FastPow) 模板</title><link>https://ptzu.github.io/posts/template-fastpow/</link><pubDate>Mon, 18 Sep 2017 01:06:00 +0000</pubDate><guid>https://ptzu.github.io/posts/template-fastpow/</guid><description>在 log(N) 時間內求取冪次方
code int fastpow(int a,int b) { int ans = 1,base = a; while(b!=0) { if(b&amp;amp;1) ans *= base; base *= base; b&amp;gt;&amp;gt;=1; } return ans; }</description></item><item><title>Eratosthenes 模板</title><link>https://ptzu.github.io/posts/template-eratosthenes/</link><pubDate>Sun, 17 Sep 2017 22:39:17 +0000</pubDate><guid>https://ptzu.github.io/posts/template-eratosthenes/</guid><description>求取小於 n 的質數
code const int MAX_N = 1e5; vector &amp;lt;int&amp;gt; prime; bool is_prime[MAX_N + 10]; int sieve(int n){ fill(is_prime, is_prime + n, true); is_prime[0] = is_prime[1] = false; for(int i = 2; i &amp;lt;= n; i++){ if(is_prime[i]){ //紀錄質數 prime.push_back(i); // 消除 i 的倍數 for(int j = i * 2; j &amp;lt;= n; j += i){ is_prime[j] = false; } } } return (int)prime.size(); }</description></item><item><title>Extgcd 模板</title><link>https://ptzu.github.io/posts/template-extgcd/</link><pubDate>Sun, 17 Sep 2017 15:23:05 +0000</pubDate><guid>https://ptzu.github.io/posts/template-extgcd/</guid><description>求取 ax + by = gcd(a, b) 此方程式之解 並回傳 gcd(a, b)
code int extgcd(int a, int b, int &amp;amp;x, int &amp;amp;y){ int d = a; if(b != 0){ d = extgcd(b, a % b, y, x); y -= (a / b) * x; } else{ x = 1; y = 0; } return d; }</description></item></channel></rss>
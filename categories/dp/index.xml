<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DP on Ptzu's blog</title><link>https://ptzu.github.io/categories/dp/</link><description>Recent content in DP on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 10 Feb 2018 00:02:58 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>卡塔蘭數 Catalan number</title><link>https://ptzu.github.io/posts/template-catalan-number/</link><pubDate>Sat, 10 Feb 2018 00:02:58 +0000</pubDate><guid>https://ptzu.github.io/posts/template-catalan-number/</guid><description>一般式: {%math%} C_{n} = \dfrac {1}{n+1}\binom{2n}{n} = \dfrac {\left( 2n\right) !}{\left( n+1\right) !n!} {%endmath%} 遞迴式: {%math%}C_{n} = \dfrac {4*n-2}{n+1}C_{n-1}{%endmath%} 若可以觀察出 h(0) = 1,h(1) = 1 h(n) = h(0)*h(n-1) + h(1)*h(n-2) + &amp;hellip; + h(n-1)h(0) (其中 n &amp;gt;= 2) 則有可能是卡塔蘭數 可用於 二元樹種類個數&amp;hellip;等問題
Code big fac[MAX_N * 2]; big res = fac[2 * n] / fac[n + 1] / fac[n]; 例題 Uva 10007 POJ 2084</description></item><item><title>雙調TSP (Bitonic TSP)</title><link>https://ptzu.github.io/posts/template-bitonic-tsp/</link><pubDate>Thu, 08 Feb 2018 17:09:02 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bitonic-tsp/</guid><description>前言 從字面理解不知道是什麼怪東西。。。 據說是 CLRS 書 15-1 的習題, 有空再去翻看看~
簡單來說是 TSP 的簡化版, 限定從最左走到最右, 而且必須嚴格遞增/減 所以不再是 NP-Hard, 而是有 {%math%}O(n^{2}){%endmath%} 的作法
狀態 定義dp[i][j]: 從起點 1 出發, 走到 i 和 j 的最小總和(上下不同兩條路徑) dp[N][N] 即為答案, 因為可以看成 1 走到 N, N 走到 1 轉移 要怎麼保證上下兩條路徑, 不會走到相同的點呢？ 針對每個點, 每次只會把它放到上面或下面的路徑 假設目前要加的點是 j 上面那條路的最後點有可能是 1 ~ j - 1 分為兩個 case 討論
i &amp;lt; j - 1 點 j 可以從 j - 1 推導過來 dp[i][j] = dp[i][j - 1] + dis[j - 1][j], for i &amp;lt; j - 1 2.</description></item><item><title>位元DP</title><link>https://ptzu.github.io/posts/template-digit-dp/</link><pubDate>Sun, 04 Feb 2018 11:54:45 +0000</pubDate><guid>https://ptzu.github.io/posts/template-digit-dp/</guid><description>以 旅行推銷員問題(TSP) 為例 複雜度: {%math%} O(2^{n}n^{2}) {%endmath%}
BOTTOM UP 狀態 S代表目前已經走過的點集合, v為目前的點 dp[S][v]: 已經走完 S, 目前在 v, 所花費的最小權重和 轉移 找一點不在集合的點 u, 列舉集合的點 v 走到 u 的距離 {%math%}dp[S | (1 &amp;laquo; u)][u] = min\left { dp[S | (1 &amp;laquo; u)][i], dp[S][v] + d[v][u], u \notin S \right }{%endmath%}
Code for(int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; n); i++) fill(dp[i], dp[i] + n, INF); dp[1][0] = 0; for(int S = 1; S &amp;lt; (1 &amp;lt;&amp;lt; n); S++){ for(int i = 0; i &amp;lt; n; i++){ if((S &amp;amp; (1 &amp;lt;&amp;lt; i)) == 0){ for(int j = 0; j &amp;lt; n; j++){ if(S &amp;amp; (1 &amp;lt;&amp;lt; j)) dp[S | (1 &amp;lt;&amp;lt; i)][i] = min(dp[S | (1 &amp;lt;&amp;lt; i)][i], dp[S][j] + d[j][i]); } } } } TOP DOWN 作法 top-down 的作法, 我覺得有點難想, 要搭配圖案</description></item><item><title>0/1 背包問題</title><link>https://ptzu.github.io/posts/template-01knaspack/</link><pubDate>Fri, 02 Feb 2018 17:11:55 +0000</pubDate><guid>https://ptzu.github.io/posts/template-01knaspack/</guid><description>狀態 dp[i] = 在背包容量 i 情況下的最大價值 轉移 dp[j] = max(dp[j - wi] + vi), for i &amp;lt; n Code 例題 Uva 10130 POJ 3624</description></item><item><title>LCS 模板</title><link>https://ptzu.github.io/posts/template-lcs/</link><pubDate>Thu, 16 Mar 2017 10:34:32 +0000</pubDate><guid>https://ptzu.github.io/posts/template-lcs/</guid><description>定義 dp[i][j]: s1&amp;hellip;si 和 t1&amp;hellip;tj 的最長共同子序列
string s1, s2; int dp[100][100]; int main(){ cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2; int len1 = s1.length(); int len2 = s2.length(); for(int i = 0; i &amp;lt; len1; i++){ for(int j = 0; j &amp;lt; len2; j++){ if(s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j] + 1; else dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]); } } cout &amp;lt;&amp;lt; dp[len1][len2] &amp;lt;&amp;lt; endl; return 0; }</description></item></channel></rss>
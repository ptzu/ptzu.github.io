<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>視覺SLAM on Ptzu's blog</title><link>https://ptzu.github.io/categories/%E8%A6%96%E8%A6%BAslam/</link><description>Recent content in 視覺SLAM on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 24 Sep 2018 10:40:17 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/%E8%A6%96%E8%A6%BAslam/index.xml" rel="self" type="application/rss+xml"/><item><title>對極幾何 Epipolar Geometry</title><link>https://ptzu.github.io/posts/epipolar-geometry/</link><pubDate>Mon, 24 Sep 2018 10:40:17 +0000</pubDate><guid>https://ptzu.github.io/posts/epipolar-geometry/</guid><description>對於一個場景, 透過兩個位置不同的相機觀看 這兩幅圖像之間會有一些點對應關係 整張圖所形成的幾何關係稱為 Epipolar Gemometry 如下圖: 兩個相機中心分別為 {%math%} O_{1},\ O_{2} {%endmath%} 三維世界座標點 {%math%} P {%endmath%} 在兩個像平面 {%math%} A_{1},\ A_{2} {%endmath%} 投影的點為 {%math%} p_{1},\ p_{2} {%endmath%} 而 {%math%} P,\ O_{1}\ O_{2} {%endmath%} 三點所形成的平面稱為極平面(Epipolar plane) {%math%} O_{1}O_{2} {%endmath%}稱為基線(Baseline), 穿越兩個像平面的點分別為 {%math%} e_{1},\ e_{2} {%endmath%} 稱為極點(Epipoles) 投影點與極點連成的線稱為極線(Epipolar Line): {%math%} l_{1},\ l_{2} {%endmath%}
我們可以透過兩幀圖像之間的特徵點對應, 進而求出相機的運動
推導 設點三維做標點 {%math%} P=[X,Y,Z]^{T} {%endmath%} 對於兩個投影點 {%math%} s_{1}p_{1}=KP\s_{2}p_{2}=K(RP+t) {%endmath%} K 是內參矩陣 若是用齊次座標, 可以將 s 去除, 因為常數項不影響 接著我們覺得 K 有點麻煩, 所以我們用歸一化座標 {%math%} x_{1}=K^{-1}p_{1},\ x_{2}=K^{-1}p_{2} {%endmath%} 看公式可以知道這東西其實就是 P 而我們不想透過 K 來得到投影點座標 反而是直接假設有一個距離相機 z = 1 的平面 投影在上面的座標為: {%math%} P=\begin{bmatrix} \frac{X}{Z}\ \frac{Y}{Z}\ 1 \end{bmatrix} {%endmath%} 來得到二維座標 我們可以得到這樣的關係: {%math%} x_{2}=Rx_{1} + t {%endmath%} 接下來就是數學的一些變換: 兩邊同時乘上 {%math%} \hat{t} {%endmath%}, 相當於與 t 做外積 {%math%} \hat{t}x_{2}=\hat{t}Rx_{1} {%endmath%} 上面的 t 因為和自己做外積, 所以消失了 接著左乘 {%math%} x_{2}^{T} {%endmath%} 因為 {%math%} \hat{t}x_{2} {%endmath%} 是一個和 {%math%} t,\ x_{2} {%endmath%} 垂直的向量 再和{%math%} x_{2} {%endmath%} 做內積就會是 0 得到以下式子: {%math%} x_{2}^{T}\hat{t}Rx_{1} = 0 {%endmath%} 此式就稱為 對極約束(Epipolar Constraint) 代入 {%math%} p_{1}, p_{2} {%endmath%} {%math%} p_{2}^{T}K^{-T}\hat{t}RK^{-1}p_{1} = 0 {%endmath%} 幾何意義是 {%math%} P,\ O_{1},\ O_{2} {%endmath%} 共平面 將 {%math%} \hat{t}R {%endmath%} 令成 E, 這東西就稱為本質矩陣(Essential Matrix) 若是有包含內參, 就是基本矩陣(Fundamental Matrix) {%math%} E=\hat{t}R,\ F=K^{-T}EK^{-1} {%endmath%} 進一步簡化約束式: {%math%} x_{2}^{T}Ex_{1}=p_{2}^{T}Fp_{1}=0 {%endmath%}</description></item><item><title>相機校正 - 張正友法</title><link>https://ptzu.github.io/posts/zhang-method/</link><pubDate>Sun, 16 Sep 2018 21:17:55 +0000</pubDate><guid>https://ptzu.github.io/posts/zhang-method/</guid><description>為什麼需要校正 待補
計算單應性矩陣 H 先前在相機模型中, 設三維世界點 {%math%}X = [X, Y, Z, 1]^{T}{%endmath%}, 二維相機像素座標 {%math%}m=[u, v, 1]^{T}{%endmath%} 我們知道這樣的轉換關係: {%math%}sm = K[R, T]X{%endmath%} 其中 s 是尺度因子, K 是內參 {%math%}K = \begin{bmatrix} f_{0} &amp;amp; \gamma &amp;amp; u\ 0 &amp;amp; f_{1}&amp;amp; v\ 0 &amp;amp; 0&amp;amp; 1 \end{bmatrix}{%endmath%} 在棋盤格上我們可以當成是 Z = 0 的平面: {%math%}s\begin{bmatrix} u\ v\ 1 \end{bmatrix} = K \begin{bmatrix} r_{1} &amp;amp; r_{2} &amp;amp; r_{3} &amp;amp; t \end{bmatrix} \begin{bmatrix} X\ Y\ 0\ 1 \end{bmatrix} = K \begin{bmatrix} r_{1} &amp;amp; r_{2} &amp;amp; t \end{bmatrix} \begin{bmatrix} X\ Y\ 1 \end{bmatrix}{%endmath%} 將 {%math%} K[r1, r2, t] {%endmath%} 稱為 單應性矩陣(Homography matrix) H 如此可以用 H 來約束內參和外參 而 H 可以透過棋盤和成像平面上的點對應計算出來(尚待學習) {%math%}s\begin{bmatrix} u\ v\ 1 \end{bmatrix} = H\begin{bmatrix} X\ Y\ 1 \end{bmatrix}{%endmath%} {%math%}H = [h_{1}\ h_{2}\ h_{3}] =\lambda K[r_{1}\ r_{2}\ t]{%endmath%}</description></item><item><title>李代數 SO(3), SE(3) 微分推導</title><link>https://ptzu.github.io/posts/lie-algebra-differential/</link><pubDate>Sat, 15 Sep 2018 22:03:57 +0000</pubDate><guid>https://ptzu.github.io/posts/lie-algebra-differential/</guid><description>SO(3) 當我們考慮到無限小的運動時 就會需要到微分 對於旋轉矩陣 R(t) 我們知道: {%math%}R(t)R^{T}(t) = I{%endmath%} 事實上旋轉矩陣的反矩陣, 即為他的轉置矩陣 接著我們對這個式子兩邊做微分: {%math%}\frac{d}{dt}(RR^{T}) = \dot{R}R^{T} + R\dot{R^{T}} = 0{%endmath%} 移項後得到: {%math%}\dot{R}R^{T} = -(\dot{R}R^{T})^{T}{%endmath%} 此時可以發現到 {%math%} \dot{R}R^{T} {%endmath%} 就是斜對稱矩陣！ 令 {%math%} \hat{w}(t) = -(\dot{R}R^{T})^{T} {%endmath%} 右乘 {%math%} R(t) {%endmath%} 得到: {%math%}\dot{R}(t) = \hat(w)R(t){%endmath%} 如此就得到 R 微分的關係式
SE(3) 接著考慮到剛體運動 對於 {%math%}g = \begin{bmatrix} R &amp;amp; T\ 0 &amp;amp; 1 \end{bmatrix}{%endmath%} 這邊我想了一整天, 才發現很根本的錯誤 原本我想照著 SO(3) 一樣乘上轉置矩陣去求 可是怎麼算都不對 原因就是 SE(3) 的轉置不是他的反矩陣啊啊啊！ 所以回到原本 我們從 {%math%}\dot{g}g^{-1}{%endmath%} 考慮 等等右乘上 g 就可以得出 g 微分的關係式 可以得到: {%math%}\dot{g}g^{-1}=\begin{bmatrix} \dot{R} &amp;amp; \dot{T}\ 0 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} R^{T} &amp;amp; -R^{T}T\ 0 &amp;amp; 1 \end{bmatrix} =\begin{bmatrix} \dot{R}R^{T} &amp;amp; \dot{T}-\dot{R}R^{T}T\ 0 &amp;amp; 0 \end{bmatrix}{%endmath%}</description></item><item><title>相機座標系、世界座標系</title><link>https://ptzu.github.io/posts/camera-frame-world-frame/</link><pubDate>Wed, 08 Aug 2018 23:15:18 +0000</pubDate><guid>https://ptzu.github.io/posts/camera-frame-world-frame/</guid><description>最近在讀 SLAM 相關 paper 時 常看到 camera/world frame 我原本想說是和 keyframe 類似的東西 結果是完全不同的東西呀～ 這邊指的是座標系(雖然我還是不知道為什麼要用frame)
順手整理一下相機的相關座標轉換 相機模型中主要有四個平面座標系:
畫素平面座標系（u,v): 圖像在像素中的位置 像平面座標系 (影像物理座標（x,y)): 以相機主點為原點，場景點在圖像平面上的投影座標。 相機座標系（Xc,Yc,Zc): 以相機為中心的三維座標。 世界座標系（Xw,Yw,Zw): 絕對座標系統中的三維座標。 當我們能將這四個座標軸作轉換, 那麼就能從二維影像得知在三維世界中的位置
畫素平面 &amp;lt;=&amp;gt; 像平面 因為畫素不能反映圖像真實尺寸 像平面可以想成是一張二維影像 只是被縮小成像素大小(物理層面) 畫素單位是 pixel(微米大小), 而像平面單位是 mm
假設畫素座標為 {%math%}(u, v, 1)^{T}{%endmath%} (這邊用的是齊次座標, 當成是(u, v)就好了) 像平面座標 {%math%}(x, y){%endmath%} 每個像素的真實尺寸為 dx * dy
我們以圖像中心當作像平面座標的原點 {%math%}(u_{0}, v_{0}){%endmath%} 所以: {%math%}\left{\begin{matrix} u=\frac{x}{dx}+u_{0}\ v=\frac{y}{dy}+v_{0} \end{matrix}\right.{%endmath%} {%math%}\left{\begin{matrix} x=udx-u_{0}dx\ y=udy-u_{0}dy \end{matrix}\right.{%endmath%}
若以矩陣來表示: {%math%}\begin{bmatrix} u\ v\ 1 \end{bmatrix} \begin{bmatrix} \frac{1}{dx} &amp;amp; 0 &amp;amp; u_{0}\ 0&amp;amp; \frac{1}{dy} &amp;amp; v_{0}\ 0&amp;amp; 0 &amp;amp; 1 \end{bmatrix}\begin{bmatrix} x\ y\ 1 \end{bmatrix}{%endmath%}</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Graph on Ptzu's blog</title><link>https://ptzu.github.io/categories/graph/</link><description>Recent content in Graph on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 Mar 2018 12:02:50 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/categories/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>2-SAT</title><link>https://ptzu.github.io/posts/template-twosat/</link><pubDate>Thu, 08 Mar 2018 12:02:50 +0000</pubDate><guid>https://ptzu.github.io/posts/template-twosat/</guid><description>當有{%math%}(a\vee b){%endmath%}這種型式的時候 可以轉成{%math%}(\neg a\Rightarrow b\wedge \neg b\Rightarrow a){%endmath%} 箭頭左邊建一條邊到右邊
addClause 的 flag 是代表該變數要不要取 not
只要{%math%}x, \neg x{%endmath%}不在同一個 SCC 內, 命題為真
邏輯定律 肯定前件律(MP): {%math%}p\supset q,\ p/\ q{%endmath%} 否定後件律(MT): {%math%}p\supset q,\ \neg q/\ \neg p{%endmath%} 連言律(Conj): {%math%}p,\ q/\ p\wedge q{%endmath%} 簡化律(Simp): {%math%}p\wedge q/\ p{%endmath%} 選言三段論(DS): {%math%}p\vee q,\ \neg p/\ q{%endmath%} 假言三段論(HS): {%math%}p\supset q,\ q\supset r/\ p\supset r{%endmath%} 添加律(Add): {%math%}p/\ p\vee q{%endmath%} 建構兩難律(CD): {%math%}p\supset q,\ r\supset s,\ p\vee r/\ q\vee s{%endmath%} 雙重否定律(DN): {%math%}p\equiv \neg \neg p{%endmath%} 笛摩根定律(DeM): {%math%}\neg (p\wedge q)\equiv \neg p \vee \neg q{%endmath%} 交換律(Comm): {%math%}p\vee q\equiv q\vee p{%endmath%} 結合律(Assoc): {%math%}p\vee (q\vee r) \equiv (p\vee q)\vee r{%endmath%} 分配律(Dist): {%math%}p\wedge (q\vee r)\equiv (p\wedge q)\vee (p\wedge r){%endmath%} {%math%}p\vee (q\wedge r)\equiv (p\vee q)\wedge (p\vee r){%endmath%} 換值換位律(Contra): {%math%}p\supset q\equiv \neg q\supset \neg p{%endmath%} 蘊涵律(Impl): {%math%}p\supset q\equiv \neg p\vee q{%endmath%} 等值律(Equiv): {%math%}(p\equiv q)\equiv (p\supset q)\wedge (q\supset p)\equiv (p\wedge q)\vee (\neg p\wedge \neg q){%endmath%} 移出律(Exp): {%math%}(p\wedge q)\supset r\equiv p\supset (q\supset r){%endmath%} 恆真律(Taut): {%math%}p\supset q\equiv \neg p\vee q{%endmath%} 其中 {%math%}\supset {%endmath%} 是條件符號</description></item><item><title>雙連通單元 BCC</title><link>https://ptzu.github.io/posts/template-bcc/</link><pubDate>Sun, 04 Mar 2018 19:30:28 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bcc/</guid><description>在一個無向圖中 若任兩點, 存在&amp;quot;兩條點不重複路徑&amp;quot;, 則稱此圖為 點-雙連通 而點-雙連通內部沒有割點 若任兩點, 存在&amp;quot;兩條邊不重複路徑&amp;quot;, 則稱此圖為 邊-雙連通
點-雙連通的最大子圖稱為雙連通單元(分量)
點-雙連通單元 性質:
條件: low[v] &amp;gt;= dfn 割點可以屬於多個連通單元 任兩個連通單元的共同點最多一個, 也就是割點 連通單元內不會有割點 可順便求割點 這在網路上有兩種寫法 一種是在 stack 存點, 另一種存邊 由於割點可以屬於多個單元, 所以在 pop 時, 不能將割點 pop 出去 而這份 code, 不會將割點 pop 出去, 但有個副作用是 root 會留在 stack 多筆測資使用要小心
存邊的寫法有空再來理解
存點 Code // 割點的 bccid 沒有意義 const int MAX_V = ...; int V, E; vector &amp;lt;int&amp;gt; g[MAX_V], bcc[MAX_V]; int dfn[MAX_V], low[MAX_V], tot, bccid[MAX_V], bcc_cnt; bool cut[MAX_V]; stack &amp;lt;int&amp;gt; S; void dfs(int x, int fa){ int child = 0; dfn[x] = low[x] = ++tot; S.</description></item><item><title>關節點、橋</title><link>https://ptzu.github.io/posts/template-articulation-point/</link><pubDate>Fri, 02 Mar 2018 12:59:19 +0000</pubDate><guid>https://ptzu.github.io/posts/template-articulation-point/</guid><description>關節點 關節點必須符合兩個性質其中一個：
假設目前點為 x, 子孫為 v, low[v] &amp;gt;= dfn 若該點是 root(起始點), 則他的小孩數量 &amp;gt; 1 先來看第一個性質, 當 low[v] 都大於等於當前的編號 就代表所有子孫不會連到當前點的祖先 也就是當前點斷掉的話, 就會分成兩塊
接下來看為何為特別將 root 設個條件(搭配下面的測資) root 的子孫 low 值一定都比 dfn[root] 大 那拿掉 root 一定可以斷開嘛？ 答案是否, 當圖案為一直線 拿掉起點不會產生新的 SCC 只有當 root_child &amp;gt; 1 時才會
相關測資 #root Input: 5 1 2 2 3 3 4 4 5 0 0 Output: 3 # dfn and low Input: 5 1 3 2 2 4 5 3 4 5 0 5 1 2 3 2 3 4 5 4 5 0 Output: 1 1 Code // 割點的 bccid 沒有意義 const int MAX_V = .</description></item><item><title>強連通單元 SCC</title><link>https://ptzu.github.io/posts/template-scc/</link><pubDate>Tue, 27 Feb 2018 23:58:21 +0000</pubDate><guid>https://ptzu.github.io/posts/template-scc/</guid><description>強連通單元為一集合, 集合內任取兩點, 都可以互相連通 任何有向圖都能分解成幾個 SCC 將 SCC 縮成一個點就會變成 DAG 求 SCC 數量方法有兩種
Tarjan 跑兩次 DFS Tarjan dfn[i]: DFS的順序(時間編號) low[i]: 能到達 i 的最小的時間編號 i 能達到的最小時間編號
在理解的時候有幾個問題
stack 的作用？ 用來存放已經走過, 但還沒變成 SCC 的點 in_stack 陣列存在的必要性？ 在看網路很多模版的時候, 他們是取作 vis 陣列的 而我想說既然有 dfn 陣列, 那還沒有時間戳的點肯定是沒走過的 為何需要 vis 陣列？ 首先走過的點可分為兩種 一種是在 stack 裏面, 另一種是不在了 當一個點不在 stack 內, 代表已經成為一個 SCC 若我們拿別的 SCC 來更新自己 low 值肯定出錯 因為已成為 SCC 的點不可能再走到當前點了 所以我認為取做 in_stack 更加恰當, 只有在 stack 的點可以更新當前 low 值 要用 dfn 還是 low 更新？ 第 19 行網路上幾乎都是用 dfn 更新 但我想想, 在 stack 的點若可走到當前點 那個點的 low 值也一定可以走到當前點 所以用 low 值更新應該沒錯吧(?</description></item><item><title>Floyd Warshall</title><link>https://ptzu.github.io/posts/template-floyd-warshall/</link><pubDate>Mon, 05 Feb 2018 12:55:12 +0000</pubDate><guid>https://ptzu.github.io/posts/template-floyd-warshall/</guid><description>全點對最短路徑 時間複雜度: {%math%}O(n^{3}){%endmath%}
Code void floyd(int V){ for(int k = 0; k &amp;lt; V; k++){ for(int i = 0; i &amp;lt; V; i++){ for(int j = 0; j &amp;lt; V; j++){ d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } }</description></item><item><title>Kruskal Algorithm</title><link>https://ptzu.github.io/posts/template-kruskal/</link><pubDate>Fri, 12 Jan 2018 13:23:37 +0000</pubDate><guid>https://ptzu.github.io/posts/template-kruskal/</guid><description>時間瓶頸在排序 複雜度： O(ElogV)
Code struct Union_Find { int par[1010], num[1010]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U; struct edge{ int u, v, w; bool operator &amp;lt;(const edge&amp;amp; e) const{ return w &amp;lt; e.</description></item><item><title>Sollin Algorithm</title><link>https://ptzu.github.io/posts/template-sollin/</link><pubDate>Fri, 12 Jan 2018 12:59:18 +0000</pubDate><guid>https://ptzu.github.io/posts/template-sollin/</guid><description>求 MST, 不過速度有點慢
Code truct edge{ int u, v, w; }; struct Union_Find { int par[1010], num[1010]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U; edge edges[100000]; int V, E; int mn[1000]; int ComponentSize; // 一開始等於V int sollin(){ int ans = 0; while(ComponentSize &amp;gt; 1){ for(int i = 0; i &amp;lt; V; i++) mn[i] = INT_MAX; // 找出每個 Component 的最小邊是誰 for(int i = 0; i &amp;lt; E; i++){ edge e = edges[i]; int a = U.</description></item><item><title>Bipartite Matching</title><link>https://ptzu.github.io/posts/template-bipartite-matching/</link><pubDate>Sat, 06 Jan 2018 16:19:43 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bipartite-matching/</guid><description>匈牙利演算法(Hungarian Algorithm) 時間複雜度: O({%math%}n^{3}{%endmath%})
Code const int MAX_V = 1010; int V; vector &amp;lt;int&amp;gt; g[MAX_V]; int match[MAX_V]; bool vis[MAX_V]; void add_edge(int u, int v){ g[u].pb(v); g[v].pb(u); } bool dfs(int u){ vis[u] = true; for(int i = 0; i &amp;lt; sz(g[u]); i++){ int v = g[u][i], w = match[v]; if(w &amp;lt; 0 || (!vis[w] &amp;amp;&amp;amp; dfs(w))){ match[u] = v; match[v] = u; return true; } } return false; } int bipartite_matching(){ int res = 0; memset(match, -1, sizeof(match)); for(int i = 0; i &amp;lt; V; i++){ if(match[i] &amp;lt; 0){ memset(vis, 0, sizeof(vis)); if(dfs(i)) res++; } } return res; }</description></item><item><title>Max Flow</title><link>https://ptzu.github.io/posts/template-dinic/</link><pubDate>Thu, 04 Jan 2018 19:13:59 +0000</pubDate><guid>https://ptzu.github.io/posts/template-dinic/</guid><description>Dinic 演算法 時間複雜度: O({%math%}EV^{2}{%endmath%})
Code struct edge{ int to, cap, rev; }; vector &amp;lt;edge&amp;gt; g[MAX_V]; int iter[MAX_V]; int level[MAX_V]; void add_edge(int u, int v, int w){ g[u].pb((edge){v, w, sz(g[v])}); g[v].pb((edge){u, 0, sz(g[u]) - 1}); } void bfs(int S){ memset(level, -1, sizeof(level)); queue &amp;lt;int&amp;gt; q; level[S] = 0; q.push(S); while(!q.empty()){ int v = q.front(); q.pop(); for(int i = 0; i &amp;lt; sz(g[v]); i++){ edge&amp;amp; e = g[v][i]; if(e.cap &amp;gt; 0 &amp;amp;&amp;amp; level[e.</description></item><item><title>Prim Algorithm</title><link>https://ptzu.github.io/posts/template-prim/</link><pubDate>Fri, 22 Dec 2017 14:07:32 +0000</pubDate><guid>https://ptzu.github.io/posts/template-prim/</guid><description>基本上和 Dijkstra 一樣 只是 d[ ] 從到原點的距離改成到樹的距離
Code struct Edge{ int to, w; }; vector &amp;lt;Edge&amp;gt; g[MAX_V]; int d[MAX_V]; bool inTree[MAX_V]; int V, E; int prim(int S){ priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt;pq; fill(d, d + V, INF); memset(inTree, 0, sizeof(inTree)); d[S] = 0; pq.push((pii){0, S}); int res = 0, cnt = 0;; while(!pq.empty()){ pii top = pq.top(); pq.pop(); int u = top.nd; if(inTree[u] || d[u] &amp;lt; top.st) continue; inTree[u] = true; // 加到樹裡面 res += d[u]; cnt++; // 看是否有每個點都被連上 for(int i = 0; i &amp;lt; sz(g[u]); i++){ Edge e = g[u][i]; // 更新距離 if(e.</description></item><item><title>SPFA</title><link>https://ptzu.github.io/posts/template-spfa/</link><pubDate>Fri, 22 Dec 2017 14:07:27 +0000</pubDate><guid>https://ptzu.github.io/posts/template-spfa/</guid><description>可偵測負環 和 Dijkstra 差不多, 多用了 cnt 陣列去紀錄每個點被更新幾次 如果有個點被更新超過 V 次, 代表有負環
Code struct Edge { int to, w; }; const int MAX_V = ...; int V; vector&amp;lt;Edge&amp;gt; g[MAX_V]; int d[MAX_V]; int cnt[MAX_V]; bool SPFA(int S) { // 回傳有無負環 fill(d, d + V, INF); fill(cnt, cnt + V, 0); priority_queue&amp;lt; pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; pq; d[S] = 0; pq.push(pii(0, S)); cnt[S] = 1; while (!pq.empty()) { pii top = pq.top(); pq.</description></item><item><title>Bellman Ford</title><link>https://ptzu.github.io/posts/template-bellman-ford/</link><pubDate>Fri, 22 Dec 2017 14:07:15 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bellman-ford/</guid><description>Code struct Edge{ int from, to, w; }; int V, E; int d[MAX_V]; int cnt[MAX_V]; vector &amp;lt;Edge&amp;gt; edges; set &amp;lt;int&amp;gt; ring; // 紀錄負環 void bellman(int S){ fill(d, d + V, INF); d[S] = 0; // 因為邊的順序不一定, 所以負環不一定每輪都會被更新, 多跑幾次 for(int i = 0; i &amp;lt; V + 10; i++){ for(int j = 0; j &amp;lt; E; j++){ Edge e = edges[j]; if(d[e.from] + e.w &amp;lt; d[e.to]){ d[e.to] = d[e.from] + e.</description></item><item><title>Dijkstra Algorithm</title><link>https://ptzu.github.io/posts/template-dijkstra/</link><pubDate>Sun, 01 Oct 2017 11:16:22 +0000</pubDate><guid>https://ptzu.github.io/posts/template-dijkstra/</guid><description>Code struct edge{ int to, w; }; int d[MAX_N]; vector &amp;lt;edge&amp;gt; g[MAX_N]; int dijkstra(int S){ priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; pq; //d, v fill(d, d + n, INF); d[S] = 0; pq.push((pii){0, S}); while(!pq.empty()){ pii top = pq.top(); pq.pop(); int u = top.nd; if(d[u] &amp;lt; top.st) continue; for(int i = 0; i &amp;lt; sz(g[u]); i++){ edge e = g[u][i]; if(d[u] + e.w &amp;lt; d[e.to]){ d[e.to] = d[u] + e.w; pq.</description></item></channel></rss>
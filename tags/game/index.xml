<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Game on Ptzu's blog</title><link>https://ptzu.github.io/tags/game/</link><description>Recent content in Game on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 24 Mar 2017 22:35:41 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/game/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeforces Round 406</title><link>https://ptzu.github.io/posts/cf406/</link><pubDate>Fri, 24 Mar 2017 22:35:41 +0000</pubDate><guid>https://ptzu.github.io/posts/cf406/</guid><description>目錄 A. The Monster 題目
input 1 ≤ a, b, c, d ≤ 100
題解 b, b + a, b + 2a, &amp;hellip; b 以這樣成長著 d, d + c, d + 2c, &amp;hellip; d 以這樣成長著 求 b 和 d 何時會相同, 輸出第一個相同的數 沒有這樣的數就輸出 -1
作法 我的作法是讓迴圈跑 100 次 想法是這樣 b, d的範圍是 100 假設極端測資, b = 100, d = 1 a = 1, c = 2 差距 99, 每次拉近 1 跑 100 次該重疊的也要重疊了吧？ 不過沒有嚴謹的證明, 只是憑感覺 但似乎大家都是這麼做的</description></item><item><title>Codeforces Round 366 (Div. 2)</title><link>https://ptzu.github.io/posts/cf366/</link><pubDate>Wed, 05 Oct 2016 21:22:50 +0000</pubDate><guid>https://ptzu.github.io/posts/cf366/</guid><description>A. Hulk 題目
題解 簡單字串處理
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int n; string s; int main(){ ios::sync_with_stdio(false); cin.tie(0); cin &amp;gt;&amp;gt; n; for(int i = 1; i &amp;lt;= n; i++){ if(i % 2 == 1){ s += &amp;#34;I hate &amp;#34;; } else if(i % 2 == 0){ s += &amp;#34;I love &amp;#34;; } if(i !</description></item></channel></rss>
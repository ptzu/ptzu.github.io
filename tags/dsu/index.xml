<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dsu on Ptzu's blog</title><link>https://ptzu.github.io/tags/dsu/</link><description>Recent content in dsu on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 09 Aug 2016 23:07:00 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/dsu/index.xml" rel="self" type="application/rss+xml"/><item><title>POJ 1988 Cube Stacking</title><link>https://ptzu.github.io/posts/poj1988/</link><pubDate>Tue, 09 Aug 2016 23:07:00 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1988/</guid><description>題解 現在有 N 個 cube, 每個一開始都是自己一個堆疊 編號為 1 ~ N input 有兩種指令
M a b: 將含有 a 的堆疊放到含有 b 的堆疊上面 C a: 計算在編號 a cube 之下有幾個 cube 作法 算是併查集進階一點的應用 首先定義兩個陣列
num[i]: 以 i 為 root 的集合有幾個 cube under[i]: 在 i 之下有幾個 cube 接著在 unite 中 M 1 2 -&amp;gt; unite(1, 2) 是將 1 加到 2 的集合中 就很當然的 under[a] += num[b] 而 b 集合也會增加數量 num[b] += num[a] 而在 find 中 under+= under[temp] 似乎有點不直覺, 但只要想想一串接很長的集合 這些都是還未經過壓縮的(par不是根) 所以大家的 under 值都是 1 加起來便沒問題了 如果還是不清楚就畫一下圖吧 AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 2236 Wireless Network</title><link>https://ptzu.github.io/posts/poj2236/</link><pubDate>Tue, 09 Aug 2016 21:29:53 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2236/</guid><description>題解 有 N 台壞掉的電腦, 要使他們能重新連通 A 和 B 能連通必須在距離 d 之內, 不過可以透過第三者連接 input 會給每台電腦座標 接著有兩種指令：
O a: 代表修復 a 電腦 S a b: 代表測試 a 和 b 是否連通 作法 用 bool 陣列紀錄哪台電腦已經修復 接著迴圈掃其他電腦, 假如距離 &amp;lt; d 且該電腦已修復 就將他們加到同個集合(併查集, Disjoint Set Union) 當要查詢時就能直接看他們是否在同一個集合啦
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item></channel></rss>
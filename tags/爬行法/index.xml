<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>爬行法 on Ptzu's blog</title><link>https://ptzu.github.io/tags/%E7%88%AC%E8%A1%8C%E6%B3%95/</link><description>Recent content in 爬行法 on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 Sep 2017 11:56:32 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/%E7%88%AC%E8%A1%8C%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>POJ 3061 Subsequence</title><link>https://ptzu.github.io/posts/poj3061/</link><pubDate>Mon, 18 Sep 2017 11:56:32 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3061/</guid><description>題解 給 n 個元素, 求連續子序列和, 滿足大於等於 S 的最小序列長度
作法 先向右不斷爬行直到和大於等於 S 在和滿足條件的情況下, 減少左端長度 並不斷更新最短長度 如此可在 O(n) 時間內求解
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX vector &amp;lt;int&amp;gt; v; int solve(int N, int S){ int mn = INF; int s = 0, t = 0, sum = 0; for(;;){ while(t &amp;lt; N &amp;amp;&amp;amp; sum &amp;lt; S){ sum += v[t++]; } if(sum &amp;lt; S) break; mn = min(mn, t - s); sum -= v[s++]; } if(mn &amp;gt; N) mn = 0; return mn; } int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ v.</description></item></channel></rss>
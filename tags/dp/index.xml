<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DP on Ptzu's blog</title><link>https://ptzu.github.io/tags/dp/</link><description>Recent content in DP on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 10 Mar 2018 20:59:25 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>HDU 1466 计算直线的交点数</title><link>https://ptzu.github.io/posts/hdu1466/</link><pubDate>Sat, 10 Mar 2018 20:59:25 +0000</pubDate><guid>https://ptzu.github.io/posts/hdu1466/</guid><description>題目
input 输入数据包含多个测试实例,每个测试实例占一行,每行包含一个正整数n（n&amp;lt;=20）,n表示直线的数量.
題解 平面上有n条直线，且无三线共点，问这些直线能有多少种不同交点数。 比如,如果n=2,则可能的交点数量为0(平行)或者1(不平行)。
作法 自己畫了幾個例子, 只覺得好亂 那麼多種直線, 找不到轉移式&amp;hellip;
只好上網找題解 首先將線分為兩種, 自由線以及平行線 所謂自由線就是那條線可以是任何方向, 只要不和平行線平行就好 平行線是彼此間互相平行的線, 定義180度水平的為平行線好了 接著我們試著畫看看 假設有 5 條自由線, 方向任意(甚至他們之間平行也沒差, 只要不和平行線平行就好) 然後我們加上一條水平線, 發現增加 5 個交點 再加上一條, 也是增加 5 個交點 於是假設現在有 i 條自由線, 加上 j 條平行線 增加的點為 i * j 個點
最後我們定義 dp[i][j]: 總共有 i 條線, j 個交點這種狀況是否成立 列舉不同數量的自由線和交點數量 若該狀態成立 dp[all][k + 平行線數 * 自由線數] 也會成立
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 10285 - Longest Run on a Snowboard</title><link>https://ptzu.github.io/posts/uva10285/</link><pubDate>Thu, 08 Mar 2018 21:37:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10285/</guid><description>題目
input 第一列輸入 T, 代表 T cases 每筆測資輸入 name, row, col 接著輸入每個點的高度
題解 現在要滑雪, 從平地到目前高度的步數是 1 接下來只能選比目前低的&amp;quot;周圍點&amp;quot;滑下去 每滑一個點算一步, 求最長路徑
作法 非常水的一題&amp;hellip; 每個點 dfs 一次就好了 dp 陣列只是紀錄跑過的不要跑, 加快而已
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 10010; int a[200][200]; int dp[200][200]; pii dir[] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int r, c; int ans; void solve(pii s, int len){ dp[s.</description></item><item><title>Uva 11069 - A Graph Problem</title><link>https://ptzu.github.io/posts/uva11069/</link><pubDate>Sun, 25 Feb 2018 00:46:36 +0000</pubDate><guid>https://ptzu.github.io/posts/uva11069/</guid><description>題目
input 多筆測資, 輸入 n (1 ≤ n ≤ 76)
題解 你的任務是：給你 n ，請算出這個圖形有以下性質的節點子集合共有多少個
集合裡不能有兩個相鄰的點。例如圖形中有 n = 3 個節點，則集合 {1,2} 是違法的，而集合 {1,3} 是合法的 當這個集合能再加入任一節點，卻可以不和其它節點相鄰，則這個集合是違法的。例如圖形中有 n = 5個節點，則集合 {1,5} 是違法的，因為這個集合再加入節點 3 仍不和其它節點相鄰，而集合 {1,3,5} 則是合法的 所以，當圖形有 n = 5 個節點時，應該有 4 個合法的集合：{1,3,5},{2,4},{2,5},{1,4}.
作法 對於 n = i 來說 i - 2 的所有組合必定可以加入 i 而 i - 1 必定不可加, 所以保留原樣轉移到 i 然而 i - 1 有些組合是從 i - 2 轉移過去 所以這樣會重複 因此分開紀錄 定義 dp[i][0] = dp[i - 2][0] + dp[i - 2][1] 從 i - 2 轉移過來的, 必定可以加 i dp[i][1] = dp[i - 1][0] 從 i - 1 轉移過來, 不能包含從 i - 2 過來的</description></item><item><title>POJ 2385 Apple Catching</title><link>https://ptzu.github.io/posts/poj2385/</link><pubDate>Wed, 14 Feb 2018 18:14:44 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2385/</guid><description>題目
input 第一列輸入 T, W (1 &amp;lt;= T &amp;lt;= 1,000), (1 &amp;lt;= W &amp;lt;= 30) 代表 T 分鐘和最多移動 W 次
題解 約翰農夫有兩棵蘋果樹, 每分鐘只會有一棵樹結出蘋果 Bessie 可以在兩棵樹間移動, 最多移動 W 次 初始位置在樹 1, 請問他最多能接到幾顆蘋果？
作法 第二次寫這題了, 雖然是簡單題 終於自己想出遞迴式, 超爽derrr 本來想放棄去看之前的 code QQ
首先定義 dp[i][j][k]: 在第 i 分鐘, 走了 j 步, 目前在第 k 樹最多能接到幾顆蘋果 考慮兩種情況
目前站在會結蘋果的樹下, 那有兩種選擇, 原本就站在 k 樹下所以不動 或者從 k ^ 1 樹走過來(k ^ 1, 0 變 1, 1 變 0) 這兩種情況挑大的, 然後 +1 目前站在沒有蘋果的樹下, 和上面一樣兩種選擇, 但是沒有蘋果, 所以不 +1 AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 2229 Sumsets</title><link>https://ptzu.github.io/posts/poj2229/</link><pubDate>Wed, 14 Feb 2018 10:24:02 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2229/</guid><description>題目
input 輸入 N (1 &amp;lt;= N &amp;lt;= 1,000,000)
題解 若只用 2 的次方數 求組出 N 有幾種方法
作法 定義 dp[i]: 組出 i 的方法數 將奇偶數分開考慮 首先奇數為前一個數 +1, 而 +1 不可能產生新的二次方數, 所以方法數和 i - 1 一樣
dp[i] = dp[i - 1] 偶數同樣可以從 i - 1 推過來 但是為偶數, 代表 +1 一定加到偶數個, 所以會產生新的二次方數 考慮 i / 2 這個數, 當他 +1 加到 i, 代表整個翻倍
dp[i] = dp[i - 1] + dp[i / 2] AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 3176 Cow Bowling</title><link>https://ptzu.github.io/posts/poj3176/</link><pubDate>Tue, 13 Feb 2018 23:10:22 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3176/</guid><description>題目
input 第一列輸入 N (1 &amp;lt;= N &amp;lt;= 350) 代表 N 列的三角形 接著輸入三角形
題解 牛牛們玩保齡球, 得分為從三角形頂部到底部, 所經過的點值總和 求最大得分為多少
作法 定義 dp[i][j] 為第 i 列第 j 行的得分總和 遞迴式即為是上層的兩個(或一個)選大的走下來 dp[i][j] += max(dp[i - 1][j - 1], dp[i - 1][j]) 最後求底層最大值即可
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 427</title><link>https://ptzu.github.io/posts/cf427/</link><pubDate>Tue, 13 Feb 2018 17:48:53 +0000</pubDate><guid>https://ptzu.github.io/posts/cf427/</guid><description>目錄 實作 Greedy 換數字 棋盤式 DP A. Key races 題目
input 輸入 s, v1, v2, t1, t2 (1 ≤ s, v1, v2, t1, t2 ≤ 1000) 分別代表字串長度, 打字速度, 延遲
題解 兩人比賽打字, 指定字串長度 s 比賽延遲 t 秒後才開始, 以每字 v 秒的速度打字, 打完後延遲 t 秒收到成功訊息 若第一人比較快, 輸出 &amp;ldquo;First&amp;rdquo; 反之輸出 &amp;ldquo;Second&amp;rdquo; 平手輸出 &amp;ldquo;Friendship&amp;rdquo;
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Codecraft-18 and Codeforces Round 458</title><link>https://ptzu.github.io/posts/cf458/</link><pubDate>Tue, 13 Feb 2018 11:39:59 +0000</pubDate><guid>https://ptzu.github.io/posts/cf458/</guid><description>題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int mod = 1e9 + 7; string s; int k; int dp[1010]; int C[1010][1010]; int main(){ fio; cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; k; if(k == 0){ puts(&amp;#34;1&amp;#34;); return 0; } dp[1] = 0; for(int i = 2; i &amp;lt;= 1000; i++) dp[i] = dp[__builtin_popcount(i)] + 1; C[0][0] = 1; for(int i = 1; i &amp;lt;= 1000; i++){ C[i][0] = 1; for(int j = 1; j &amp;lt;= 1000; j++){ C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; } } int one_num = 0, len = s.</description></item><item><title>NYOJ 16 矩形嵌套</title><link>https://ptzu.github.io/posts/nyoj16/</link><pubDate>Mon, 12 Feb 2018 01:33:06 +0000</pubDate><guid>https://ptzu.github.io/posts/nyoj16/</guid><description>題目
input 第一行是一个正正数N(0&amp;lt;N&amp;lt;10)，表示测试数据组数， 每组测试数据的第一行是一个正正数n，表示该组测试数据中含有矩形的个数(n&amp;lt;=1000) 随后的n行，每行有两个数a,b(0&amp;lt;a,b&amp;lt;100)，表示矩形的长和宽
題解 描述 有n个矩形，每个矩形可以用a,b来描述，表示长和宽。矩形X(a,b)可以嵌套在矩形Y(c,d)中当且仅当a&amp;lt;c,b&amp;lt;d或者b&amp;lt;c,a&amp;lt;d（相当于旋转X90度）。例如（1,5）可以嵌套在（6,2）内，但不能嵌套在（3,4）中。你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。
输出 每组测试数据都输出一个数，表示最多符合条件的矩形数目，每组输出占一行
作法 DAG 上 DP, 求最長路徑 若矩型 a, 可嵌套在矩型 b, 則 a 連一條邊到 b 形成一 DAG
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 16; pii p[1010]; int dp[1010]; vector &amp;lt;int&amp;gt; g[1010]; bool ok(pii a, pii b){ if((a.</description></item><item><title>HDU 4281 - Judges' response (2012天津網路賽)</title><link>https://ptzu.github.io/posts/hdu4281/</link><pubDate>Sun, 11 Feb 2018 20:13:14 +0000</pubDate><guid>https://ptzu.github.io/posts/hdu4281/</guid><description>題目
input 多筆測資, 每筆測資輸入 N, M, 2 &amp;lt;= N &amp;lt;= 16, 0 &amp;lt;= M &amp;lt;= 100000 代表 N - 1 位參賽者舉手發問, 裁判的耐心 M 接著輸入 N 個座標, 第一個座標為所有裁判的位置, 其餘為參賽者位置 再輸入 N 個解答問題所需要的時間, 同樣第一個為裁判
題解 現有一場比賽, 有 N - 1 位參賽者同時舉手發問 我們知道解答某參賽者的問題, 需要耗費的時間 但是每位裁判有固定 M 的耐心, 也就是他最多只願意花 M 分鐘解答 因此需要多位裁判去替選手解答 現有兩個問題:(第一次遇到一次問兩題的XD)
至少需要多少位裁判才能解答所有問題？ 假如裁判數量充足, 求一條路線使得所有裁判行走的時間總和最短 距離採歐基里得距離取 ceil, 且每位裁判的行走速度為 1 注意所有裁判的起始位置都一樣 作法 第一題可視為 n 個物品, 至少需要幾個箱子才能裝完(位元DP, 01背包(?)) 第二題是 MTSP, 上面那題我們已經將一個集合視為一個箱子, 也就是一位裁判負責的狀況 接著稍微解說一下作法:</description></item><item><title>POJ 2084 Game of Connections</title><link>https://ptzu.github.io/posts/poj2084/</link><pubDate>Sat, 10 Feb 2018 14:41:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2084/</guid><description>題目
input 多筆測資, 每筆輸入 n, 1 &amp;lt;= n &amp;lt;= 100 輸入 -1 結束測資
題解 有 2 * n 個點順時針排序, 任兩點連線, 但線不准交叉 求有幾種連法
作法 卡塔蘭數 固定點 1, 向周圍的點畫線 可以把圖分成左右兩塊, 左右兩塊的點數都是偶數(因為奇數必不能兩兩互連) 我們可以得到以下結論 h(0) = 1,h(1) = 1 遞迴式：
h(n) = h(0)*h(n-1) + h(1)*h(n-2) + &amp;hellip; + h(n-1)h(0) (其中 n &amp;gt;= 2) 即為卡塔蘭數
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 10007 - Count the Trees</title><link>https://ptzu.github.io/posts/uva10007/</link><pubDate>Fri, 09 Feb 2018 22:17:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10007/</guid><description>題目
input 多筆測資, 每筆測資輸入 n, 1 &amp;lt;= n &amp;lt;= 300 代表 n 個結點 輸入 0 測資結束
題解 給 n 個點求有幾種不同結構的二元樹 因為不同數字也算不同, 所以再乘上 n!
作法 卡塔蘭數 + 大數
AC code import java.util.Scanner; import java.math.BigInteger; import java.util.*; public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); BigInteger[] fac = new BigInteger[601]; fac[0] = fac[1] = BigInteger.ONE; for(int i = 2; i &amp;lt;= 600; i++) fac[i] = fac[i - 1].</description></item><item><title>POJ 2677 Tour</title><link>https://ptzu.github.io/posts/poj2677/</link><pubDate>Thu, 08 Feb 2018 17:00:43 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2677/</guid><description>題目
input 含多筆測資, 每筆測資開頭輸入 n, 代表 n 個點 接著輸入 n 個點的 x, y 座標 x 座標為遞增
題解 從最左邊的點, 嚴格遞增走到右邊 然後再從最右邊嚴格遞減走回起點, 求這路程的最小距離
作法 Bitonic TSP 這題要注意, double 要用 %f 輸出而不是 %lf 才能過 猜測是精度的問題, 不影響題意理解
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;cmath&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 100; struct point{ double x, y; }; int n; point p[MAX_N]; double dis[MAX_N][MAX_N]; double dp[MAX_N][MAX_N]; double get_dis(point a, point b){ return sqrt((a.</description></item><item><title>ZJ b177 [TIOJ 1471] 山景 Skyline</title><link>https://ptzu.github.io/posts/zj-b177/</link><pubDate>Wed, 07 Feb 2018 14:38:51 +0000</pubDate><guid>https://ptzu.github.io/posts/zj-b177/</guid><description>題目
input 輸入 n, n必為偶數, n &amp;lt;= 3000
題解 一座山的山稜線由許多片段的45度斜坡構成，每一個片段不是上坡就是下坡。
/\ /\/ \ / \ 在我們眼前的所見的任何寬度為n個單位的山稜形狀，可以輕鬆地觀察到所有山頂的位置。
請問有多少種山稜線的形狀，使得所有山頂的位置由左而右非遞減呢？
所有的山稜線都必須完整，也就是說左右兩端都必須是高度為0的山腳，而且不能有任何山谷的位置隱沒在地平線底下。
這題在 2017中程盃 有出現類似題 這題的要求是山頂必須非遞減, 而中程盃那題是問 r 個高度為 k 的山頂有幾種畫法
作法 一開始想法是定義 dp[i][j] 為走 i 步高度為 j 有幾種畫法 而遞迴式是 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1] 不過這樣沒辦法保證山頂非遞減 後來參考 morris 的答案 想了整天, 最後畫圖才理解 首先定義 dp[i][j]: 第 i 條線, 高度 j 的點有幾種畫法 不難想像, 轉移方程式可以寫成 dp[i][j] = dp[i - 1][j - 1] 高度 j 當然可以從 j - 1 轉移過來 但還有個需要考慮的是, 同高度的也能轉移過來 而同高度的可以從不只一個地方轉移, 所以用 sum[j] 代表高度 j 的畫法 因此遞迴式變成這樣: dp[i][j] = dp[i - 1][j - 1] + sum[j] 我們稍微把圖畫得複雜一點: sum[j] 的遞迴方式是: sum[j] - dp[i - j][j] + dp[i][j] dp[i - j][j] 已經走到高度為 0 的路線 因此之後已經沒有路線可以走, 簡單來說就是被 dp[i][j] 取代掉 所以必須扣掉避免重複 而答案即是第 i 條線上面各種高度的總和</description></item><item><title>Uva 10032 - Tug of War</title><link>https://ptzu.github.io/posts/uva10032/</link><pubDate>Mon, 05 Feb 2018 15:07:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10032/</guid><description>題目
input 第一列輸入 T, 代表 T case 每筆測資開頭輸入 n, n 最多 100 接著輸入 n 個人的體重
題解 將人分成兩堆, 使兩隊的體重和相差最小 並且兩隊人數最多只能差 1
作法 這題類似 Uva 562, 分成兩堆, 使得總和差最小 但是多了一個限制是人數只能差 1 原本是 dp[人數][重量] = 0 or 1, 代表該重量能否組出 現在多一個條件 dp[人數][重量][目前人數] = 0 or 1 的三維DP 但是會超時 我們把第三維度利用位元操作, 轉為 64 bits 的資料 也就是 dp[人數][重量] = bitset 而那個 bitset 代表的是組出這個重量, 那一隊可以有幾人 例如 dp[人數][重量] = 1110(二進位) 就代表他可以用 1(2^1)、2(2^2)、3(2^3) 這些人數組成 最後只要看 n/2、n/2+1(偶數人數), n/2(奇數人數)的 bit 是否成立即可
AC code #include &amp;lt;bits/stdc++.</description></item><item><title>HDU 5418 - Victor and World</title><link>https://ptzu.github.io/posts/hdu5418/</link><pubDate>Mon, 05 Feb 2018 12:49:00 +0000</pubDate><guid>https://ptzu.github.io/posts/hdu5418/</guid><description>題目
input 第一列輸入 T, 代表 T case 每筆測資開頭輸入 n, m, 1 &amp;lt;= n &amp;lt;= 16, 1 &amp;lt;= m &amp;lt;= 100000 代表 n 個點, m 條邊 每條邊都是無向邊 輸入 u, v, w 代表 u 到 v 花費 w
題解 Victor 想環遊世界, 求拜訪每個國家並回到起點的最少花費 每個國家可拜訪不只一次
作法 同 POJ 3311 只是這題的距離不是給相鄰矩陣 先用 floyd 求一下距離
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 3311 Hie with the Pie</title><link>https://ptzu.github.io/posts/poj3311/</link><pubDate>Sun, 04 Feb 2018 01:33:35 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3311/</guid><description>題目
input 含多筆測資, 每筆測資開頭輸入 n, 1 &amp;lt;= n &amp;lt;= 10 代表除了起點以外, 有幾個點 接著輸入相鄰矩陣代表點之間的距離
題解 這題規定每個點可不只經過一次 然後 TSP 是限定每個點只能有一次 需要做點小修改
作法 TSP裸題
AC code bottom up 作法
#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 11; int d[MAX_N][MAX_N]; int dp[1 &amp;lt;&amp;lt; MAX_N][MAX_N]; void floyd(int V){ for(int k = 0; k &amp;lt; V; k++){ for(int i = 0; i &amp;lt; V; i++){ for(int j = 0; j &amp;lt; V; j++){ d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } int main(){ int n; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Uva 562 - Dividing coins</title><link>https://ptzu.github.io/posts/uva562/</link><pubDate>Fri, 02 Feb 2018 19:16:02 +0000</pubDate><guid>https://ptzu.github.io/posts/uva562/</guid><description>題目
input 第一列輸入 Test Case 每筆測資開頭輸入 n, 表有 n 種硬幣 接著輸入 n 種硬幣
題解 兩人分錢
作法 要使差距最小, 那就是愈接近一半愈好 把金額當作背包, 使得背包裡的價值愈大愈好
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 60000; int n; int a[110]; int dp[50505]; int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(dp, 0, sizeof(dp)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); int sum = 0; for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); sum += a[i]; } int m = sum / 2; for(int i = 0; i &amp;lt; n; i++){ for(int j = m; j &amp;gt;= a[i]; j--) dp[j] = max(dp[j], dp[j - a[i]] + a[i]); } printf(&amp;#34;%d\n&amp;#34;, (sum - dp[m]) - dp[m]); } return 0; }</description></item><item><title>Uva 481 - What Goes Up</title><link>https://ptzu.github.io/posts/uva481/</link><pubDate>Fri, 15 Dec 2017 09:09:05 +0000</pubDate><guid>https://ptzu.github.io/posts/uva481/</guid><description>題目
input 據說50萬個數字左右
題解 求 LIS 的最長長度 如果有多個, 印最後一個出現的LIS
作法 LIS裸題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 1000000; int v[MAX_N]; int dp[MAX_N]; int pos[MAX_N]; int main(){ int x, n = 0; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;x) !</description></item><item><title>Uva 10130 - SuperSale</title><link>https://ptzu.github.io/posts/uva10130/</link><pubDate>Thu, 30 Nov 2017 11:51:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10130/</guid><description>題目
input 1 &amp;lt;= T, N &amp;lt;= 1000 1 &amp;lt;= P &amp;lt;= 100 1 &amp;lt;= W &amp;lt;= 30 1 &amp;lt;= 背包容量 &amp;lt;= 30
題解 給 n 個物品, 每個物品有價格和重量 每個人最多可以帶 MW 重量 每個人對某個物品最多只能拿一次 求全部人可以買多少價格的商品
作法 01背包問題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int V[1010], W[1010]; int dp[100], n; void solve(){ // 如果迴圈從重量開始, 會導致少算一些價值 // 例如求容量為 90 的最大價值, 可以放入重量 30, 60的物品 // 但是我們只會放入其中一個, 因為不管是 dp[90 - 30], dp[90 - 60] 都還沒計算 // 若迴圈從物品開始, 我們就可以計算每個容量的最大價值 // 可能有個疑問, 為什麼迴圈重量不從 0 開始跑就好, 這樣每個重量也都會被先計算阿？ // 因為這樣就變成多重背包問題(每個物品可以選不只一次)了=w= // for(int i = 99; i &amp;gt;= 0; i--){ // for(int j = 0; j &amp;lt; n; j++){ // if(i &amp;gt;= W[j]){ // dp[i] = max(dp[i], dp[i - W[j]] + V[j]); // } // } // } for(int i = 0; i &amp;lt; n; i++){ for(int j = 99; j &amp;gt;= W[i]; j--){ dp[j] = max(dp[j], dp[j - W[i]] + V[i]); } } } int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(dp, 0, sizeof(dp)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;V[i], &amp;amp;W[i]); } solve(); int G; scanf(&amp;#34;%d&amp;#34;, &amp;amp;G); int ans = 0; for(int i = 0; i &amp;lt; G; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); ans += dp[x]; } printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; }</description></item><item><title>Uva 10684 - The jackpot</title><link>https://ptzu.github.io/posts/uva10684/</link><pubDate>Thu, 30 Mar 2017 22:45:00 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10684/</guid><description>題目
input n 個數: n &amp;lt;= 10000 數字 x: 0 &amp;lt; x &amp;lt; 1000
題解 Manuel 想要快速變有錢, 所以他決定去賭博 他精心計劃了贏錢的策略 每個下注可能贏錢或輸錢 求一段連續的下注最多可以獲得多少錢 ps: 題目說負值輸出 losing, 但根據測資, 0 也算 losing
作法 最大連續區間和裸題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int dp[10101]; int n; int main(){ while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Codeforces Round 407</title><link>https://ptzu.github.io/posts/cf407/</link><pubDate>Thu, 30 Mar 2017 16:32:28 +0000</pubDate><guid>https://ptzu.github.io/posts/cf407/</guid><description>目錄 微動腦實作 math 最大連續區間和變形 A. Anastasia and pebbles 題目
input n 種石頭, 口袋能放 k 個: 1 ≤ n ≤ 10^5, 1 ≤ k ≤ 10^9 石頭數量 w1&amp;hellip;wn: 1 ≤ wi ≤ 10^4
題解 Anastasia 決定在公園裡蒐集石頭 他有兩個口袋, 每個口袋可以放 k 個石頭 公園裡有 n 種石頭, 第 i 種石頭有 wi 個 在同一個口袋不能放不同種類的石頭 她一天只能來公園蒐集一次石頭(兩個口袋滿) 請問要幾天才能蒐集完公園裡全部石頭？
作法 由於每次只能裝 k 個, 而且不能混別種石頭 所以就每 k 個當作一堆, 每天能裝 2 堆 看要幾天
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Educational Codeforces Round 18</title><link>https://ptzu.github.io/posts/cfedu18/</link><pubDate>Thu, 30 Mar 2017 16:32:26 +0000</pubDate><guid>https://ptzu.github.io/posts/cfedu18/</guid><description>目錄 距離 sort 使用 vector erase 數字 digit 總於除 3 A. New Bus Route 題目
input n 個城市: 2 ≤ n ≤ 2·10^5 城市座標: - 10^9 ≤ a ≤ 10^9
題解 有 n 座城市, 要規劃新的公車路線 所以要求出任兩城市的最短距離, 以及符合該距離的 pair 有幾個？
作法 sort
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 406</title><link>https://ptzu.github.io/posts/cf406/</link><pubDate>Fri, 24 Mar 2017 22:35:41 +0000</pubDate><guid>https://ptzu.github.io/posts/cf406/</guid><description>目錄 A. The Monster 題目
input 1 ≤ a, b, c, d ≤ 100
題解 b, b + a, b + 2a, &amp;hellip; b 以這樣成長著 d, d + c, d + 2c, &amp;hellip; d 以這樣成長著 求 b 和 d 何時會相同, 輸出第一個相同的數 沒有這樣的數就輸出 -1
作法 我的作法是讓迴圈跑 100 次 想法是這樣 b, d的範圍是 100 假設極端測資, b = 100, d = 1 a = 1, c = 2 差距 99, 每次拉近 1 跑 100 次該重疊的也要重疊了吧？ 不過沒有嚴謹的證明, 只是憑感覺 但似乎大家都是這麼做的</description></item><item><title>Uva 10003 - Cutting Sticks</title><link>https://ptzu.github.io/posts/uva10003/</link><pubDate>Mon, 13 Mar 2017 16:23:33 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10003/</guid><description>題目
input 棍子長度 L: 0 &amp;lt; L &amp;lt; 1000 切點數量 n: n &amp;lt; 50 切點位置: 0 &amp;lt; c &amp;lt; L 當 L = 0時結束輸入
題解 給一根棍子以及 n 個切點 切棍子的費用是, 要切的棍子長度 求切完 n 個點, 最小的花費
作法 O(N^3) 第二次做這題目, 看到原本的code卻一直想不通 是對切點做DP, 而不是棍子的長度！ 定義 dp[i][j]: 完成第 i 個點 &amp;hellip; 第 j 個點所花的最小費用 在頭尾新增兩個切點, cut[0] = 0, cut[n + 1] = L 作用是如果沒有切點在兩端, 就不好算當前棍子長度了
根據不同的 i &amp;hellip; j 範圍, 選擇一個 k 點切下去
DP遞迴式 dp[i][j] = {dp[i][k] + dp[k][j] + (cut[j] - cut[i]) | for i &amp;lt; k &amp;lt; j} AC code #include &amp;lt;bits/stdc++.</description></item><item><title>POJ 3624 Charm Bracelet</title><link>https://ptzu.github.io/posts/poj3624/</link><pubDate>Wed, 18 Jan 2017 18:08:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3624/</guid><description>題解 01背包問題裸題, 但需要空間優化
作法 dp陣列開成兩條一維, 交替使用
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, m; int dp[2][13000]; int w[3500], d[3500]; int main(){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;m); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;w[i], &amp;amp;d[i]); } for(int i = 0; i &amp;lt; n; i++){ for(int j = 0; j &amp;lt;= m; j++){ if(j &amp;lt; w[i]) dp[(i + 1) &amp;amp; 1][j] = dp[i &amp;amp; 1][j]; else dp[(i + 1) &amp;amp; 1][j] = max(dp[i &amp;amp; 1][j], dp[i &amp;amp; 1][j - w[i]] + d[i]); } } printf(&amp;#34;%d\n&amp;#34;, dp[n &amp;amp; 1][m]); return 0; }</description></item><item><title>Codeforces Beta Round 89 (Div. 2) (not finished)</title><link>https://ptzu.github.io/posts/cf89/</link><pubDate>Fri, 15 Jul 2016 16:34:29 +0000</pubDate><guid>https://ptzu.github.io/posts/cf89/</guid><description>D. Caesar&amp;rsquo;s Legions 題目
題解 給 n1, n2, k1, k2 現有一排軍隊, n1 個步兵, n2個騎兵 步兵不能連續站在一起超過 k1 個, 騎兵不能超過 k2 個 求有多少種排法符合條件
作法 一開始想到的DP定義 dp[i][j][k] : i 位士兵, 最後一串連續的士兵為 j: 0 是步兵, 1 是騎兵, 連續的長度為k
但這樣會有個問題,用了 i 位士兵,無法判定那兩種士兵各用了幾位(可能會超過(n1 or n2)
所以改成 dp[i][j][k][l] : i, j 分別代表步兵和騎兵各有幾位 其他定義相同
答案為dp[n1][n2][0][1~k1] + dp[n1][n2][1][1~k2] 總和 % 100000000
DP遞迴 if(連續長度 &amp;gt; 1) //直接補上一個數字,方法數等同前一長度的方法數 dp[i][j][k][l] = dp[i][j][k][l - 1] else if(連續長度 == 1) //選擇另一種士兵,連續長度為 1 &amp;lt;= s &amp;lt;= (k1 or k2)的總和, 要注意 s 不能超過 i 或 j, 不然會多算 dp[i][j][k][l] = sum(dp[i][j][!</description></item><item><title>POJ 3046 Ant Counting</title><link>https://ptzu.github.io/posts/poj3046/</link><pubDate>Sat, 09 Jul 2016 23:26:56 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3046/</guid><description>題解 多重背包變形 給定有 T 個不同的家族,及有 A 隻螞蟻(屬於哪個家族) 求利用 T 個家族,及總共S&amp;hellip;B隻螞蟻的情況下 能組出不同組合的數量
作法 分割成子問題,只用前i家族的螞蟻,慢慢推到全部 定義dp[i][j] ： 用前i個家族共j隻螞蟻,能組出不同組合的數量 題目要求只輸出6位數,所以還要取餘數
DP遞迴 dp[i][j] = sum(dp[i-1][j-k]), k為目前i家族所有的螞蟻數量 概念類似排列組合的選取,選i家族：0隻、1隻&amp;hellip;、num[i]隻 那i-1就要用j-k隻(不然怎麼有j隻嘛)
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 1742 Coins</title><link>https://ptzu.github.io/posts/poj1742/</link><pubDate>Sat, 09 Jul 2016 10:11:43 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1742/</guid><description>題解 給定硬幣面額及數量,求在金額 m 以內,可以組出的額度數量作法 可以用多重背包,三層迴圈去解,但會TLE所以我們先把它當成無限背包解,再用一個陣列num去紀錄已使用的硬幣數量時間複雜度：O(nm)兩種DP表格建法 1.若j金額可以,則推廣到j + A[i]
for (int i = 0; i &amp;lt; N; ++i) { fill(num, num+M+1, 0); for (int j = 0; j+A[i] &amp;lt;= M; ++j) if (dp[j] == true &amp;amp;&amp;amp; !dp[j+A[i]] &amp;amp;&amp;amp; num[j] &amp;lt; C[i]) { dp[j+A[i]] = true; num[j+A[i]] = num[j] + 1; } } 2.若j - A[i]可以組出,則金額j也可組出
for(int i = 0; i &amp;lt; n; i++){ memset(num, 0, sizeof(num)); //j從A[i]開始,因為小於A[i]不可能組出 for(int j = A[i]; j &amp;lt;= m; j++){ if(dp[j] == false &amp;amp;&amp;amp; dp[j - A[i]] &amp;amp;&amp;amp; num[j - A[i]] &amp;lt; C[i]){ dp[j] = true; num[j] = num[j - A[i]] + 1; } } } AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 3280 Cheapest Palindrome</title><link>https://ptzu.github.io/posts/poj3280/</link><pubDate>Wed, 06 Jul 2016 19:29:49 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3280/</guid><description>題解 迴文最小成本問題給定字符增添及刪除成本求將字串變成迴文的最小成本作法 字符的增添及刪除本質上是一樣的所以只要存下該字符的增添或刪除成本取最小的dp[i][j]： 代表字串i&amp;hellip;j變成迴文的最小成本遞迴式爲 dp[i][j] = min(dp[i+1][j] + cost, dp[i][j-1] + cost)看處理左邊或右邊哪個好當左右字符一樣時 s[i] == s[j]: 看dp[i+1][j-1] 是否能更小AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int N,M; int cost[30]; int dp[2048][2048]; int main(){ ios::sync_with_stdio(false); cin.</description></item></channel></rss>
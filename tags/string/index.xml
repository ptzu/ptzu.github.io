<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>String on Ptzu's blog</title><link>https://ptzu.github.io/tags/string/</link><description>Recent content in String on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 12 Jan 2018 12:46:31 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/string/index.xml" rel="self" type="application/rss+xml"/><item><title>String 切 Token</title><link>https://ptzu.github.io/posts/string-token/</link><pubDate>Fri, 12 Jan 2018 12:46:31 +0000</pubDate><guid>https://ptzu.github.io/posts/string-token/</guid><description>有兩種方法
將 string 轉為 c 字串, 然後用 strtok 利用 stringstream 第一種：
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; string s; int main(){ while(getline(cin, s)){ char cstr[10000]; strcpy(cstr, s.c_str()); char *token = strtok(cstr, &amp;#34; &amp;#34;); while(token != NULL){ printf(&amp;#34;%s &amp;#34;, token); token = strtok(NULL, &amp;#34; &amp;#34;); } puts(&amp;#34;&amp;#34;); } return 0; } 第二種:
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; string s; stringstream ss; int main(){ while(getline(cin, s)){ ss.str(&amp;#34;&amp;#34;); ss.clear(); // 上面兩行是清空 stringstream, 兩行都必加 ss &amp;lt;&amp;lt; s; int n; while(ss &amp;gt;&amp;gt; n){ cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; endl; } return 0; } 測試資料:</description></item><item><title>Codeforces Beta Round 93 (Div. 1 Only)</title><link>https://ptzu.github.io/posts/cf93/</link><pubDate>Mon, 01 Aug 2016 21:10:58 +0000</pubDate><guid>https://ptzu.github.io/posts/cf93/</guid><description>B. Password # string 題目
題解 給一字串 尋找是否有一子字串 出現在前綴(開頭), 中間, 以及後綴 輸出符合條件的最長子字串 如果沒有就輸出 Just a legend
作法 字串搜尋類型的題目 暴力搜尋會花上 O(nm) 的時間 為了這題, 又去重新理解一次KMP 果然這東西還是很難記住啊~~
這題有兩種作法
用failure function 的特性 用rolling hash(尚未研究) 如果還不懂何謂KMP 先去看看演算法教學吧~~ &amp;mdash;-以下開始&amp;mdash;- 當建好 f 函數時 把所有有匹配到的字元, 做上標記(不標記最後一字元) 然後看字串最後一個字元的 f 函數值是多少 假如前綴和後綴都有, 那我們就要來看中間是否有出現過啦 作法就是以最後一字元的函數值做回溯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>KMP Algorithm 探討</title><link>https://ptzu.github.io/posts/kmp/</link><pubDate>Thu, 28 Jul 2016 13:06:36 +0000</pubDate><guid>https://ptzu.github.io/posts/kmp/</guid><description>關於KMP 一般再搜尋字串時, 暴力搜尋將每個位置都搜尋一次 同時比對要搜尋的字串(pattern) 時間複雜度為O(nm)
KMP演算法改進了一些不必要的搜尋 使得時間複雜度為O(n + m)
名詞定義 失敗函數(failure function): 當比對失敗時, pattern需位移幾位才能成為前綴, 一般用在字串比對失敗時查找, 故稱失敗函數
建立 F 函數 這邊放上網路上常見兩種寫法 不變的是 j 代表的是目前比對的字元的 &amp;lsquo;前一個字&amp;rsquo; f[i] 代表比對失敗時, j 要變成的位置
字串從 0 開始存, 沒匹配字元時, f 值為 -1 void getF(string s){ f[0] = -1; for(int i = 1; i &amp;lt; s.length(); i++){ int j = f[i - 1]; //如果不相等, 先位移到適合位置 while(j &amp;gt;= 0 &amp;amp;&amp;amp; s[j + 1] != s[i]) j = f[j]; if(s[j + 1] == s[i]) f[i] = j + 1; //還是不相等, 此時 j = -1 else f[i] = j; } } 字串從 1 開始存, 沒匹配字元時, f 值為 0 void getF(string s) { for (int i = 2; i &amp;lt;= s.</description></item></channel></rss>
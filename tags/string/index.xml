<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>String on Ptzu's blog</title><link>https://ptzu.github.io/tags/string/</link><description>Recent content in String on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 Aug 2016 21:10:58 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/string/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeforces Beta Round 93 (Div. 1 Only)</title><link>https://ptzu.github.io/posts/cf93/</link><pubDate>Mon, 01 Aug 2016 21:10:58 +0000</pubDate><guid>https://ptzu.github.io/posts/cf93/</guid><description>B. Password # string 題目
題解 給一字串 尋找是否有一子字串 出現在前綴(開頭), 中間, 以及後綴 輸出符合條件的最長子字串 如果沒有就輸出 Just a legend
作法 字串搜尋類型的題目 暴力搜尋會花上 O(nm) 的時間 為了這題, 又去重新理解一次KMP 果然這東西還是很難記住啊~~
這題有兩種作法
用failure function 的特性 用rolling hash(尚未研究) 如果還不懂何謂KMP 先去看看演算法教學吧~~ &amp;mdash;-以下開始&amp;mdash;- 當建好 f 函數時 把所有有匹配到的字元, 做上標記(不標記最後一字元) 然後看字串最後一個字元的 f 函數值是多少 假如前綴和後綴都有, 那我們就要來看中間是否有出現過啦 作法就是以最後一字元的函數值做回溯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item></channel></rss>
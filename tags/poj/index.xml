<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>POJ on Ptzu's blog</title><link>https://ptzu.github.io/tags/poj/</link><description>Recent content in POJ on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 13 Apr 2018 16:46:55 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/poj/index.xml" rel="self" type="application/rss+xml"/><item><title>POJ 1201 Intervals</title><link>https://ptzu.github.io/posts/poj1201/</link><pubDate>Fri, 13 Apr 2018 16:46:55 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1201/</guid><description>題目
input 輸入 N (1 &amp;lt;= N &amp;lt;= 50000) 代表有 N 個區間 區間輸入 [a, b] 有 c 個元素
題解 給一些區間, 並告訴你其中有幾個元素 區間之間可重疊元素 請問總共最少有幾個元素？
作法 區間約束 令 d[i] 為 0&amp;hellip;i 區間有幾個元素 則題目可以轉化為 d[b + 1] - d[a] &amp;gt;= c index 向右平移 1 是為了不要有負的 index 然後稍做整理 d[a] - d[b + 1] &amp;lt;= -c 建一條從 a -&amp;gt; b 的 -c 邊 除此之外還有個條件是 0 &amp;lt;= d[i + 1] - d[i] &amp;lt;= 1 建好圖之後求差分約束即可
PS： 網路上很多作法在建邊是這樣定義 d[b + 1] - d[a] &amp;gt;= c, 從 a -&amp;gt; b 建一條 c 邊 然後求最長路徑 想法應該是一樣 不過有點麻煩我就用我習慣的定義了</description></item><item><title>POJ 3169 Layout</title><link>https://ptzu.github.io/posts/poj3169/</link><pubDate>Fri, 13 Apr 2018 07:33:17 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3169/</guid><description>題目
input 輸入 N, E1, E2 (2 &amp;lt;= N &amp;lt;= 1,000)(1 &amp;lt;= E1,E2 &amp;lt;= 10,000) 分別代表 N 頭牛, 最大距離限制數量, 最小距離限制數量 接著輸入 E1, E2 個限制
題解 有 N 頭牛編號 1 ~ N 有些牛想要和其他牛保持距離, 有些牛希望和其他牛在一定距離內 給一些限制表示兩頭牛之間的最大及最小距離 問第一頭牛和最後一頭牛的最大距離是多少
作法 差分約束裸題 有負環輸出 -1 到不了輸出 -2
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 3461 Oulipo</title><link>https://ptzu.github.io/posts/poj3461/</link><pubDate>Sun, 18 Mar 2018 09:54:41 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3461/</guid><description>題目
input 多筆測資, 每筆測資先輸入目標字串 t (1 &amp;lt;= |t| &amp;lt;= 10000) 再輸入比對字串 s (|t| &amp;lt;= |s| &amp;lt;= 1000000)
題解 給一文本 求目標字串在文本的出現次數
作法 KMP比對
AC code #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 10010; int fail[MAX_N]; int len, ans; void getf(string s){ fail[0] = -1; int idx = -1; for(int i = 1; i &amp;lt; s.</description></item><item><title>POJ 1741 Tree</title><link>https://ptzu.github.io/posts/poj1741/</link><pubDate>Sat, 17 Mar 2018 16:11:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1741/</guid><description>題目
input 多筆測資, 每筆開頭輸入 n, k (n &amp;lt;= 10000) 代表 n 個點, 路徑長 k 接著輸入 n - 1 條邊 u, v, w 代表 u 連到 v 權重 w
題解 給一棵樹 求點對 (u, v) 長度不超過 k 有幾個點對
作法 利用重心分解的技巧 每次都從重心做樹分治 複雜度: {%math%}O(logn){%endmath%} 針對每個重心, 跑一次DFS 每個子樹我們可以求點到根的距離 cal(x) 可以求取以 x 為根, 經過 x 的路徑有幾條 經過排序後, 可以在 O(n) 時間內求取所有點對 瓶頸在排序, 複雜度：{%math%}O(nlogn){%endmath%}
由於當 k 夠大時, cal(x) 會計算到不經過 x, 但長度為 &amp;lt;= k 的路徑 因此每次都要扣掉子樹的數量
總複雜度: {%math%}O(nlog^{2}n){%endmath%}</description></item><item><title>POJ 1655 Balancing Act</title><link>https://ptzu.github.io/posts/poj1655/</link><pubDate>Wed, 14 Mar 2018 14:42:58 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1655/</guid><description>題目
input 含多筆測資, 每筆測資開頭輸入 V (1 &amp;lt;= V &amp;lt;= 20,000) 代表 V 個點 接著輸入 V - 1 條樹邊
題解 找樹重心, 有多個就輸出編號最小的
作法 找樹重心, 有多個就輸出編號最小的
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX vector &amp;lt;int&amp;gt; g[20010]; int son[20010], centroid, balance_size; int V; void init(){ for(int i = 0; i &amp;lt; V; i++) g[i].</description></item><item><title>POJ 1830 开关问题</title><link>https://ptzu.github.io/posts/poj1830/</link><pubDate>Tue, 13 Mar 2018 16:32:10 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1830/</guid><description>題目
input 输入第一行有一个数K，表示以下有K组测试数据。 每组测试数据的格式如下： 第一行 一个数N（0 &amp;lt; N &amp;lt; 29） 第二行 N个0或者1的数，表示开始时N个开关状态。 第三行 N个0或者1的数，表示操作结束后N个开关的状态。 接下来 每行两个数I J，表示如果操作第 I 个开关，第J个开关的状态也会变化。每组数据以 0 0 结束。
題解 有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。你的目标是经过若干次开关操作后使得最后N个开关达到一个特定的状态。对于任意一个开关，最多只能进行一次开关操作。你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序）
作法 用高斯消去法找自由變數量
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX typedef vector&amp;lt;int&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; int tot; // 自由變數量 void gauss(mat &amp;amp;m){ int n = m.</description></item><item><title>POJ 1523 SPF</title><link>https://ptzu.github.io/posts/poj1523/</link><pubDate>Tue, 06 Mar 2018 21:20:50 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1523/</guid><description>題目
input 含多筆測資 無限量的輸入邊 直到輸入 0 結束
題解 Single Point of Failure 定義為拿掉該點, 會使得至少一點不連通 求所有的 SPF 和會分成幾塊
作法 求拿掉割點會分成幾塊
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;set&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 10010; int V, E; vector &amp;lt;int&amp;gt; g[MAX_V]; int dfn[MAX_V], low[MAX_V], tot, bccid[MAX_V], bcc_cnt; int cut[MAX_V]; stack &amp;lt;int&amp;gt; S; int cnt; set &amp;lt;int&amp;gt; ans; void init(){ for(int i = 0; i &amp;lt; V; i++) g[i].</description></item><item><title>POJ 2117 Electricity</title><link>https://ptzu.github.io/posts/poj2117/</link><pubDate>Tue, 06 Mar 2018 21:20:47 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2117/</guid><description>題目
input 多筆測資, 每筆測資輸入 V, E V, E 為 0 結束 接著輸入 E 條邊
題解 現有 V 個電廠, 要建立一個電路網不需要任兩個電廠都連接 要考慮電路網的可靠度, 假設一個電廠掛掉, 會被分成幾個區塊 請問最多可能被分為幾塊
作法 和找割點差不多 cut[i] 改成會切開幾個兒子(有幾個橋邊) 若 i 是根, 則會增加 cut[i] - 1 個
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 3352 Road Construction</title><link>https://ptzu.github.io/posts/poj3352/</link><pubDate>Tue, 06 Mar 2018 17:47:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3352/</guid><description>題目
input 多筆測資, 每筆測資開頭輸入 V, E (3 ≤ V ≤ 1000)(2 ≤ E ≤ 1000) 分別代表點數和邊數 接著輸入 E 條邊
注意輸入和輸出的中文字都是沒有的
題解 有一座島上有 V 個名勝景點, 他們之間有許多路互相連接 現在想要維修&amp;quot;一條&amp;quot;路, 所以這條路就不能走了 然而不想讓這些名勝景點斷開連結 所以決定建造一些路, 使得之間仍然連通, 建造中的路可以行走 問最少需要建造幾條路？ 維修中的路不能走, 建造中的路可以走, 真是神邏輯&amp;hellip;
作法 邊-雙連通分量
拔掉一個邊還要連通, 那代表該圖要是雙連通分量 作法是找到雙連通分量, 縮點後 想要將此圖建成雙連通 需要加的邊數為 (度數為 1 的點) + 1 / 2
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 1144 Network</title><link>https://ptzu.github.io/posts/poj1144/</link><pubDate>Fri, 02 Mar 2018 11:50:28 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1144/</guid><description>題目
input 含多筆測資, 每筆開頭輸入 N, 代表 N 個點, N = 0 結束測資 接下來有不定數量的列 每列開頭輸入 u, 當 u = 0 結束 u 後面接著多個數 v, 代表 u, v 之間有一條邊
題解 電話公司正在建立電話網, 有 N 個地方, 編號從 1 ~ N 每條電話線是雙向的, 每個地方都有個電話轉接站 任兩個地方可透過轉接站連接, 所以不必直接連接 若有個轉接站停電會造成某些區域無法互相連通 稱那個地方為 critical, 求有幾個地方是 critical
作法 找關節點數量 不過用 SCC 的方法也過了, 還沒去想是否正確
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;numeric&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 2186 Popular Cows</title><link>https://ptzu.github.io/posts/poj2186/</link><pubDate>Tue, 27 Feb 2018 23:46:26 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2186/</guid><description>題目
input 輸入 N, M (1 &amp;lt;= N &amp;lt;= 10,000)(1 &amp;lt;= M &amp;lt;= 50,000) 代表 N 頭牛, M 條關係 接著 M 條關係 輸入 A B, 代表 牛A 認為 牛B 很紅
題解 (A, B) 代表 牛A 認為 牛B 很紅, 而這種關係有遞移性 即 A-&amp;gt;B, B-&amp;gt;C, 則 A-&amp;gt;C 請問有幾頭牛被其他所有的牛認為很紅？
作法 首先當一頭牛被所有牛認為很紅的時候(最紅) 那和這頭牛在同一個 SCC 的也必定是最紅 在求 SCC 時最後一個 SCC 就會是最紅的一群 因為整張圖是個 DAG, 最後一個 SCC 便是大家連過去的 所以找到最後一個 SCC 時, 就跑一次 RDFS, 如果能跑完所有點 就是答案
Tarjan AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 2823 Sliding Window</title><link>https://ptzu.github.io/posts/poj2823/</link><pubDate>Sat, 17 Feb 2018 17:50:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2823/</guid><description>題目
input 輸入 n, k (n ≤ 10^6) n 個數字及視窗大小 k
題解 視窗由左而右平移, 輸出每個視窗內的最小/大值
作法 利用單調隊列, 看有人用大小堆作, 之後再來試看看 首先單增隊列維護最小值, 同時紀錄隊列內每個值的 index, 用來判斷是否還在視窗內 將當前元素和隊尾做比較, 如果該元素比較小, 則把隊尾 pop, 直到遇到比該元素還大的 然後就把該元素塞進去, 此時的隊頭即為最小值 同理可以用單減隊列維護最大值, 作法同上
為何單增不能維護最大值呢？因為只要遇到比較小的元素, 就會被 pop 例如 3, 2, 1 最後只會留下 1
PS: 一直不太喜歡 POJ 的 compiler, 這題用 G++ 提交會超時, C++ 不會 明明同樣一份 code, 時間差了至少一倍以上
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 1330 Nearest Common Ancestors</title><link>https://ptzu.github.io/posts/poj1330/</link><pubDate>Fri, 16 Feb 2018 19:52:38 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1330/</guid><description>題目
input 第一列輸入 T, 代表 T cases 每筆第一列輸入 N (2 &amp;lt;= N &amp;lt;= 10,000) 代表樹有 N 個點 接著輸入 N - 1 條邊 u, v 代表 u 是 v 的父節點 最後一列輸入 qu, qv, 求 qu, qv 的 LCA
題解 找出最近共同祖先
作法 LCA 裸題
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 2299 Ultra-QuickSort</title><link>https://ptzu.github.io/posts/poj2299/</link><pubDate>Thu, 15 Feb 2018 21:13:37 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2299/</guid><description>題目
input 有多筆測資, 每筆第一列輸入 n (n &amp;lt; 500,000) 接著輸入 n 個數
題解 給一數列做排序 只能相鄰數字做交換 請問要交換幾次才能完成排序 即為求逆序數對個數
作法 Merge Sort 求逆序數對
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 505050; int a[MAX_N]; ll ans; void Merge(int l, int m, int r){ vector &amp;lt;int&amp;gt; temp; int idx1 = l, idx2 = m + 1; while(idx1 &amp;lt;= m &amp;amp;&amp;amp; idx2 &amp;lt;= r){ if(a[idx1] &amp;lt;= a[idx2]){ temp.</description></item><item><title>POJ 2385 Apple Catching</title><link>https://ptzu.github.io/posts/poj2385/</link><pubDate>Wed, 14 Feb 2018 18:14:44 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2385/</guid><description>題目
input 第一列輸入 T, W (1 &amp;lt;= T &amp;lt;= 1,000), (1 &amp;lt;= W &amp;lt;= 30) 代表 T 分鐘和最多移動 W 次
題解 約翰農夫有兩棵蘋果樹, 每分鐘只會有一棵樹結出蘋果 Bessie 可以在兩棵樹間移動, 最多移動 W 次 初始位置在樹 1, 請問他最多能接到幾顆蘋果？
作法 第二次寫這題了, 雖然是簡單題 終於自己想出遞迴式, 超爽derrr 本來想放棄去看之前的 code QQ
首先定義 dp[i][j][k]: 在第 i 分鐘, 走了 j 步, 目前在第 k 樹最多能接到幾顆蘋果 考慮兩種情況
目前站在會結蘋果的樹下, 那有兩種選擇, 原本就站在 k 樹下所以不動 或者從 k ^ 1 樹走過來(k ^ 1, 0 變 1, 1 變 0) 這兩種情況挑大的, 然後 +1 目前站在沒有蘋果的樹下, 和上面一樣兩種選擇, 但是沒有蘋果, 所以不 +1 AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 2229 Sumsets</title><link>https://ptzu.github.io/posts/poj2229/</link><pubDate>Wed, 14 Feb 2018 10:24:02 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2229/</guid><description>題目
input 輸入 N (1 &amp;lt;= N &amp;lt;= 1,000,000)
題解 若只用 2 的次方數 求組出 N 有幾種方法
作法 定義 dp[i]: 組出 i 的方法數 將奇偶數分開考慮 首先奇數為前一個數 +1, 而 +1 不可能產生新的二次方數, 所以方法數和 i - 1 一樣
dp[i] = dp[i - 1] 偶數同樣可以從 i - 1 推過來 但是為偶數, 代表 +1 一定加到偶數個, 所以會產生新的二次方數 考慮 i / 2 這個數, 當他 +1 加到 i, 代表整個翻倍
dp[i] = dp[i - 1] + dp[i / 2] AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 3176 Cow Bowling</title><link>https://ptzu.github.io/posts/poj3176/</link><pubDate>Tue, 13 Feb 2018 23:10:22 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3176/</guid><description>題目
input 第一列輸入 N (1 &amp;lt;= N &amp;lt;= 350) 代表 N 列的三角形 接著輸入三角形
題解 牛牛們玩保齡球, 得分為從三角形頂部到底部, 所經過的點值總和 求最大得分為多少
作法 定義 dp[i][j] 為第 i 列第 j 行的得分總和 遞迴式即為是上層的兩個(或一個)選大的走下來 dp[i][j] += max(dp[i - 1][j - 1], dp[i - 1][j]) 最後求底層最大值即可
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 2084 Game of Connections</title><link>https://ptzu.github.io/posts/poj2084/</link><pubDate>Sat, 10 Feb 2018 14:41:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2084/</guid><description>題目
input 多筆測資, 每筆輸入 n, 1 &amp;lt;= n &amp;lt;= 100 輸入 -1 結束測資
題解 有 2 * n 個點順時針排序, 任兩點連線, 但線不准交叉 求有幾種連法
作法 卡塔蘭數 固定點 1, 向周圍的點畫線 可以把圖分成左右兩塊, 左右兩塊的點數都是偶數(因為奇數必不能兩兩互連) 我們可以得到以下結論 h(0) = 1,h(1) = 1 遞迴式：
h(n) = h(0)*h(n-1) + h(1)*h(n-2) + &amp;hellip; + h(n-1)h(0) (其中 n &amp;gt;= 2) 即為卡塔蘭數
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 2677 Tour</title><link>https://ptzu.github.io/posts/poj2677/</link><pubDate>Thu, 08 Feb 2018 17:00:43 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2677/</guid><description>題目
input 含多筆測資, 每筆測資開頭輸入 n, 代表 n 個點 接著輸入 n 個點的 x, y 座標 x 座標為遞增
題解 從最左邊的點, 嚴格遞增走到右邊 然後再從最右邊嚴格遞減走回起點, 求這路程的最小距離
作法 Bitonic TSP 這題要注意, double 要用 %f 輸出而不是 %lf 才能過 猜測是精度的問題, 不影響題意理解
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;cmath&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 100; struct point{ double x, y; }; int n; point p[MAX_N]; double dis[MAX_N][MAX_N]; double dp[MAX_N][MAX_N]; double get_dis(point a, point b){ return sqrt((a.</description></item><item><title>POJ 3311 Hie with the Pie</title><link>https://ptzu.github.io/posts/poj3311/</link><pubDate>Sun, 04 Feb 2018 01:33:35 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3311/</guid><description>題目
input 含多筆測資, 每筆測資開頭輸入 n, 1 &amp;lt;= n &amp;lt;= 10 代表除了起點以外, 有幾個點 接著輸入相鄰矩陣代表點之間的距離
題解 這題規定每個點可不只經過一次 然後 TSP 是限定每個點只能有一次 需要做點小修改
作法 TSP裸題
AC code bottom up 作法
#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 11; int d[MAX_N][MAX_N]; int dp[1 &amp;lt;&amp;lt; MAX_N][MAX_N]; void floyd(int V){ for(int k = 0; k &amp;lt; V; k++){ for(int i = 0; i &amp;lt; V; i++){ for(int j = 0; j &amp;lt; V; j++){ d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } int main(){ int n; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>POJ 2104 K-th Number</title><link>https://ptzu.github.io/posts/poj2104/</link><pubDate>Sun, 28 Jan 2018 12:31:22 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2104/</guid><description>題目
input 給兩正整數 n, m, 1 &amp;lt;= n &amp;lt;= 100000, 1 &amp;lt;= m &amp;lt;= 5000 代表 n 個數字, m 個查詢 第二列輸入 n 個不超過 10^9 的數字 接著每個查詢輸入 l, r, k 代表問區間 [l, r] 的第 k 大數字
題解 給一序列, 然後不斷問不同區間的第 k 大數字 目前看到的作法有 歸併樹、劃分樹、可持久化線段樹(主席樹)、平方分解
作法 離散化 + 主席樹
AC Code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 1990 MooFest</title><link>https://ptzu.github.io/posts/poj1990/</link><pubDate>Wed, 24 Jan 2018 16:13:21 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1990/</guid><description>題目
input 第一列輸入一正整數 N, 1 &amp;lt;= N &amp;lt;= 20000 代表 N 頭牛 接著輸入每頭牛的耳背值 v, 位置 x
題解 有 N 頭牛想互相交談 任兩頭牛交談產生的音量是 max(vi, vj) * 距離 求兩兩交談後產生的總音量是多少
作法 如果直接枚舉就炸了 那我們處理的時候一定是選耳背值最大的那個 所以就從耳背值小到大一個一個處理 在處理第 i 個的時候 我們想知道這頭牛, 左邊有幾頭, 右邊有幾頭？ 也想知道左邊的座標和是多少, 右邊的座標和是多少？ 這時候如果每次都去算一次, 那就跟直接枚舉一樣了 所以就交給 BIT 去算！ num_bit: 代表到 pos[i] 總共有幾頭牛 dis_bit: 代表到 pos[i] 的座標總和
每做完一頭牛記得要把他加入到 BIT 裡
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 3468 A Simple Problem with Integers</title><link>https://ptzu.github.io/posts/poj3468/</link><pubDate>Wed, 24 Jan 2018 10:58:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3468/</guid><description>題目
input 第一列含兩個正整數 N, Q, 1 ≤ N,Q ≤ 100000 分別代表 N 個正整數和 Q 個操作 輸入 N 個整數 A, -1000000000 ≤ A ≤ 1000000000 接著輸入 Q 個操作 有兩種操作
C a b c: 對 a ~ b 範圍加 c Q a b: 查詢 a ~ b 範圍的和 題解 不斷的對區間修改和查詢 跟著做一定會超時 所以用線段樹
作法 線段樹裸題
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 2421 Constructing Roads</title><link>https://ptzu.github.io/posts/poj2421/</link><pubDate>Fri, 12 Jan 2018 13:11:08 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2421/</guid><description>題目
input 第一行輸入正整數 N, 3 &amp;lt;= N &amp;lt;= 100 代表有 N 個村莊 接著輸入一個 N * N 的相鄰矩陣, 代表邊 然後輸入一個正整數 q 接著 q 行輸入 a, b 代表 a, b 之間已經有建好路
題解 建路需要成本, 已經有些路建好 求要連接所有村莊, 最小成本是多少？
作法 求 MST, 不過這題範圍比較小 所以我拿來測試 Sollin 演算法
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;climits&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 3041 Asteroids</title><link>https://ptzu.github.io/posts/poj3041/</link><pubDate>Sat, 06 Jan 2018 11:24:59 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3041/</guid><description>題目
input 第一列輸入兩個正整數 N, K, 代表 N * N 的地圖, 和 K 顆行星
題解 現在你有兩種武器, 分別可以射出橫的或直的射線 被射線射到的行星就會被摧毀 現有 k 顆行星 請問最少要幾次射線才能摧毀全部行星
作法 最小點涵蓋
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 1010; int V; vector &amp;lt;int&amp;gt; g[MAX_V]; int match[MAX_V]; bool vis[MAX_V]; void add_edge(int u, int v){ g[u].</description></item><item><title>POJ 3281 Dining</title><link>https://ptzu.github.io/posts/poj3281/</link><pubDate>Thu, 04 Jan 2018 19:13:50 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3281/</guid><description>題目
input 第一列輸入3個正整數 N, F, D, 1 &amp;lt;= N, F, D &amp;lt;= 100 分別代表 N 頭牛, F 種食物, D 種飲料 接下來 N 行, 每列開頭有兩個正整數 f, d 分別代表那頭牛喜歡的食物, 飲料數量 緊接著輸入他喜歡的食物和飲料
題解 每頭牛有自己喜歡的食物, 飲料種類 若要填飽一頭牛, 他必須要有食物和飲料 每種食物和飲料只能被分配一次(也就是不能分給其他牛) 請問最多有幾頭牛被填飽
作法 最大流經典題 待補圖
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 3259 Wormholes</title><link>https://ptzu.github.io/posts/poj3259/</link><pubDate>Sun, 31 Dec 2017 14:39:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3259/</guid><description>題目
input 含多筆測資, 第一列有一正整數代表接下來有幾筆測資 每筆測資開頭有 3 個正整數 1 &amp;lt;= N &amp;lt;= 500, 1 &amp;lt;= M &amp;lt;= 2500, 1 &amp;lt;= W &amp;lt;= 200 分別代表 N 個點, M 條邊, W 條負邊 接著輸入 M 條邊和 W 條負邊
題解 蟲洞是一條單向路徑, 可以回到過去的時間, 所以等於一條負邊 題目問是否能從一個點開始走, 然後走一走之後, 發現時間比開始的時候還早 那也就是圖中含有負環
作法 可以用 Bellman 或 SPFA 來偵測
AC code #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 1151 - Atlantis</title><link>https://ptzu.github.io/posts/poj1151/</link><pubDate>Sat, 09 Dec 2017 22:18:31 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1151/</guid><description>題目
input 1 &amp;lt;= n &amp;lt;= 100 0 &amp;lt;= x1 &amp;lt; x2 &amp;lt;= 100000, 0 &amp;lt;= y1 &amp;lt; y2 &amp;lt;= 100000
題解 給 n 個矩形, 求所有矩形覆蓋面積
作法 座標範圍有點大, 先離散化 y 軸 然後掃描線掃 x 軸 若掃到某個矩形的 x1, 就將 y1 ~ y2 區間 +1, 反之掃到 x2 就 -1 以每一段的 x 座標為一個區段, 則這一個區段的面積就是 (x軸變化 * y軸被覆蓋的長度) 將所有區段加起來就是答案
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 2386 Lake Counting</title><link>https://ptzu.github.io/posts/poj2386/</link><pubDate>Sat, 18 Nov 2017 13:35:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2386/</guid><description>題目
input 1 &amp;lt;= N, M &amp;lt;= 100
題解 給一個 N X M 的地圖 &amp;lsquo;W&amp;rsquo; 代表有水, &amp;lsquo;.&amp;rsquo; 代表陸地 水的 8 個方向可以互相連接成水塘 請問有幾個水塘
作法 DFS可找出每一塊水塘
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INTf_MAX // const int MAX_N = 100010; char a[200][200]; int n, m; pii dir[] = {{1, 1}, {1, 0}, {1, -1}, {0, 1}, {0, -1}, {-1, 1}, {-1, 0}, {-1, -1}}; bool vis[200][200]; void dfs(int r, int c){ vis[r][c] = true; for(int i = 0; i &amp;lt; 8; i++){ int R = r + dir[i].</description></item><item><title>POJ 2417 Discrete Logging</title><link>https://ptzu.github.io/posts/poj2417/</link><pubDate>Sat, 28 Oct 2017 18:03:04 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2417/</guid><description>題目
input {% math %} 2\leq P&amp;lt; 2^{31},\ 2\leq B&amp;lt; P,\ 1\leq N&amp;lt; P {% endmath %}
題解 求 {%math%} B^{L} \equiv N (mod\ P) {%endmath%} 之 L
作法 BSGS 算法 裸題 這題時限卡蠻緊的, 如果用 int 去轉 long long 會超時 果斷全用 long long了
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;map&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 1258 Agri-Net</title><link>https://ptzu.github.io/posts/poj1258/</link><pubDate>Sun, 01 Oct 2017 17:01:36 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1258/</guid><description>題目
input 含有多筆測資, 每筆測資開頭輸入一正整數 N, 3 &amp;lt;= N &amp;lt;= 100 代表有 N 個農場 接著輸入一個 N * N 的相鄰矩陣, 代表邊
題解 農夫 John 要在農場建立網路, 連接網路電纜需要成本 求連接所有農場的最小成本
作法 Kruskal 裸題
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX struct Union_Find { int par[1010], num[1010]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U; struct edge{ int u, v, w; bool operator &amp;lt;(const edge&amp;amp; e) const{ return w &amp;lt; e.</description></item><item><title>POJ 2342 Anniversary party</title><link>https://ptzu.github.io/posts/poj2342/</link><pubDate>Wed, 27 Sep 2017 18:34:56 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2342/</guid><description>題解 派對中有 n 個員工, 老闆不希望對於某個員工, 他的上司和下屬出現在派對, 每個人都有一個歡樂值, 請問派對中最大的歡樂值總和為多少？
作法 樹型DP, bottom-up dp[i][0] 表第 i 個員工不出席的歡樂值 dp[i][1] 表第 i 個員工出席的歡樂值
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX vector &amp;lt;int&amp;gt; g[6060]; int conviviality[6060]; bool point[6060] ;// 判斷是否有被指向 int n; int dp[6060][2]; void DFS(int x){ for(int i = 0; i &amp;lt; sz(g[x]); i++){ int son = g[x][i]; DFS(son); dp[x][0] += max(dp[son][0], dp[son][1]); dp[x][1] += dp[son][0]; } } int main(){ // fio; // #ifdef DEBUG // printf (&amp;#34;TEST\n&amp;#34;); // #else // printf(&amp;#34;FAIL\n&amp;#34;); // #endif cin &amp;gt;&amp;gt; n; for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;conviviality[i]); dp[i][1] = conviviality[i]; } for(int i = 0; i &amp;lt; n; i++){ int u, v; scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;u, &amp;amp;v); u--;v--; g[v].</description></item><item><title>POJ 3061 Subsequence</title><link>https://ptzu.github.io/posts/poj3061/</link><pubDate>Mon, 18 Sep 2017 11:56:32 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3061/</guid><description>題解 給 n 個元素, 求連續子序列和, 滿足大於等於 S 的最小序列長度
作法 先向右不斷爬行直到和大於等於 S 在和滿足條件的情況下, 減少左端長度 並不斷更新最短長度 如此可在 O(n) 時間內求解
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX vector &amp;lt;int&amp;gt; v; int solve(int N, int S){ int mn = INF; int s = 0, t = 0, sum = 0; for(;;){ while(t &amp;lt; N &amp;amp;&amp;amp; sum &amp;lt; S){ sum += v[t++]; } if(sum &amp;lt; S) break; mn = min(mn, t - s); sum -= v[s++]; } if(mn &amp;gt; N) mn = 0; return mn; } int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ v.</description></item><item><title>POJ 3624 Charm Bracelet</title><link>https://ptzu.github.io/posts/poj3624/</link><pubDate>Wed, 18 Jan 2017 18:08:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3624/</guid><description>題解 01背包問題裸題, 但需要空間優化
作法 dp陣列開成兩條一維, 交替使用
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, m; int dp[2][13000]; int w[3500], d[3500]; int main(){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;m); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;w[i], &amp;amp;d[i]); } for(int i = 0; i &amp;lt; n; i++){ for(int j = 0; j &amp;lt;= m; j++){ if(j &amp;lt; w[i]) dp[(i + 1) &amp;amp; 1][j] = dp[i &amp;amp; 1][j]; else dp[(i + 1) &amp;amp; 1][j] = max(dp[i &amp;amp; 1][j], dp[i &amp;amp; 1][j - w[i]] + d[i]); } } printf(&amp;#34;%d\n&amp;#34;, dp[n &amp;amp; 1][m]); return 0; }</description></item><item><title>POJ 2155 Matrix</title><link>https://ptzu.github.io/posts/poj2155/</link><pubDate>Sun, 11 Dec 2016 23:40:53 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2155/</guid><description>AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; const int MAX_N = 1000; int bit[MAX_N + 10][MAX_N + 10]; int N, T; void add(int a, int b){ for(int i = a; i &amp;lt;= N; i += (i &amp;amp; -i)){ for(int j = b; j &amp;lt;= N; j += (j &amp;amp; -j)){ bit[i][j]++; } } } int sum(int a, int b){ int s = 0; for(int i = a; i &amp;gt; 0; i -= (i &amp;amp; -i)){ for(int j = b; j &amp;gt; 0; j -= (j &amp;amp; -j)){ s += bit[i][j]; } } return s; } int main(){ int TC; scanf(&amp;#34;%d\n&amp;#34;, &amp;amp;TC); while(TC--){ memset(bit, 0, sizeof(bit)); scanf(&amp;#34;%d %d\n&amp;#34;, &amp;amp;N, &amp;amp;T); for(int i = 0; i &amp;lt; T; i++){ char c[3]; scanf(&amp;#34;%s&amp;#34;, c); if(c[0] == &amp;#39;C&amp;#39;){ int x1, y1, x2, y2; scanf(&amp;#34;%d %d %d %d&amp;#34;, &amp;amp;x1, &amp;amp;y1, &amp;amp;x2, &amp;amp;y2); add(x1, y1); add(x2 + 1, y1); add(x1, y2 + 1); add(x2 + 1, y2 + 1); } else{ int x, y; scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;x, &amp;amp;y); printf(&amp;#34;%d\n&amp;#34;, sum(x, y) % 2); } } puts(&amp;#34;&amp;#34;); } return 0; }</description></item><item><title>POJ 1988 Cube Stacking</title><link>https://ptzu.github.io/posts/poj1988/</link><pubDate>Tue, 09 Aug 2016 23:07:00 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1988/</guid><description>題解 現在有 N 個 cube, 每個一開始都是自己一個堆疊 編號為 1 ~ N input 有兩種指令
M a b: 將含有 a 的堆疊放到含有 b 的堆疊上面 C a: 計算在編號 a cube 之下有幾個 cube 作法 算是併查集進階一點的應用 首先定義兩個陣列
num[i]: 以 i 為 root 的集合有幾個 cube under[i]: 在 i 之下有幾個 cube 接著在 unite 中 M 1 2 -&amp;gt; unite(1, 2) 是將 1 加到 2 的集合中 就很當然的 under[a] += num[b] 而 b 集合也會增加數量 num[b] += num[a] 而在 find 中 under+= under[temp] 似乎有點不直覺, 但只要想想一串接很長的集合 這些都是還未經過壓縮的(par不是根) 所以大家的 under 值都是 1 加起來便沒問題了 如果還是不清楚就畫一下圖吧 AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 2236 Wireless Network</title><link>https://ptzu.github.io/posts/poj2236/</link><pubDate>Tue, 09 Aug 2016 21:29:53 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2236/</guid><description>題解 有 N 台壞掉的電腦, 要使他們能重新連通 A 和 B 能連通必須在距離 d 之內, 不過可以透過第三者連接 input 會給每台電腦座標 接著有兩種指令：
O a: 代表修復 a 電腦 S a b: 代表測試 a 和 b 是否連通 作法 用 bool 陣列紀錄哪台電腦已經修復 接著迴圈掃其他電腦, 假如距離 &amp;lt; d 且該電腦已修復 就將他們加到同個集合(併查集, Disjoint Set Union) 當要查詢時就能直接看他們是否在同一個集合啦
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 3046 Ant Counting</title><link>https://ptzu.github.io/posts/poj3046/</link><pubDate>Sat, 09 Jul 2016 23:26:56 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3046/</guid><description>題解 多重背包變形 給定有 T 個不同的家族,及有 A 隻螞蟻(屬於哪個家族) 求利用 T 個家族,及總共S&amp;hellip;B隻螞蟻的情況下 能組出不同組合的數量
作法 分割成子問題,只用前i家族的螞蟻,慢慢推到全部 定義dp[i][j] ： 用前i個家族共j隻螞蟻,能組出不同組合的數量 題目要求只輸出6位數,所以還要取餘數
DP遞迴 dp[i][j] = sum(dp[i-1][j-k]), k為目前i家族所有的螞蟻數量 概念類似排列組合的選取,選i家族：0隻、1隻&amp;hellip;、num[i]隻 那i-1就要用j-k隻(不然怎麼有j隻嘛)
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 1742 Coins</title><link>https://ptzu.github.io/posts/poj1742/</link><pubDate>Sat, 09 Jul 2016 10:11:43 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1742/</guid><description>題解 給定硬幣面額及數量,求在金額 m 以內,可以組出的額度數量作法 可以用多重背包,三層迴圈去解,但會TLE所以我們先把它當成無限背包解,再用一個陣列num去紀錄已使用的硬幣數量時間複雜度：O(nm)兩種DP表格建法 1.若j金額可以,則推廣到j + A[i]
for (int i = 0; i &amp;lt; N; ++i) { fill(num, num+M+1, 0); for (int j = 0; j+A[i] &amp;lt;= M; ++j) if (dp[j] == true &amp;amp;&amp;amp; !dp[j+A[i]] &amp;amp;&amp;amp; num[j] &amp;lt; C[i]) { dp[j+A[i]] = true; num[j+A[i]] = num[j] + 1; } } 2.若j - A[i]可以組出,則金額j也可組出
for(int i = 0; i &amp;lt; n; i++){ memset(num, 0, sizeof(num)); //j從A[i]開始,因為小於A[i]不可能組出 for(int j = A[i]; j &amp;lt;= m; j++){ if(dp[j] == false &amp;amp;&amp;amp; dp[j - A[i]] &amp;amp;&amp;amp; num[j - A[i]] &amp;lt; C[i]){ dp[j] = true; num[j] = num[j - A[i]] + 1; } } } AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 3280 Cheapest Palindrome</title><link>https://ptzu.github.io/posts/poj3280/</link><pubDate>Wed, 06 Jul 2016 19:29:49 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3280/</guid><description>題解 迴文最小成本問題給定字符增添及刪除成本求將字串變成迴文的最小成本作法 字符的增添及刪除本質上是一樣的所以只要存下該字符的增添或刪除成本取最小的dp[i][j]： 代表字串i&amp;hellip;j變成迴文的最小成本遞迴式爲 dp[i][j] = min(dp[i+1][j] + cost, dp[i][j-1] + cost)看處理左邊或右邊哪個好當左右字符一樣時 s[i] == s[j]: 看dp[i+1][j-1] 是否能更小AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int N,M; int cost[30]; int dp[2048][2048]; int main(){ ios::sync_with_stdio(false); cin.</description></item></channel></rss>
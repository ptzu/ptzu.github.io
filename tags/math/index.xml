<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Math on Ptzu's blog</title><link>https://ptzu.github.io/tags/math/</link><description>Recent content in Math on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 13 Mar 2018 16:32:10 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/math/index.xml" rel="self" type="application/rss+xml"/><item><title>POJ 1830 开关问题</title><link>https://ptzu.github.io/posts/poj1830/</link><pubDate>Tue, 13 Mar 2018 16:32:10 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1830/</guid><description>題目
input 输入第一行有一个数K，表示以下有K组测试数据。 每组测试数据的格式如下： 第一行 一个数N（0 &amp;lt; N &amp;lt; 29） 第二行 N个0或者1的数，表示开始时N个开关状态。 第三行 N个0或者1的数，表示操作结束后N个开关的状态。 接下来 每行两个数I J，表示如果操作第 I 个开关，第J个开关的状态也会变化。每组数据以 0 0 结束。
題解 有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。你的目标是经过若干次开关操作后使得最后N个开关达到一个特定的状态。对于任意一个开关，最多只能进行一次开关操作。你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序）
作法 用高斯消去法找自由變數量
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX typedef vector&amp;lt;int&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; int tot; // 自由變數量 void gauss(mat &amp;amp;m){ int n = m.</description></item><item><title>Uva 684 - Integral Determinant</title><link>https://ptzu.github.io/posts/uva684/</link><pubDate>Mon, 12 Mar 2018 01:00:56 +0000</pubDate><guid>https://ptzu.github.io/posts/uva684/</guid><description>題目
input 多筆測資, 每筆測資開頭輸入 n (n &amp;lt;= 30) 代表矩陣大小 接著輸入 n x n 矩陣
題解 求行列式
作法 求行列式
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX typedef vector&amp;lt;ll&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; ll determinant(mat m){ int n = m.</description></item><item><title>Educational Codeforces Round 35</title><link>https://ptzu.github.io/posts/cfedu35/</link><pubDate>Thu, 22 Feb 2018 20:48:46 +0000</pubDate><guid>https://ptzu.github.io/posts/cfedu35/</guid><description>目錄 最小數字最近距離 裝蛋糕使最少塊最多 燈泡週期性 逆序數對奇偶性 A. Nearest Minimums 題目
input 輸入 N (2 ≤ n ≤ 10^5), 代表 array 大小 接著輸入 N 個值
題解 找最小值之間最近的距離
作法 紀錄好值和 index, 排序後去找
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX pii p[101010]; int n; int main(){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); p[i].</description></item><item><title>Codeforces Round 452</title><link>https://ptzu.github.io/posts/cf452/</link><pubDate>Tue, 20 Feb 2018 22:39:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf452/</guid><description>目錄 湊組別 月份日期合法 數字分堆差最小 湊出最多 9 相同數字區間刪除 區間刪除特定字元 A. Splitting in Teams 題目
input 輸入 n (2 ≤ n ≤ 2·10^5) 代表有 n 組 接著輸入每組有幾人 (1 ≤ a ≤ 2)
題解 有 n 組人參加訓練營, 每組有 1 人或 2 人 教練想要組隊參加比賽, 一隊有 3 人 若是一組要參加, 則整組的人都要參加 問最多能湊出幾隊去比賽
作法 兩人一組的一定只能和一人的組別配對 所以先算出這樣可以配出幾隊 然後剩下的一人組別再去湊
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Codeforces Round 447</title><link>https://ptzu.github.io/posts/cf447/</link><pubDate>Sat, 17 Feb 2018 23:43:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf447/</guid><description>目錄 窮舉 方格填數 A. QAQ 題目
input 輸入一字串 s
題解 QAQ 代表哭臉 給一字串, 求有幾個 QAQ (不必相連)
作法 窮舉
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 100010; int main(){ string s; cin &amp;gt;&amp;gt; s; int cnt = 0; for(int i = 0; i &amp;lt; s.</description></item><item><title>POJ 2299 Ultra-QuickSort</title><link>https://ptzu.github.io/posts/poj2299/</link><pubDate>Thu, 15 Feb 2018 21:13:37 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2299/</guid><description>題目
input 有多筆測資, 每筆第一列輸入 n (n &amp;lt; 500,000) 接著輸入 n 個數
題解 給一數列做排序 只能相鄰數字做交換 請問要交換幾次才能完成排序 即為求逆序數對個數
作法 Merge Sort 求逆序數對
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 505050; int a[MAX_N]; ll ans; void Merge(int l, int m, int r){ vector &amp;lt;int&amp;gt; temp; int idx1 = l, idx2 = m + 1; while(idx1 &amp;lt;= m &amp;amp;&amp;amp; idx2 &amp;lt;= r){ if(a[idx1] &amp;lt;= a[idx2]){ temp.</description></item><item><title>POJ 2084 Game of Connections</title><link>https://ptzu.github.io/posts/poj2084/</link><pubDate>Sat, 10 Feb 2018 14:41:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2084/</guid><description>題目
input 多筆測資, 每筆輸入 n, 1 &amp;lt;= n &amp;lt;= 100 輸入 -1 結束測資
題解 有 2 * n 個點順時針排序, 任兩點連線, 但線不准交叉 求有幾種連法
作法 卡塔蘭數 固定點 1, 向周圍的點畫線 可以把圖分成左右兩塊, 左右兩塊的點數都是偶數(因為奇數必不能兩兩互連) 我們可以得到以下結論 h(0) = 1,h(1) = 1 遞迴式：
h(n) = h(0)*h(n-1) + h(1)*h(n-2) + &amp;hellip; + h(n-1)h(0) (其中 n &amp;gt;= 2) 即為卡塔蘭數
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 10007 - Count the Trees</title><link>https://ptzu.github.io/posts/uva10007/</link><pubDate>Fri, 09 Feb 2018 22:17:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10007/</guid><description>題目
input 多筆測資, 每筆測資輸入 n, 1 &amp;lt;= n &amp;lt;= 300 代表 n 個結點 輸入 0 測資結束
題解 給 n 個點求有幾種不同結構的二元樹 因為不同數字也算不同, 所以再乘上 n!
作法 卡塔蘭數 + 大數
AC code import java.util.Scanner; import java.math.BigInteger; import java.util.*; public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); BigInteger[] fac = new BigInteger[601]; fac[0] = fac[1] = BigInteger.ONE; for(int i = 2; i &amp;lt;= 600; i++) fac[i] = fac[i - 1].</description></item><item><title>Uva 10041 - Vito's Family</title><link>https://ptzu.github.io/posts/uva10041/</link><pubDate>Fri, 22 Dec 2017 09:03:09 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10041/</guid><description>題目
input 含有多筆測資, 每筆測資開頭有一正整數 r, 0 &amp;lt; r &amp;lt;= 500 接著有 r 個正整數 s, 0 &amp;lt; s &amp;lt; 30000
題解 想找一間房子離其它親戚最近
作法 到其它點的距離和最小, 找中位數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int a[1000]; int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); } sort(a, a + n); int mid = a[n / 2]; int ans = 0; for(int i = 0; i &amp;lt; n; i++) ans += abs(mid - a[i]); printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; }</description></item><item><title>Uva 10057 - A mid-summer night's dream.</title><link>https://ptzu.github.io/posts/uva10057/</link><pubDate>Mon, 18 Dec 2017 21:40:11 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10057/</guid><description>題目
input 含有多筆測資, 每筆測資開頭有一正整數 N 接著有 N 個數, 每個數不超過65536
題解 找出一個數, 使它與其他數的絕對值差, 總和最小 輸出符合條件最小的數, 以及 input 中有幾個這樣的數, 還有所有符合條件的數(含input以外的數)
作法 找中位數, 當有偶數個的時候, 兩個中位數之間的數也都符合條件
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 1000000; int v[1000010]; int main(){ int n; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>POJ 2417 Discrete Logging</title><link>https://ptzu.github.io/posts/poj2417/</link><pubDate>Sat, 28 Oct 2017 18:03:04 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2417/</guid><description>題目
input {% math %} 2\leq P&amp;lt; 2^{31},\ 2\leq B&amp;lt; P,\ 1\leq N&amp;lt; P {% endmath %}
題解 求 {%math%} B^{L} \equiv N (mod\ P) {%endmath%} 之 L
作法 BSGS 算法 裸題 這題時限卡蠻緊的, 如果用 int 去轉 long long 會超時 果斷全用 long long了
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;map&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>BSGS 演算法</title><link>https://ptzu.github.io/posts/bsgs-algorithm/</link><pubDate>Sat, 28 Oct 2017 13:25:28 +0000</pubDate><guid>https://ptzu.github.io/posts/bsgs-algorithm/</guid><description>BSGS 原名Baby Steps Giant Steps，又名大小步算法 用途是用來解離散對數, {% math %} a^{x}\equiv b\left( mod\ p\right) {% endmath %} 求最小 x 的解
步驟為
令 {% math %} x=im-j {% endmath %} {% math %} m = \left \lceil \sqrt{p} \right \rceil {% endmath %} {% math %} a^{im-j} \equiv b(mod\ p) {% endmath %} 移項 {% math %} a^{im} \equiv a^{j}b(mod\ p) {% endmath %} 對於 {% math %} a^{j}b {% endmath %} 列舉 0 ~ m 存起來 再對於 {% math %} a^{im} {% endmath %} 列舉 1 ~ m 對於第一個符合方程式的 i, j 即為所求, 代回去可得到 x 問題與證明 何時無解？ 有解必須滿足費馬小定理, p 為質數, 且 gcd(a, p) = 1</description></item><item><title>求取循環節長度</title><link>https://ptzu.github.io/posts/repeatingdecimal/</link><pubDate>Sat, 28 Oct 2017 11:01:11 +0000</pubDate><guid>https://ptzu.github.io/posts/repeatingdecimal/</guid><description>任何有理數 p / q 皆可以用循環小數來表示 像是 1 / 3 = 0.33333&amp;hellip; 1 / 4 = 0.25000&amp;hellip;
以下介紹一些定理以及方法 來求取 非循環節 以及 循環節
定理 不循環節長度 - 2 / 5 定理： 分母拆解成 2 和 5 的乘積, 長度 = max(num_2, num_5);
循環節長度: 如果 b 沒有 2 or 5 的質因數, 且 a, b 互質 則 a / b 的循環節長度為: {% math %} \min { e\in N,10^{e}\equiv 1(mod\ b) } {% endmath %} 然後我們就可以用 BSGS 演算法來求出 e</description></item><item><title>Codeforces Round 443</title><link>https://ptzu.github.io/posts/cf443/</link><pubDate>Fri, 27 Oct 2017 17:05:13 +0000</pubDate><guid>https://ptzu.github.io/posts/cf443/</guid><description>目錄 模擬題 模擬題 位元操作 A. Borya&amp;rsquo;s Diagnosis 題目
input 1 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= s, d &amp;lt;= 1000
題解 Borya 要依序看 n 個醫生 每個醫生只在 si, si + di &amp;hellip; 的日子營業 請問最快要幾天才能看完所有醫生
作法 模擬題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 369 - Combinations</title><link>https://ptzu.github.io/posts/uva369/</link><pubDate>Wed, 25 Oct 2017 19:44:07 +0000</pubDate><guid>https://ptzu.github.io/posts/uva369/</guid><description>題目
input 5 &amp;lt;= N &amp;lt;= M &amp;lt;= 100
題解 求 C N 取 M
作法 帕斯卡三角形
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; ll pascal[110][110]; void init(){ } int main(){ int N, M; pascal[1][0] = 1; pascal[1][1] = 1; for(int i = 2; i &amp;lt;= 100; i++){ pascal[i][0] = 1; for(int j = 1; j &amp;lt; i; j++){ pascal[i][j] = pascal[i - 1][j] + pascal[i - 1][j - 1]; } pascal[i][i] = 1; } while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;N, &amp;amp;M) !</description></item><item><title>Uva 374 - Big Mod</title><link>https://ptzu.github.io/posts/uva374/</link><pubDate>Wed, 25 Oct 2017 07:29:49 +0000</pubDate><guid>https://ptzu.github.io/posts/uva374/</guid><description>題目
input 0 &amp;lt;= B, P, M &amp;lt;= 2147483647
題解 求出 B^P % M
作法 利用快速冪即可, 可參考 求取指數完整題型 包含大數指數, 以及底數和指數都是大數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 30000010; void init(){ } ll fastpow(ll B, ll P, ll M){ ll base = B, ans = 1; while(P){ if(P &amp;amp; 1) ans = ans * base % M; base = base * base % M; P &amp;gt;&amp;gt;= 1; } return ans; } int main(){ ll B, P, M; while(scanf(&amp;#34;%lld%lld%lld&amp;#34;, &amp;amp;B, &amp;amp;P, &amp;amp;M) !</description></item><item><title>Uva 12716 - GCD XOR</title><link>https://ptzu.github.io/posts/uva12716/</link><pubDate>Mon, 23 Oct 2017 23:13:31 +0000</pubDate><guid>https://ptzu.github.io/posts/uva12716/</guid><description>題目
input T &amp;lt;= 10000 1 &amp;lt;= N &amp;lt;= 30000000
題解 求所有 GCD(A,B) = A XOR B 的pair數量, 對於 1 &amp;lt;= B &amp;lt;= A &amp;lt;= N
作法 首先有幾點必須先知道:
a XOR b &amp;gt;= (a - b) 以二進位來說, 一個 bit 為0, 一個 bit 為1 在 XOR 時為 1, 但是減法卻還要借位 而其他情況都相同, 所以可以肯定 a XOR b &amp;gt;= (a - b) 令GCD(a,b) = a ^ b = c 因為 a, b 的最大公因數為 c 所以可以寫成 a = k1 * c, b = k2 * c, k1 &amp;gt;= k2 a - b = (k1 - k2) * c, 所以 a - b &amp;gt;= c 結合以上兩點, 可以得到 (a - b) &amp;lt;= c &amp;lt;= (a - b) 根據夾擠定理, c = a - b 接著我們要列舉所有可能 a - b = c, 又 GCD(a,b) = c, 所以 a 可以寫成 k * c (k &amp;gt;= 2) 而 b 可以從 a - c 得到 這樣就可以找出所有 pair</description></item><item><title>大數取 MOD</title><link>https://ptzu.github.io/posts/bigint-mod/</link><pubDate>Mon, 09 Oct 2017 08:40:40 +0000</pubDate><guid>https://ptzu.github.io/posts/bigint-mod/</guid><description>Code ll getMod(string s, ll mod){ ll r = 0; for(char c : s) r = (r * 10 + c - &amp;#39;0&amp;#39;) % mod; return r; }</description></item><item><title>Codeforces Round 407</title><link>https://ptzu.github.io/posts/cf407/</link><pubDate>Thu, 30 Mar 2017 16:32:28 +0000</pubDate><guid>https://ptzu.github.io/posts/cf407/</guid><description>目錄 微動腦實作 math 最大連續區間和變形 A. Anastasia and pebbles 題目
input n 種石頭, 口袋能放 k 個: 1 ≤ n ≤ 10^5, 1 ≤ k ≤ 10^9 石頭數量 w1&amp;hellip;wn: 1 ≤ wi ≤ 10^4
題解 Anastasia 決定在公園裡蒐集石頭 他有兩個口袋, 每個口袋可以放 k 個石頭 公園裡有 n 種石頭, 第 i 種石頭有 wi 個 在同一個口袋不能放不同種類的石頭 她一天只能來公園蒐集一次石頭(兩個口袋滿) 請問要幾天才能蒐集完公園裡全部石頭？
作法 由於每次只能裝 k 個, 而且不能混別種石頭 所以就每 k 個當作一堆, 每天能裝 2 堆 看要幾天
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Codeforces Round 382 (Div. 2)</title><link>https://ptzu.github.io/posts/cf382/</link><pubDate>Wed, 15 Feb 2017 23:25:08 +0000</pubDate><guid>https://ptzu.github.io/posts/cf382/</guid><description>目錄 A. 實作題 B. greedy C. fibunacci D. 哥德巴赫猜想
A. Ostap and Grasshopper 題目
input n 個 cell: 2 &amp;lt;= n &amp;lt;= 100 蚱蜢一次跳 k 步： 1 &amp;lt;= k &amp;lt;= n - 1
題解 &amp;ldquo;.&amp;rdquo; 代表空的cell, &amp;ldquo;#&amp;rdquo; 代表障礙, &amp;ldquo;G&amp;rdquo; 代表蚱蜢, &amp;ldquo;T&amp;rdquo; 代表目標 問能否達到目標
作法 實作題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int n, k; int main(){ // ios::sync_with_stdio(false); // cin.</description></item><item><title>Codeforces Round 384 (Div. 2)</title><link>https://ptzu.github.io/posts/cf384/</link><pubDate>Thu, 02 Feb 2017 20:21:21 +0000</pubDate><guid>https://ptzu.github.io/posts/cf384/</guid><description>C. Vladik and fractions 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); if(n == 1){ printf(&amp;#34;-1\n&amp;#34;); return 0; } for(int i = 1; i &amp;lt;= 1e8; i++){ ll up = 2 * i - 1; ll down = n * i; ll x, y; if(up % 2 == 1){ x = up / 2; y = up / 2 + 1; } if(x &amp;gt; 1e9 || y &amp;gt; 1e9 || down &amp;gt; 1e9) break; if(x * y == down){ printf(&amp;#34;%lld %lld %lld\n&amp;#34;, x, y, down); return 0; } } printf(&amp;#34;-1\n&amp;#34;); return 0; }</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Knapsack on Ptzu's blog</title><link>https://ptzu.github.io/tags/knapsack/</link><description>Recent content in Knapsack on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 02 Feb 2018 19:16:02 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/knapsack/index.xml" rel="self" type="application/rss+xml"/><item><title>Uva 562 - Dividing coins</title><link>https://ptzu.github.io/posts/uva562/</link><pubDate>Fri, 02 Feb 2018 19:16:02 +0000</pubDate><guid>https://ptzu.github.io/posts/uva562/</guid><description>題目
input 第一列輸入 Test Case 每筆測資開頭輸入 n, 表有 n 種硬幣 接著輸入 n 種硬幣
題解 兩人分錢
作法 要使差距最小, 那就是愈接近一半愈好 把金額當作背包, 使得背包裡的價值愈大愈好
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 60000; int n; int a[110]; int dp[50505]; int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(dp, 0, sizeof(dp)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); int sum = 0; for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); sum += a[i]; } int m = sum / 2; for(int i = 0; i &amp;lt; n; i++){ for(int j = m; j &amp;gt;= a[i]; j--) dp[j] = max(dp[j], dp[j - a[i]] + a[i]); } printf(&amp;#34;%d\n&amp;#34;, (sum - dp[m]) - dp[m]); } return 0; }</description></item><item><title>Uva 10130 - SuperSale</title><link>https://ptzu.github.io/posts/uva10130/</link><pubDate>Thu, 30 Nov 2017 11:51:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10130/</guid><description>題目
input 1 &amp;lt;= T, N &amp;lt;= 1000 1 &amp;lt;= P &amp;lt;= 100 1 &amp;lt;= W &amp;lt;= 30 1 &amp;lt;= 背包容量 &amp;lt;= 30
題解 給 n 個物品, 每個物品有價格和重量 每個人最多可以帶 MW 重量 每個人對某個物品最多只能拿一次 求全部人可以買多少價格的商品
作法 01背包問題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int V[1010], W[1010]; int dp[100], n; void solve(){ // 如果迴圈從重量開始, 會導致少算一些價值 // 例如求容量為 90 的最大價值, 可以放入重量 30, 60的物品 // 但是我們只會放入其中一個, 因為不管是 dp[90 - 30], dp[90 - 60] 都還沒計算 // 若迴圈從物品開始, 我們就可以計算每個容量的最大價值 // 可能有個疑問, 為什麼迴圈重量不從 0 開始跑就好, 這樣每個重量也都會被先計算阿？ // 因為這樣就變成多重背包問題(每個物品可以選不只一次)了=w= // for(int i = 99; i &amp;gt;= 0; i--){ // for(int j = 0; j &amp;lt; n; j++){ // if(i &amp;gt;= W[j]){ // dp[i] = max(dp[i], dp[i - W[j]] + V[j]); // } // } // } for(int i = 0; i &amp;lt; n; i++){ for(int j = 99; j &amp;gt;= W[i]; j--){ dp[j] = max(dp[j], dp[j - W[i]] + V[i]); } } } int main(){ int TC; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); while(TC--){ memset(dp, 0, sizeof(dp)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;V[i], &amp;amp;W[i]); } solve(); int G; scanf(&amp;#34;%d&amp;#34;, &amp;amp;G); int ans = 0; for(int i = 0; i &amp;lt; G; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); ans += dp[x]; } printf(&amp;#34;%d\n&amp;#34;, ans); } return 0; }</description></item><item><title>POJ 3624 Charm Bracelet</title><link>https://ptzu.github.io/posts/poj3624/</link><pubDate>Wed, 18 Jan 2017 18:08:24 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3624/</guid><description>題解 01背包問題裸題, 但需要空間優化
作法 dp陣列開成兩條一維, 交替使用
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int n, m; int dp[2][13000]; int w[3500], d[3500]; int main(){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;m); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;w[i], &amp;amp;d[i]); } for(int i = 0; i &amp;lt; n; i++){ for(int j = 0; j &amp;lt;= m; j++){ if(j &amp;lt; w[i]) dp[(i + 1) &amp;amp; 1][j] = dp[i &amp;amp; 1][j]; else dp[(i + 1) &amp;amp; 1][j] = max(dp[i &amp;amp; 1][j], dp[i &amp;amp; 1][j - w[i]] + d[i]); } } printf(&amp;#34;%d\n&amp;#34;, dp[n &amp;amp; 1][m]); return 0; }</description></item><item><title>POJ 3046 Ant Counting</title><link>https://ptzu.github.io/posts/poj3046/</link><pubDate>Sat, 09 Jul 2016 23:26:56 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3046/</guid><description>題解 多重背包變形 給定有 T 個不同的家族,及有 A 隻螞蟻(屬於哪個家族) 求利用 T 個家族,及總共S&amp;hellip;B隻螞蟻的情況下 能組出不同組合的數量
作法 分割成子問題,只用前i家族的螞蟻,慢慢推到全部 定義dp[i][j] ： 用前i個家族共j隻螞蟻,能組出不同組合的數量 題目要求只輸出6位數,所以還要取餘數
DP遞迴 dp[i][j] = sum(dp[i-1][j-k]), k為目前i家族所有的螞蟻數量 概念類似排列組合的選取,選i家族：0隻、1隻&amp;hellip;、num[i]隻 那i-1就要用j-k隻(不然怎麼有j隻嘛)
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>POJ 1742 Coins</title><link>https://ptzu.github.io/posts/poj1742/</link><pubDate>Sat, 09 Jul 2016 10:11:43 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1742/</guid><description>題解 給定硬幣面額及數量,求在金額 m 以內,可以組出的額度數量作法 可以用多重背包,三層迴圈去解,但會TLE所以我們先把它當成無限背包解,再用一個陣列num去紀錄已使用的硬幣數量時間複雜度：O(nm)兩種DP表格建法 1.若j金額可以,則推廣到j + A[i]
for (int i = 0; i &amp;lt; N; ++i) { fill(num, num+M+1, 0); for (int j = 0; j+A[i] &amp;lt;= M; ++j) if (dp[j] == true &amp;amp;&amp;amp; !dp[j+A[i]] &amp;amp;&amp;amp; num[j] &amp;lt; C[i]) { dp[j+A[i]] = true; num[j+A[i]] = num[j] + 1; } } 2.若j - A[i]可以組出,則金額j也可組出
for(int i = 0; i &amp;lt; n; i++){ memset(num, 0, sizeof(num)); //j從A[i]開始,因為小於A[i]不可能組出 for(int j = A[i]; j &amp;lt;= m; j++){ if(dp[j] == false &amp;amp;&amp;amp; dp[j - A[i]] &amp;amp;&amp;amp; num[j - A[i]] &amp;lt; C[i]){ dp[j] = true; num[j] = num[j - A[i]] + 1; } } } AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;ctime&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;functional&amp;gt; // greater&amp;lt;T&amp;gt;#include &amp;lt;numeric&amp;gt; // for accumulate#include &amp;lt;string&amp;gt;#include &amp;lt;deque&amp;gt;#include &amp;lt;sstream&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Segment Tree on Ptzu's blog</title><link>https://ptzu.github.io/tags/segment-tree/</link><description>Recent content in Segment Tree on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 28 Mar 2018 21:10:33 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/segment-tree/index.xml" rel="self" type="application/rss+xml"/><item><title>TIOJ 1224 矩形覆蓋面積計算</title><link>https://ptzu.github.io/posts/tioj1224/</link><pubDate>Wed, 28 Mar 2018 21:10:33 +0000</pubDate><guid>https://ptzu.github.io/posts/tioj1224/</guid><description>題目
input 輸入檔只包含一筆測試資料。 第一列有一個正整數n(1&amp;lt;=n&amp;lt;=100,000)，代表有n個矩形。 接下來有n列，每列有四個整數 L,R,D,U(0&amp;lt;=L&amp;lt;R&amp;lt;=1,000,000；0&amp;lt;=D&amp;lt;U&amp;lt;=1,000,000)代表矩形的左、右、下、上四個邊界座標。
題解 給你很多平面上的矩形，請求出它們覆蓋的總表面積。
作法 和 POJ 1151相同
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX struct line{ int pos, y1, y2, type; bool operator &amp;lt;(const line&amp;amp; a)const{ return pos &amp;lt; a.</description></item><item><title>Codeforces Round 452</title><link>https://ptzu.github.io/posts/cf452/</link><pubDate>Tue, 20 Feb 2018 22:39:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf452/</guid><description>目錄 湊組別 月份日期合法 數字分堆差最小 湊出最多 9 相同數字區間刪除 區間刪除特定字元 A. Splitting in Teams 題目
input 輸入 n (2 ≤ n ≤ 2·10^5) 代表有 n 組 接著輸入每組有幾人 (1 ≤ a ≤ 2)
題解 有 n 組人參加訓練營, 每組有 1 人或 2 人 教練想要組隊參加比賽, 一隊有 3 人 若是一組要參加, 則整組的人都要參加 問最多能湊出幾隊去比賽
作法 兩人一組的一定只能和一人的組別配對 所以先算出這樣可以配出幾隊 然後剩下的一人組別再去湊
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>ZOJ 2112 Dynamic Rankings</title><link>https://ptzu.github.io/posts/zoj2112/</link><pubDate>Fri, 02 Feb 2018 12:16:07 +0000</pubDate><guid>https://ptzu.github.io/posts/zoj2112/</guid><description>題目
input 題解 作法 帶修改的主席樹
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 60000; int N, M, SZ, cnt; int a[MAX_N + 10]; vector &amp;lt;int&amp;gt; pool; struct node{ int l, r, val; }T[MAX_N * 40]; int root[MAX_N + 10], BIT[MAX_N + 10], use[MAX_N]; struct q{ int type, l, r, k; }Q[10010]; void init(){ cnt = 0; pool.</description></item><item><title>POJ 2104 K-th Number</title><link>https://ptzu.github.io/posts/poj2104/</link><pubDate>Sun, 28 Jan 2018 12:31:22 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2104/</guid><description>題目
input 給兩正整數 n, m, 1 &amp;lt;= n &amp;lt;= 100000, 1 &amp;lt;= m &amp;lt;= 5000 代表 n 個數字, m 個查詢 第二列輸入 n 個不超過 10^9 的數字 接著每個查詢輸入 l, r, k 代表問區間 [l, r] 的第 k 大數字
題解 給一序列, 然後不斷問不同區間的第 k 大數字 目前看到的作法有 歸併樹、劃分樹、可持久化線段樹(主席樹)、平方分解
作法 離散化 + 主席樹
AC Code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 3468 A Simple Problem with Integers</title><link>https://ptzu.github.io/posts/poj3468/</link><pubDate>Wed, 24 Jan 2018 10:58:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3468/</guid><description>題目
input 第一列含兩個正整數 N, Q, 1 ≤ N,Q ≤ 100000 分別代表 N 個正整數和 Q 個操作 輸入 N 個整數 A, -1000000000 ≤ A ≤ 1000000000 接著輸入 Q 個操作 有兩種操作
C a b c: 對 a ~ b 範圍加 c Q a b: 查詢 a ~ b 範圍的和 題解 不斷的對區間修改和查詢 跟著做一定會超時 所以用線段樹
作法 線段樹裸題
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>POJ 1151 - Atlantis</title><link>https://ptzu.github.io/posts/poj1151/</link><pubDate>Sat, 09 Dec 2017 22:18:31 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1151/</guid><description>題目
input 1 &amp;lt;= n &amp;lt;= 100 0 &amp;lt;= x1 &amp;lt; x2 &amp;lt;= 100000, 0 &amp;lt;= y1 &amp;lt; y2 &amp;lt;= 100000
題解 給 n 個矩形, 求所有矩形覆蓋面積
作法 座標範圍有點大, 先離散化 y 軸 然後掃描線掃 x 軸 若掃到某個矩形的 x1, 就將 y1 ~ y2 區間 +1, 反之掃到 x2 就 -1 以每一段的 x 座標為一個區段, 則這一個區段的面積就是 (x軸變化 * y軸被覆蓋的長度) 將所有區段加起來就是答案
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>資料結構 － Segment Tree</title><link>https://ptzu.github.io/posts/segment-tree/</link><pubDate>Sun, 04 Dec 2016 20:09:49 +0000</pubDate><guid>https://ptzu.github.io/posts/segment-tree/</guid><description>用途 多筆區間查詢時, 如果有某點被更新, 則每次都要O(n)重新計算 這樣非常耗時, 因此有了線段樹這個資料結構
變數定義 N: input 個數 NN: 恰好大於 N 的 2次方 seg[]: 線段樹陣列
圖解 以 N = 7 為例子(不是2的指數次) input 為 1, 2, 3 ,4, 5, 6, 7
init #build (建構線段樹) 參數說明: idx 為 該區塊在 seg[]陣列中實際的index 合併 建構完成！</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Codeforces on Ptzu's blog</title><link>https://ptzu.github.io/tags/codeforces/</link><description>Recent content in Codeforces on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 24 Sep 2018 10:40:17 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/codeforces/index.xml" rel="self" type="application/rss+xml"/><item><title>對極幾何 Epipolar Geometry</title><link>https://ptzu.github.io/posts/epipolar-geometry/</link><pubDate>Mon, 24 Sep 2018 10:40:17 +0000</pubDate><guid>https://ptzu.github.io/posts/epipolar-geometry/</guid><description>對於一個場景, 透過兩個位置不同的相機觀看 這兩幅圖像之間會有一些點對應關係 整張圖所形成的幾何關係稱為 Epipolar Gemometry 如下圖: 兩個相機中心分別為 {%math%} O_{1},\ O_{2} {%endmath%} 三維世界座標點 {%math%} P {%endmath%} 在兩個像平面 {%math%} A_{1},\ A_{2} {%endmath%} 投影的點為 {%math%} p_{1},\ p_{2} {%endmath%} 而 {%math%} P,\ O_{1}\ O_{2} {%endmath%} 三點所形成的平面稱為極平面(Epipolar plane) {%math%} O_{1}O_{2} {%endmath%}稱為基線(Baseline), 穿越兩個像平面的點分別為 {%math%} e_{1},\ e_{2} {%endmath%} 稱為極點(Epipoles) 投影點與極點連成的線稱為極線(Epipolar Line): {%math%} l_{1},\ l_{2} {%endmath%}
我們可以透過兩幀圖像之間的特徵點對應, 進而求出相機的運動
推導 設點三維做標點 {%math%} P=[X,Y,Z]^{T} {%endmath%} 對於兩個投影點 {%math%} s_{1}p_{1}=KP\s_{2}p_{2}=K(RP+t) {%endmath%} K 是內參矩陣 若是用齊次座標, 可以將 s 去除, 因為常數項不影響 接著我們覺得 K 有點麻煩, 所以我們用歸一化座標 {%math%} x_{1}=K^{-1}p_{1},\ x_{2}=K^{-1}p_{2} {%endmath%} 看公式可以知道這東西其實就是 P 而我們不想透過 K 來得到投影點座標 反而是直接假設有一個距離相機 z = 1 的平面 投影在上面的座標為: {%math%} P=\begin{bmatrix} \frac{X}{Z}\ \frac{Y}{Z}\ 1 \end{bmatrix} {%endmath%} 來得到二維座標 我們可以得到這樣的關係: {%math%} x_{2}=Rx_{1} + t {%endmath%} 接下來就是數學的一些變換: 兩邊同時乘上 {%math%} \hat{t} {%endmath%}, 相當於與 t 做外積 {%math%} \hat{t}x_{2}=\hat{t}Rx_{1} {%endmath%} 上面的 t 因為和自己做外積, 所以消失了 接著左乘 {%math%} x_{2}^{T} {%endmath%} 因為 {%math%} \hat{t}x_{2} {%endmath%} 是一個和 {%math%} t,\ x_{2} {%endmath%} 垂直的向量 再和{%math%} x_{2} {%endmath%} 做內積就會是 0 得到以下式子: {%math%} x_{2}^{T}\hat{t}Rx_{1} = 0 {%endmath%} 此式就稱為 對極約束(Epipolar Constraint) 代入 {%math%} p_{1}, p_{2} {%endmath%} {%math%} p_{2}^{T}K^{-T}\hat{t}RK^{-1}p_{1} = 0 {%endmath%} 幾何意義是 {%math%} P,\ O_{1},\ O_{2} {%endmath%} 共平面 將 {%math%} \hat{t}R {%endmath%} 令成 E, 這東西就稱為本質矩陣(Essential Matrix) 若是有包含內參, 就是基本矩陣(Fundamental Matrix) {%math%} E=\hat{t}R,\ F=K^{-T}EK^{-1} {%endmath%} 進一步簡化約束式: {%math%} x_{2}^{T}Ex_{1}=p_{2}^{T}Fp_{1}=0 {%endmath%}</description></item><item><title>CMake 搜尋函式庫 find_package()</title><link>https://ptzu.github.io/posts/cmake-find-package/</link><pubDate>Fri, 14 Sep 2018 10:29:17 +0000</pubDate><guid>https://ptzu.github.io/posts/cmake-find-package/</guid><description>最近使用 CMake 時 使用到了 OpenCV 這個庫 不過因為我電腦裡面有兩個版本 一個是 ROS 自裝的, 一個是自己編譯好的 他一直找到舊版本的函式庫 於是自己就好奇他是如何找到的
當我們呼叫 find_package(套件) 時, 他會從以下步驟搜尋 Find.cmake 檔
從 ${CMAKE_MODULE_PATH} 這個變數中的路徑去搜尋 通常這個是 project 中的 cmake 資料夾 如果找不到, 會到 cmake 中的模組搜尋, 路徑通常是 /usr/share/cmake-x.y/Modules 最後一種是套件安裝時, 會在他自己的資料夾產生 .cmake 檔讓別人搜尋, 稱為配置模式, 尋找 Config.cmake 當找到 .cmake 檔時 會配置以下變數
&amp;lt;NAME&amp;gt;_FOUND &amp;lt;NAME&amp;gt;_INCLUDE_DIRS or &amp;lt;NAME&amp;gt;_INCLUDES &amp;lt;NAME&amp;gt;_LIBRARIES or &amp;lt;NAME&amp;gt;_LIBRARIES or &amp;lt;NAME&amp;gt;_LIBS &amp;lt;NAME&amp;gt;_DEFINITIONS 以 OpenCV 為例, 就會先在模組找 FindOpenCV.cmake 找不到再去找 OpenCVConfig.cmake
參考 https://blog.csdn.net/u011092188/article/details/61425924 https://blog.csdn.net/haluoluo211/article/details/80559341</description></item><item><title>Codeforces Good Bye 2017</title><link>https://ptzu.github.io/posts/cfgb2017/</link><pubDate>Fri, 23 Feb 2018 00:48:39 +0000</pubDate><guid>https://ptzu.github.io/posts/cfgb2017/</guid><description>目錄 若 p 則 q 給指令走路 盤子下降 A. New Year and Counting Cards 題目
input 輸入一字串 s (1 &amp;lt;= |s| &amp;lt;= 50) 每個字代表這張卡可以看到的字母
題解 現有 n 張卡 有一敘述: 若一面是 &amp;ldquo;a,e,i,o,u&amp;rdquo; 則另一面是 &amp;ldquo;0,2,4,6,8&amp;rdquo; 目前可以看到這些卡的一面, 若想確定這敘述是對的 最少需要翻開幾張卡看另一面？
作法 當敘述為真, 有兩種情況 p =&amp;gt; q 或是 not q =&amp;gt; not p 所以若是看到 p 或 not q, 則要翻開另一面確認
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Educational Codeforces Round 35</title><link>https://ptzu.github.io/posts/cfedu35/</link><pubDate>Thu, 22 Feb 2018 20:48:46 +0000</pubDate><guid>https://ptzu.github.io/posts/cfedu35/</guid><description>目錄 最小數字最近距離 裝蛋糕使最少塊最多 燈泡週期性 逆序數對奇偶性 A. Nearest Minimums 題目
input 輸入 N (2 ≤ n ≤ 10^5), 代表 array 大小 接著輸入 N 個值
題解 找最小值之間最近的距離
作法 紀錄好值和 index, 排序後去找
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX pii p[101010]; int n; int main(){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); p[i].</description></item><item><title>Codeforces Round 455</title><link>https://ptzu.github.io/posts/cf455/</link><pubDate>Wed, 21 Feb 2018 22:09:31 +0000</pubDate><guid>https://ptzu.github.io/posts/cf455/</guid><description>目錄 組成字典序最小字串 線段重疊 Python語法 分堆刪除 A. Generate Login 題目
input 輸入一字串 s (1 &amp;lt;= |s| &amp;lt;= 10) 包含 first name, last name
題解 first name, last name 各取 prefix (不可為空), 組成一字串 求字典序最小的字串
作法 暴力法列舉
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ fio; string s1, s2; cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2; string ans = s1 + s2; string temp; for(int i = 0; i &amp;lt; s1.</description></item><item><title>Codeforces Round 452</title><link>https://ptzu.github.io/posts/cf452/</link><pubDate>Tue, 20 Feb 2018 22:39:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf452/</guid><description>目錄 湊組別 月份日期合法 數字分堆差最小 湊出最多 9 相同數字區間刪除 區間刪除特定字元 A. Splitting in Teams 題目
input 輸入 n (2 ≤ n ≤ 2·10^5) 代表有 n 組 接著輸入每組有幾人 (1 ≤ a ≤ 2)
題解 有 n 組人參加訓練營, 每組有 1 人或 2 人 教練想要組隊參加比賽, 一隊有 3 人 若是一組要參加, 則整組的人都要參加 問最多能湊出幾隊去比賽
作法 兩人一組的一定只能和一人的組別配對 所以先算出這樣可以配出幾隊 然後剩下的一人組別再去湊
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Codeforces Round 451</title><link>https://ptzu.github.io/posts/cf451/</link><pubDate>Tue, 20 Feb 2018 11:56:25 +0000</pubDate><guid>https://ptzu.github.io/posts/cf451/</guid><description>目錄 四捨五入 花費組合 電話簿清除後綴字串 鬧鐘關閉滑動視窗 A. Rounding 題目
input 輸入 n (0 ≤ n ≤ 10^9)
題解 將最後一位數四捨五入
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 10000; int main(){ ll n; scanf(&amp;#34;%lld&amp;#34;, &amp;amp;n); if(n % 10 &amp;lt; 5){ n /= 10; n *= 10; } else{ n /= 10; n++; n *= 10; } printf(&amp;#34;%lld\n&amp;#34;, n); return 0; } B.</description></item><item><title>Codeforces Round 448</title><link>https://ptzu.github.io/posts/cf448/</link><pubDate>Sun, 18 Feb 2018 00:20:12 +0000</pubDate><guid>https://ptzu.github.io/posts/cf448/</guid><description>目錄 切 pizza 區間被 x 整除有 k 個 A. Pizza Separation 題目
input 輸入 n (1 ≤ n ≤ 360), 代表 pizza 切成 n 塊 輸入 n 塊的角度
題解 pizza 已經切成 n 塊, 現在想要將這些分為連續的兩部份 並且使這兩部份的角度和差距最小
作法 窮舉不同的和
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 447</title><link>https://ptzu.github.io/posts/cf447/</link><pubDate>Sat, 17 Feb 2018 23:43:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf447/</guid><description>目錄 窮舉 方格填數 A. QAQ 題目
input 輸入一字串 s
題解 QAQ 代表哭臉 給一字串, 求有幾個 QAQ (不必相連)
作法 窮舉
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX // const int MAX_N = 100010; int main(){ string s; cin &amp;gt;&amp;gt; s; int cnt = 0; for(int i = 0; i &amp;lt; s.</description></item><item><title>Codeforces Round 446</title><link>https://ptzu.github.io/posts/cf446/</link><pubDate>Sat, 17 Feb 2018 22:12:08 +0000</pubDate><guid>https://ptzu.github.io/posts/cf446/</guid><description>目錄 分裝可樂 耙子殺人 GCD A. Greed 題目
input 第一列輸入 n (2 ≤ n ≤ 100 000) 代表 n 罐可樂 下一列輸入每罐剩餘的可樂 (0 ≤ a ≤ 10^9) 最後輸入每個罐子的容量 (a ≤ b ≤ 10^9)
題解 有 n 罐可樂, 每個罐子有其剩餘的可樂和罐子容量 問是否能將全部剩餘的可樂分裝到兩個罐子內
作法 sorting 後找最大的兩個罐子
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 427</title><link>https://ptzu.github.io/posts/cf427/</link><pubDate>Tue, 13 Feb 2018 17:48:53 +0000</pubDate><guid>https://ptzu.github.io/posts/cf427/</guid><description>目錄 實作 Greedy 換數字 棋盤式 DP A. Key races 題目
input 輸入 s, v1, v2, t1, t2 (1 ≤ s, v1, v2, t1, t2 ≤ 1000) 分別代表字串長度, 打字速度, 延遲
題解 兩人比賽打字, 指定字串長度 s 比賽延遲 t 秒後才開始, 以每字 v 秒的速度打字, 打完後延遲 t 秒收到成功訊息 若第一人比較快, 輸出 &amp;ldquo;First&amp;rdquo; 反之輸出 &amp;ldquo;Second&amp;rdquo; 平手輸出 &amp;ldquo;Friendship&amp;rdquo;
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Codecraft-18 and Codeforces Round 458</title><link>https://ptzu.github.io/posts/cf458/</link><pubDate>Tue, 13 Feb 2018 11:39:59 +0000</pubDate><guid>https://ptzu.github.io/posts/cf458/</guid><description>題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int mod = 1e9 + 7; string s; int k; int dp[1010]; int C[1010][1010]; int main(){ fio; cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; k; if(k == 0){ puts(&amp;#34;1&amp;#34;); return 0; } dp[1] = 0; for(int i = 2; i &amp;lt;= 1000; i++) dp[i] = dp[__builtin_popcount(i)] + 1; C[0][0] = 1; for(int i = 1; i &amp;lt;= 1000; i++){ C[i][0] = 1; for(int j = 1; j &amp;lt;= 1000; j++){ C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod; } } int one_num = 0, len = s.</description></item><item><title>主席樹之詳細解說</title><link>https://ptzu.github.io/posts/chairman-tree/</link><pubDate>Mon, 29 Jan 2018 09:59:36 +0000</pubDate><guid>https://ptzu.github.io/posts/chairman-tree/</guid><description>待補
參考資料 http://blog.csdn.net/Lin_disguiser/article/details/52093248 http://blog.csdn.net/Regina8023/article/details/41910615 https://blog.masterliu.net/chairman-tree/ http://blog.csdn.net/good_night_sion_/article/details/72919960 http://chrysanthemum.is-programmer.com/posts/189902.html 帶修改
https://tw.saowen.com/a/c97b1e0a1d5be2000652c21d5d3471ea86b13359a5acf317c6828c3bf006301f http://blog.csdn.net/u014664226/article/details/47839973</description></item><item><title>Codeforces Hello 2018</title><link>https://ptzu.github.io/posts/cfhello2018/</link><pubDate>Sat, 13 Jan 2018 15:31:50 +0000</pubDate><guid>https://ptzu.github.io/posts/cfhello2018/</guid><description>目錄 取模 判斷樹的孩子數量 檸檬汁購買 A. Modular Exponentiation 題目
input 輸入兩個正整數 n, m, 1 &amp;lt;= n,m &amp;lt;= 10^8
題解 求 m mod 2^n
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 1010; int main(){ int n, m; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); int mod = 1; if(n &amp;gt;= 32){ printf(&amp;#34;%d\n&amp;#34;, m); } else{ for(int i = 1; i &amp;lt;= n; i++) mod &amp;lt;&amp;lt;= 1; printf(&amp;#34;%d\n&amp;#34;, m % mod); } return 0; } B.</description></item><item><title>Codeforces Round 454</title><link>https://ptzu.github.io/posts/cf454/</link><pubDate>Sun, 24 Dec 2017 14:13:13 +0000</pubDate><guid>https://ptzu.github.io/posts/cf454/</guid><description>目錄 暴力列舉 大型 OOXX 猜字元 A. Masha and Bears 題目
input 給四正整數, V1, V2, V3, Vm, 1 &amp;lt;= V &amp;lt;= 100 分別代表 熊爸, 熊媽, 小熊, Masha 的大小
題解 設熊的尺寸 a, 車的尺寸 b 可以上車的條件為 a &amp;lt;= b 喜歡那台車的條件為 可以上車且 b &amp;lt;= 2 * a 熊爸喜歡最大的車, 熊媽喜歡中型的車, 小熊喜歡最小的車 Masha &amp;ldquo;只&amp;rdquo; 喜歡最小的車
作法 暴力列舉就好, 唯一要注意的是 Masha 只喜歡最小的車 所以中型車必須 b &amp;gt; 2 * a
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Codeforces Round 443</title><link>https://ptzu.github.io/posts/cf443/</link><pubDate>Fri, 27 Oct 2017 17:05:13 +0000</pubDate><guid>https://ptzu.github.io/posts/cf443/</guid><description>目錄 模擬題 模擬題 位元操作 A. Borya&amp;rsquo;s Diagnosis 題目
input 1 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= s, d &amp;lt;= 1000
題解 Borya 要依序看 n 個醫生 每個醫生只在 si, si + di &amp;hellip; 的日子營業 請問最快要幾天才能看完所有醫生
作法 模擬題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>利用 CSS 達到 div 併排</title><link>https://ptzu.github.io/posts/css-float/</link><pubDate>Fri, 19 May 2017 11:44:58 +0000</pubDate><guid>https://ptzu.github.io/posts/css-float/</guid><description>假設我們現在有3個區塊想要並列一起
&amp;lt;div class=&amp;#34;wrap&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;a&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;b&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;c&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 我們可以在 Css 中利用 float 來達成併排效果
.wrap{ background-color: green; } .a, .b, .c{ float: left; } 這樣就可以達到效果 但這時候你可能會發現, 父階層的 div 怎麼沒有高度？ 原因是 float 造成元素沒有撐起 div 高度
有三種方法解決
對父階層設定高度 使用 css clear 在結束標籤前加一個 div(注意不是直接作用在父階層哦) &amp;lt;div class=&amp;#34;wrap&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;a&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;b&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;c&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;clear&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ```css .clear{ clear:both; } 對父階層使用 css overflow .wrap{ overflow: hidden; }</description></item><item><title>compiler2</title><link>https://ptzu.github.io/posts/compiler2/</link><pubDate>Fri, 12 May 2017 12:00:33 +0000</pubDate><guid>https://ptzu.github.io/posts/compiler2/</guid><description>java -cp antlr-3.5.2-complete.jar org.antlr.Tool myC.g
javac -cp ./antlr-3.5.2-complete.jar:. myC_test.java
java -cp .:antlr-3.5.2-complete.jar myC_test input1.c</description></item><item><title>Compiler(一)：環境建制以及Lexer</title><link>https://ptzu.github.io/posts/compiler1/</link><pubDate>Mon, 03 Apr 2017 22:32:26 +0000</pubDate><guid>https://ptzu.github.io/posts/compiler1/</guid><description>使用 ANTLR V3 ANTLR官網
ANTLR 利用 .g 檔生成 Lexer 定義 Token 如下:
INT_TYPE : 'int'; LONGLONG_TYPE : 'long long'; CHAR_TYPE : 'char'; VOID_TYPE : 'void'; FLOAT_TYPE: 'float'; WHILE_ : 'while'; FOR_ : 'for'; IF_ : 'if'; ELSE_ : 'else'; 一些常見型態如: int, long long, char, void, float 一些保留字如: while, for, if, else
ASSIGN_OP : '='; P_OP : '+'; M_OP : '-'; MU_OP : '*'; MUA_OP : '*='; D_OP : '/'; DA_OP : '/='; PA_OP : '+='; MA_OP : '-='; EQ_OP : '=='; LE_OP : '&amp;lt;='; GE_OP : '&amp;gt;='; NE_OP : '!</description></item><item><title>Codeforces Round 407</title><link>https://ptzu.github.io/posts/cf407/</link><pubDate>Thu, 30 Mar 2017 16:32:28 +0000</pubDate><guid>https://ptzu.github.io/posts/cf407/</guid><description>目錄 微動腦實作 math 最大連續區間和變形 A. Anastasia and pebbles 題目
input n 種石頭, 口袋能放 k 個: 1 ≤ n ≤ 10^5, 1 ≤ k ≤ 10^9 石頭數量 w1&amp;hellip;wn: 1 ≤ wi ≤ 10^4
題解 Anastasia 決定在公園裡蒐集石頭 他有兩個口袋, 每個口袋可以放 k 個石頭 公園裡有 n 種石頭, 第 i 種石頭有 wi 個 在同一個口袋不能放不同種類的石頭 她一天只能來公園蒐集一次石頭(兩個口袋滿) 請問要幾天才能蒐集完公園裡全部石頭？
作法 由於每次只能裝 k 個, 而且不能混別種石頭 所以就每 k 個當作一堆, 每天能裝 2 堆 看要幾天
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Educational Codeforces Round 18</title><link>https://ptzu.github.io/posts/cfedu18/</link><pubDate>Thu, 30 Mar 2017 16:32:26 +0000</pubDate><guid>https://ptzu.github.io/posts/cfedu18/</guid><description>目錄 距離 sort 使用 vector erase 數字 digit 總於除 3 A. New Bus Route 題目
input n 個城市: 2 ≤ n ≤ 2·10^5 城市座標: - 10^9 ≤ a ≤ 10^9
題解 有 n 座城市, 要規劃新的公車路線 所以要求出任兩城市的最短距離, 以及符合該距離的 pair 有幾個？
作法 sort
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 406</title><link>https://ptzu.github.io/posts/cf406/</link><pubDate>Fri, 24 Mar 2017 22:35:41 +0000</pubDate><guid>https://ptzu.github.io/posts/cf406/</guid><description>目錄 A. The Monster 題目
input 1 ≤ a, b, c, d ≤ 100
題解 b, b + a, b + 2a, &amp;hellip; b 以這樣成長著 d, d + c, d + 2c, &amp;hellip; d 以這樣成長著 求 b 和 d 何時會相同, 輸出第一個相同的數 沒有這樣的數就輸出 -1
作法 我的作法是讓迴圈跑 100 次 想法是這樣 b, d的範圍是 100 假設極端測資, b = 100, d = 1 a = 1, c = 2 差距 99, 每次拉近 1 跑 100 次該重疊的也要重疊了吧？ 不過沒有嚴謹的證明, 只是憑感覺 但似乎大家都是這麼做的</description></item><item><title>Codeforces Round 405</title><link>https://ptzu.github.io/posts/cf405/</link><pubDate>Sun, 19 Mar 2017 15:08:22 +0000</pubDate><guid>https://ptzu.github.io/posts/cf405/</guid><description>目錄 模擬題 DFS 區間元素不重複&amp;amp;重複 A. Bear and Big Brother 題目
input 1 ≤ a ≤ b ≤ 10
題解 a 每天變為 3 倍, b 每天變為 2 倍 問幾天後, a 會嚴格大於 b
作法 模擬題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; int cnt = 0; while(1){ if(a &amp;gt; b) break; a *= 3; b *= 2; cnt++; } cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; return 0; } B.</description></item><item><title>Codeforces Round 403</title><link>https://ptzu.github.io/posts/cf403/</link><pubDate>Wed, 08 Mar 2017 23:48:14 +0000</pubDate><guid>https://ptzu.github.io/posts/cf403/</guid><description>目錄 實作題 平均最大化變形 樹著色 A. Andryusha and Socks 題目
input n 雙襪子: 1 ≤ n ≤ 10^5 接著 2 * n 個輸入, 從袋子拿出編號 i 的襪子
題解 從袋子裡拿出襪子, 如果襪子還沒成雙, 就放在桌上 成雙就放進衣櫥, 求桌上最多幾隻襪子？
作法 實作題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int cnt[101010]; int main(){ ios::sync_with_stdio(false); cin.</description></item><item><title>Codeforces Round 402</title><link>https://ptzu.github.io/posts/cf402/</link><pubDate>Tue, 28 Feb 2017 23:27:35 +0000</pubDate><guid>https://ptzu.github.io/posts/cf402/</guid><description>目錄 分配相等 被 10^k 整除 greedy 買東西 字串二分搜 A. Pupils Redistribution 題目
input 每組 n 人： 1 &amp;lt;= n &amp;lt;= 100 學業值 a: 1 &amp;lt;= a &amp;lt;= 5
題解 每個人的學業表現值為1~5 在學校裡分為 A,B 兩組, 每組有 n 人 今要使兩組在各表現值的人數相同 兩組的人員可以交換, 求最少要交換幾次？
作法 要使兩組人數相同, 就代表一組在該值的人數為 2 / n 算出總交換次數, 再除以 2 為答案
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>ICM Technex 2017 and Codeforces Round 400</title><link>https://ptzu.github.io/posts/cf400/</link><pubDate>Fri, 24 Feb 2017 19:30:50 +0000</pubDate><guid>https://ptzu.github.io/posts/cf400/</guid><description>目錄 實作題 判斷質數 組出多個數字的區間和有幾個 A. A Serial Killer 題目
input 兩個名字： s1, s2 n: 接下來有幾天 字串a, b: a 代表誰被殺, b 代表誰去取代被殺人的位置
題解 有個連續殺人魔, 一開始鎖定了兩個人 接下來 n 天, 他都會殺了 a, 並再找一個 b 請問每天他可以選擇的人名有誰？
作法 簡單實作題, 不斷替換字串就好
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ ios::sync_with_stdio(false); cin.</description></item><item><title>Codeforces Round 380 (Div. 2)</title><link>https://ptzu.github.io/posts/cf380/</link><pubDate>Thu, 16 Feb 2017 23:54:05 +0000</pubDate><guid>https://ptzu.github.io/posts/cf380/</guid><description>A. Interview with Oleg 題目
input n: 字串長度 s: 一字串
題解 把字串中有出現 &amp;lsquo;ogo&amp;rsquo; 的替換成 *** 另外,如果 ogo 後面接上 go 也算是一起的例如 &amp;lsquo;ogogo&amp;rsquo;
作法 O(n) 掃過一次即可
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ // ios::sync_with_stdio(false); // cin.</description></item><item><title>Codeforces Round 382 (Div. 2)</title><link>https://ptzu.github.io/posts/cf382/</link><pubDate>Wed, 15 Feb 2017 23:25:08 +0000</pubDate><guid>https://ptzu.github.io/posts/cf382/</guid><description>目錄 A. 實作題 B. greedy C. fibunacci D. 哥德巴赫猜想
A. Ostap and Grasshopper 題目
input n 個 cell: 2 &amp;lt;= n &amp;lt;= 100 蚱蜢一次跳 k 步： 1 &amp;lt;= k &amp;lt;= n - 1
題解 &amp;ldquo;.&amp;rdquo; 代表空的cell, &amp;ldquo;#&amp;rdquo; 代表障礙, &amp;ldquo;G&amp;rdquo; 代表蚱蜢, &amp;ldquo;T&amp;rdquo; 代表目標 問能否達到目標
作法 實作題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int n, k; int main(){ // ios::sync_with_stdio(false); // cin.</description></item><item><title>Codeforces Round 381 (Div. 2)</title><link>https://ptzu.github.io/posts/cf381/</link><pubDate>Wed, 15 Feb 2017 23:25:00 +0000</pubDate><guid>https://ptzu.github.io/posts/cf381/</guid><description>A. Alyona and copybooks 題目
input 1 &amp;lt;= n,a,b,c &amp;lt;= 10^9
題解 Alyona 有4個科目, 他想替每個科目買數量相同的習字本目前他已經有 n 本商店有三種包裝, 一本賣 a 盧布, 兩本賣 b 盧布, 三本賣 c 盧布他還需要買 k 本使得 n + k 是4的倍數請問買 k 本最少需要花多少錢？
作法 把每一種包裝的組合可能列舉出來, 找出花最少錢的組合
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ // ios::sync_with_stdio(false); // cin.</description></item><item><title>Codeforces Round 395 (Div. 2)</title><link>https://ptzu.github.io/posts/cf395/</link><pubDate>Fri, 03 Feb 2017 23:56:45 +0000</pubDate><guid>https://ptzu.github.io/posts/cf395/</guid><description>目錄 GCD/LCM 實作序列翻轉 子樹不能有相同顏色 奇數邊長長方形上色 A. Taymyr is calling you 題目
input 數字 n, m, z: 1 ≤ n, m, z ≤ 10^4
題解 一天長 z 分鐘, Ilia-alpinist 每 n, 2n, 3n&amp;hellip;分鐘會打電話 Artists 每 m, 2m, 3m 會來房間 求要殺掉幾個人, 才能使打電話時, 房間沒有人 奇怪的題目敘述(?
作法 求LCM就好
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ // ios::sync_with_stdio(false); // cin.</description></item><item><title>Codeforces Round 389 (Div. 2)</title><link>https://ptzu.github.io/posts/cf389/</link><pubDate>Thu, 02 Feb 2017 20:24:08 +0000</pubDate><guid>https://ptzu.github.io/posts/cf389/</guid><description>C. Santa Claus and Robot 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ int n; char dir1 = 0, dir2 = 0; scanf(&amp;#34;%d\n&amp;#34;, &amp;amp;n); int cnt = 0; for(int i = 0; i &amp;lt; n; i++){ char c; scanf(&amp;#34;%c&amp;#34;, &amp;amp;c); if(c == &amp;#39;U&amp;#39; || c == &amp;#39;D&amp;#39;){ if(dir1 == 0){ dir1 = c; continue; } if(c !</description></item><item><title>Codeforces Round 388 (Div. 2)</title><link>https://ptzu.github.io/posts/cf388/</link><pubDate>Thu, 02 Feb 2017 20:24:01 +0000</pubDate><guid>https://ptzu.github.io/posts/cf388/</guid><description>C. Voting 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX deque &amp;lt;int&amp;gt; D; deque &amp;lt;int&amp;gt; R; char a[202020]; int main(){ // ios::sync_with_stdio(false); // cin.tie(0); int n; scanf(&amp;#34;%d\n&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ scanf(&amp;#34;%c&amp;#34;, &amp;amp;a[i]); if(a[i] == &amp;#39;D&amp;#39;) D.</description></item><item><title>Codeforces Round 387 (Div. 2)</title><link>https://ptzu.github.io/posts/cf387/</link><pubDate>Thu, 02 Feb 2017 20:23:51 +0000</pubDate><guid>https://ptzu.github.io/posts/cf387/</guid><description>C. Servers 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; server; vector &amp;lt;int&amp;gt; can; int main(){ int n, q; scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;q); for(int i = 0; i &amp;lt; n; i++) can.</description></item><item><title>Codeforces Round 386 (Div. 2)</title><link>https://ptzu.github.io/posts/cf386/</link><pubDate>Thu, 02 Feb 2017 20:23:43 +0000</pubDate><guid>https://ptzu.github.io/posts/cf386/</guid><description>C. Tram 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;%d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int s, x1, x2, v1, v2, p, d; int main(){ scanf(&amp;#34;%d %d %d %d %d %d %d&amp;#34;, &amp;amp;s, &amp;amp;x1, &amp;amp;x2, &amp;amp;v1, &amp;amp;v2, &amp;amp;p, &amp;amp;d); //opposite direction int dis = 0; int ans = abs(x2 - x1) * v2; if((x2 - x1) * d &amp;lt; 0){ if(d &amp;gt; 0) dis = s - p + abs(x2 - s); else dis = p + x2; } else{ if(d &amp;gt; 0 &amp;amp;&amp;amp; p &amp;gt; x1) dis = (s - p) + s + x2; else if(d &amp;lt; 0 &amp;amp;&amp;amp; p &amp;lt; x1) dis = p + s + abs(s - x2); else dis = abs(x2 - p); } printf(&amp;#34;%d\n&amp;#34;, min(ans, dis * v1)); return 0; } E.</description></item><item><title>Codeforces Round 384 (Div. 2)</title><link>https://ptzu.github.io/posts/cf384/</link><pubDate>Thu, 02 Feb 2017 20:21:21 +0000</pubDate><guid>https://ptzu.github.io/posts/cf384/</guid><description>C. Vladik and fractions 題目
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); if(n == 1){ printf(&amp;#34;-1\n&amp;#34;); return 0; } for(int i = 1; i &amp;lt;= 1e8; i++){ ll up = 2 * i - 1; ll down = n * i; ll x, y; if(up % 2 == 1){ x = up / 2; y = up / 2 + 1; } if(x &amp;gt; 1e9 || y &amp;gt; 1e9 || down &amp;gt; 1e9) break; if(x * y == down){ printf(&amp;#34;%lld %lld %lld\n&amp;#34;, x, y, down); return 0; } } printf(&amp;#34;-1\n&amp;#34;); return 0; }</description></item><item><title>Codeforces Round 385 (Div. 2)</title><link>https://ptzu.github.io/posts/cf385/</link><pubDate>Wed, 25 Jan 2017 11:08:09 +0000</pubDate><guid>https://ptzu.github.io/posts/cf385/</guid><description>A. Hongcow Learns the Cyclic Shift 題目
input 題解 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX map &amp;lt;string, bool&amp;gt; m; int main(){ string s; cin &amp;gt;&amp;gt; s; int len = s.length(); int cnt = 0; for(int i = 0; i &amp;lt; len; i++){ string ss = s.</description></item><item><title>Codeforces Round 383 (Div. 2)</title><link>https://ptzu.github.io/posts/cf383/</link><pubDate>Wed, 07 Dec 2016 23:13:55 +0000</pubDate><guid>https://ptzu.github.io/posts/cf383/</guid><description>A. Arpa’s hard exam and Mehrdad’s naive cheat 題目
input 0 &amp;lt;= n &amp;lt;= 10^9
題解 求1378的 n 次方
解法 直接列舉 8 次方的可能 或是快速冪(需要mod)
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int fast_pow(int a,int b) { ll ans = 1,base = a; while(b!</description></item><item><title>Codeforces Round 366 (Div. 2)</title><link>https://ptzu.github.io/posts/cf366/</link><pubDate>Wed, 05 Oct 2016 21:22:50 +0000</pubDate><guid>https://ptzu.github.io/posts/cf366/</guid><description>A. Hulk 題目
題解 簡單字串處理
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int n; string s; int main(){ ios::sync_with_stdio(false); cin.tie(0); cin &amp;gt;&amp;gt; n; for(int i = 1; i &amp;lt;= n; i++){ if(i % 2 == 1){ s += &amp;#34;I hate &amp;#34;; } else if(i % 2 == 0){ s += &amp;#34;I love &amp;#34;; } if(i !</description></item><item><title>Codeforces Round 365 (Div. 2)</title><link>https://ptzu.github.io/posts/cf365/</link><pubDate>Wed, 05 Oct 2016 20:00:52 +0000</pubDate><guid>https://ptzu.github.io/posts/cf365/</guid><description>A. Mishka and Game 題目
題解 水題 判斷誰猜拳贏的次數多
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f #define st first #define nd second // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ ios::sync_with_stdio(false); cin.tie(0); int n; cin &amp;gt;&amp;gt; n; int num1 = 0; int num2 = 0; for(int i = 0; i &amp;lt; n; i++){ int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; if(a &amp;gt; b) num1++; else if(a &amp;lt; b) num2++; } if(num1 &amp;gt; num2) cout &amp;lt;&amp;lt; &amp;#34;Mishka\n&amp;#34;; else if(num2 &amp;gt; num1) cout &amp;lt;&amp;lt; &amp;#34;Chris\n&amp;#34;; else cout &amp;lt;&amp;lt; &amp;#34;Friendship is magic!</description></item><item><title>KTUcamp2</title><link>https://ptzu.github.io/posts/cfktucamp2/</link><pubDate>Tue, 26 Jul 2016 22:46:21 +0000</pubDate><guid>https://ptzu.github.io/posts/cfktucamp2/</guid><description>C. Rating Shuffle # binary_search 題目
題解 給 n 個人, 每個人都有評分(rating) 每場比賽每個人的評分可以上升或下降 d 分 求需要最少幾場可以使第 i 人, 評分第 i 大 也就是大到小
作法 可以觀察到愈多場次, 愈容易達成 所以可以用二分搜, 是否能使用 k 場來完成需求
想法： 先將第一人直接加到最大 接著看第二人需要幾場可以最接近第一人 但不超過他, 以此類推
需要注意的是奇偶數的判定 例如： 我們需要上升(或下降) 3 場, 而二分搜的場次為 4 場 但這樣不可能達成, 因為需要 +3 場, 則剩下那個一定是 -1 場 結果就為 +2 場
所以當有奇偶數場的差別時, 可以退而求其次, 不那麼接近 prev 也就是 need&amp;ndash;
而判斷函式回傳 false 的條件: abs(need) &amp;gt; mid 可分為兩部份討論
需要加上 +need 場數: 這種情況不影響, 因為可以不那麼接近, 而且會和 mid 取 min</description></item><item><title>Educational Codeforces Round 11</title><link>https://ptzu.github.io/posts/cfedu11/</link><pubDate>Sun, 24 Jul 2016 22:12:59 +0000</pubDate><guid>https://ptzu.github.io/posts/cfedu11/</guid><description>C. Hard Process # binary_search # two points 題目
題解 給定長度為 n 只有 0, 1 的數列現有 k 次機會可將 0 轉換成 1求可連續的 1 最長是多少作法 可利用二分搜, 假設長度 x 是否能在 k 次轉換得到由於觀察到長度愈長, 愈難達成有此單調性, 故可用二分搜是 1 1 1 1 0 0 0 0 類型AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f // LLONG_MIN LLONG_MaX INT_MIN INT_MaX int n, k; int a[303030]; bool C(int x, int &amp;amp;pos){ int block_1 = 0; for(int i=0; i&amp;lt;x; i++){ if(a[i] == 1) block_1++; } int need = x - block_1; for(int i=1; i + x - 1 &amp;lt; n; i++){ if(a[i - 1] == 1) block_1--; if(a[i + x - 1] == 1) block_1++; if(x - block_1 &amp;lt; need){ need = x - block_1; pos = i; } } return need &amp;lt;= k; } int binary_search(int &amp;amp;pos){ //[0,n], 1 1 1 1 0 0 0 0 type int lb = 0; int ub = n; if(C(lb, pos) == 0) return 0; if(C(ub, pos) == 1) return n; while(ub - lb &amp;gt; 1){ int mid = (lb + ub) / 2; if(C(mid, pos)) lb = mid; else ub = mid; } //Make the pos in the right place C(lb, pos); return lb; } int main(){ ios::sync_with_stdio(false); cin.</description></item><item><title>Codeforces Round 340 (Div. 2)</title><link>https://ptzu.github.io/posts/cf340/</link><pubDate>Sat, 28 May 2016 23:48:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf340/</guid><description>A. Elephant 題目
題解 簡單題 一次可走 1~5 求到終點最少要走幾次
作法 終點座標除以 5 再看是否整除
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define make_pair mp #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f // LLONG_MIN LLONG_MaX INT_MIN INT_MaX int main(){ int x; cin &amp;gt;&amp;gt; x; int ans = x / 5; if(x % 5 != 0) ans++; cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0; } B.</description></item></channel></rss>
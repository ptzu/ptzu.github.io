<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Search on Ptzu's blog</title><link>https://ptzu.github.io/tags/binary-search/</link><description>Recent content in Binary Search on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 18 Feb 2018 00:20:12 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/binary-search/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeforces Round 448</title><link>https://ptzu.github.io/posts/cf448/</link><pubDate>Sun, 18 Feb 2018 00:20:12 +0000</pubDate><guid>https://ptzu.github.io/posts/cf448/</guid><description>目錄 切 pizza 區間被 x 整除有 k 個 A. Pizza Separation 題目
input 輸入 n (1 ≤ n ≤ 360), 代表 pizza 切成 n 塊 輸入 n 塊的角度
題解 pizza 已經切成 n 塊, 現在想要將這些分為連續的兩部份 並且使這兩部份的角度和差距最小
作法 窮舉不同的和
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Codeforces Round 403</title><link>https://ptzu.github.io/posts/cf403/</link><pubDate>Wed, 08 Mar 2017 23:48:14 +0000</pubDate><guid>https://ptzu.github.io/posts/cf403/</guid><description>目錄 實作題 平均最大化變形 樹著色 A. Andryusha and Socks 題目
input n 雙襪子: 1 ≤ n ≤ 10^5 接著 2 * n 個輸入, 從袋子拿出編號 i 的襪子
題解 從袋子裡拿出襪子, 如果襪子還沒成雙, 就放在桌上 成雙就放進衣櫥, 求桌上最多幾隻襪子？
作法 實作題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int cnt[101010]; int main(){ ios::sync_with_stdio(false); cin.</description></item><item><title>Codeforces Round 402</title><link>https://ptzu.github.io/posts/cf402/</link><pubDate>Tue, 28 Feb 2017 23:27:35 +0000</pubDate><guid>https://ptzu.github.io/posts/cf402/</guid><description>目錄 分配相等 被 10^k 整除 greedy 買東西 字串二分搜 A. Pupils Redistribution 題目
input 每組 n 人： 1 &amp;lt;= n &amp;lt;= 100 學業值 a: 1 &amp;lt;= a &amp;lt;= 5
題解 每個人的學業表現值為1~5 在學校裡分為 A,B 兩組, 每組有 n 人 今要使兩組在各表現值的人數相同 兩組的人員可以交換, 求最少要交換幾次？
作法 要使兩組人數相同, 就代表一組在該值的人數為 2 / n 算出總交換次數, 再除以 2 為答案
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>KTUcamp2</title><link>https://ptzu.github.io/posts/cfktucamp2/</link><pubDate>Tue, 26 Jul 2016 22:46:21 +0000</pubDate><guid>https://ptzu.github.io/posts/cfktucamp2/</guid><description>C. Rating Shuffle # binary_search 題目
題解 給 n 個人, 每個人都有評分(rating) 每場比賽每個人的評分可以上升或下降 d 分 求需要最少幾場可以使第 i 人, 評分第 i 大 也就是大到小
作法 可以觀察到愈多場次, 愈容易達成 所以可以用二分搜, 是否能使用 k 場來完成需求
想法： 先將第一人直接加到最大 接著看第二人需要幾場可以最接近第一人 但不超過他, 以此類推
需要注意的是奇偶數的判定 例如： 我們需要上升(或下降) 3 場, 而二分搜的場次為 4 場 但這樣不可能達成, 因為需要 +3 場, 則剩下那個一定是 -1 場 結果就為 +2 場
所以當有奇偶數場的差別時, 可以退而求其次, 不那麼接近 prev 也就是 need&amp;ndash;
而判斷函式回傳 false 的條件: abs(need) &amp;gt; mid 可分為兩部份討論
需要加上 +need 場數: 這種情況不影響, 因為可以不那麼接近, 而且會和 mid 取 min</description></item><item><title>Codeforces Round 364</title><link>https://ptzu.github.io/posts/cf364/</link><pubDate>Sun, 24 Jul 2016 22:58:53 +0000</pubDate><guid>https://ptzu.github.io/posts/cf364/</guid><description>C. They Are Everywhere 類似題目請參考 cfedu11 C 題 題目
題解 現有 n 間房間, 每間房間有不同類型的pokemon: a ~ z, A ~ Z 還真是趕的上流行的一題阿 哈哈 每間房間只能連到 n + 1 間, 意即只能往右走 求最少要經過幾間房間, 才能捉到所有類型的pokemon(input給的)
作法 又是一樣的兩端點區間的題目 用二分搜, 長度為 x 能不能捉到所有類型的pokemon 判斷函式寫法, 在長度 x 下用 map 記載類型數量 看能否達到題目要求的數量
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>Educational Codeforces Round 11</title><link>https://ptzu.github.io/posts/cfedu11/</link><pubDate>Sun, 24 Jul 2016 22:12:59 +0000</pubDate><guid>https://ptzu.github.io/posts/cfedu11/</guid><description>C. Hard Process # binary_search # two points 題目
題解 給定長度為 n 只有 0, 1 的數列現有 k 次機會可將 0 轉換成 1求可連續的 1 最長是多少作法 可利用二分搜, 假設長度 x 是否能在 k 次轉換得到由於觀察到長度愈長, 愈難達成有此單調性, 故可用二分搜是 1 1 1 1 0 0 0 0 類型AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f // LLONG_MIN LLONG_MaX INT_MIN INT_MaX int n, k; int a[303030]; bool C(int x, int &amp;amp;pos){ int block_1 = 0; for(int i=0; i&amp;lt;x; i++){ if(a[i] == 1) block_1++; } int need = x - block_1; for(int i=1; i + x - 1 &amp;lt; n; i++){ if(a[i - 1] == 1) block_1--; if(a[i + x - 1] == 1) block_1++; if(x - block_1 &amp;lt; need){ need = x - block_1; pos = i; } } return need &amp;lt;= k; } int binary_search(int &amp;amp;pos){ //[0,n], 1 1 1 1 0 0 0 0 type int lb = 0; int ub = n; if(C(lb, pos) == 0) return 0; if(C(ub, pos) == 1) return n; while(ub - lb &amp;gt; 1){ int mid = (lb + ub) / 2; if(C(mid, pos)) lb = mid; else ub = mid; } //Make the pos in the right place C(lb, pos); return lb; } int main(){ ios::sync_with_stdio(false); cin.</description></item></channel></rss>
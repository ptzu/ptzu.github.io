<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DFS on Ptzu's blog</title><link>https://ptzu.github.io/tags/dfs/</link><description>Recent content in DFS on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 Dec 2017 22:09:08 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml"/><item><title>Uva 10004 - Bicoloring</title><link>https://ptzu.github.io/posts/uva10004/</link><pubDate>Mon, 18 Dec 2017 22:09:08 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10004/</guid><description>題目
input 含有多筆測資, 每筆測資開頭有一正整數 n, 表 n 個點 接著含一正整數 l, 表 l 條邊 每條邊輸入 u, v, 代表 u 和 v 之間相連
題解 在 1976 年證明任何一張圖可以用 4 個顏色塗完, 相鄰兩點必須為不同顏色 而你現在要判斷是否能用兩個顏色塗完
作法 判斷二分圖裸題, 用DFS下去著色 如果相鄰的點和自己顏色一樣 就不是二分圖
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 210; vector &amp;lt;int&amp;gt; g[MAX_N]; int color[MAX_N]; bool dfs(int x, int c){ color[x] = c; bool ok = true; for(int i = 0; i &amp;lt; sz(g[x]); i++){ int v = g[x][i]; if(color[v] == 0) ok = min(ok, dfs(v, -c)); else if(color[v] == color[x]) return false; } return ok; } int main(){ int V, E; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;V) &amp;amp;&amp;amp; V){ for(int i = 0; i &amp;lt; MAX_N; i++) g[i].</description></item><item><title>POJ 2386 Lake Counting</title><link>https://ptzu.github.io/posts/poj2386/</link><pubDate>Sat, 18 Nov 2017 13:35:25 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2386/</guid><description>題目
input 1 &amp;lt;= N, M &amp;lt;= 100
題解 給一個 N X M 的地圖 &amp;lsquo;W&amp;rsquo; 代表有水, &amp;lsquo;.&amp;rsquo; 代表陸地 水的 8 個方向可以互相連接成水塘 請問有幾個水塘
作法 DFS可找出每一塊水塘
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INTf_MAX // const int MAX_N = 100010; char a[200][200]; int n, m; pii dir[] = {{1, 1}, {1, 0}, {1, -1}, {0, 1}, {0, -1}, {-1, 1}, {-1, 0}, {-1, -1}}; bool vis[200][200]; void dfs(int r, int c){ vis[r][c] = true; for(int i = 0; i &amp;lt; 8; i++){ int R = r + dir[i].</description></item><item><title>Codeforces Round 405</title><link>https://ptzu.github.io/posts/cf405/</link><pubDate>Sun, 19 Mar 2017 15:08:22 +0000</pubDate><guid>https://ptzu.github.io/posts/cf405/</guid><description>目錄 模擬題 DFS 區間元素不重複&amp;amp;重複 A. Bear and Big Brother 題目
input 1 ≤ a ≤ b ≤ 10
題解 a 每天變為 3 倍, b 每天變為 2 倍 問幾天後, a 會嚴格大於 b
作法 模擬題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; int cnt = 0; while(1){ if(a &amp;gt; b) break; a *= 3; b *= 2; cnt++; } cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; return 0; } B.</description></item></channel></rss>
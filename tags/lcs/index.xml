<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LCS on Ptzu's blog</title><link>https://ptzu.github.io/tags/lcs/</link><description>Recent content in LCS on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 17 Mar 2017 11:23:38 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/lcs/index.xml" rel="self" type="application/rss+xml"/><item><title>Uva 10066 - The Twin Towers</title><link>https://ptzu.github.io/posts/uva10066/</link><pubDate>Fri, 17 Mar 2017 11:23:38 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10066/</guid><description>題目
input 牆磚: 1 ≤ N1, N2 ≤ 100 N1 個牆磚半徑 N2 個牆磚半徑
題解 在一個古帝國, 有兩座形狀不一樣的塔, 它們是由不同半徑的圓形牆磚疊合而成。 數千年後, 皇帝要求工匠移除某些牆磚, 使得兩座塔變得一樣, 當然牆磚的順序必須和原本的塔一樣 請問若要使塔的高度最高, 它有幾塊牆磚?
作法 要使塔最高, 就代表相同的牆磚要愈多愈好, 而且順序不能變 那就是 LCS 解了！ 輸出記得空一行
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int a[200], b[200]; int main(){ int cnt = 1; int n, m; while(scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;m) !</description></item><item><title>Uva 531 - Compromise</title><link>https://ptzu.github.io/posts/uva531/</link><pubDate>Fri, 17 Mar 2017 10:23:45 +0000</pubDate><guid>https://ptzu.github.io/posts/uva531/</guid><description>題目
input 有很多 test case, 每個 case 有兩人的提議, 而且分別以 # 做結尾 每個人的提議最多 100 字, 每字最多 30 字元
題解 再幾個月, 歐洲貨幣聯盟就要成立, 要加入他們必須滿足馬斯垂克條約, 這並不是一件簡單的事, 為了讓德國滿足條約, 政府有好幾個方法(增稅, 賣股票&amp;hellip;), 但是難以決定。 兩位政治人物分別提出了建議, 你的任務是從他們兩個的建議中, 找出最多相同的提議, 並輸出那些提議。
作法 LCS + 回溯 用 pre 陣列來紀錄目前這個解是從哪裡來, 回推回去 ps: 感覺 udebug 有幾個測資有錯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 111 - History Grading</title><link>https://ptzu.github.io/posts/uva111/</link><pubDate>Thu, 16 Mar 2017 22:31:01 +0000</pubDate><guid>https://ptzu.github.io/posts/uva111/</guid><description>題目
input n 個歷史事件: 2 ≤ n ≤ 20 接下一行是正確答案的事件rank 後面每行都是學生答案的rank
題解 在一個歷史考試中, 學生被要求根據歷史事件發生年代做排序 全部排對可以得到全部分數, 而部分給分規則如下
根據每個事件, 排在正確位置就得 1 分 根據每個事件, 只要他的相對順序是正確就得 1 分 而我們接下來要採用第 2 個規則 給一串序列, c1&amp;hellip;cn, 代表第 i 個事件排的&amp;quot;位置(rank)&amp;quot; 例如: 3, 1, 2, 則真實順序為 2, 3, 1 求每個學生的得分 作法 LCS 要注意的是 input 所代表的意義 另外我覺得範例怪怪的, 那應該是代表兩筆測資 因為我只對 n 做一次輸入就AC了 應該不用做到多筆測資 當然學生的input是多筆沒錯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item></channel></rss>
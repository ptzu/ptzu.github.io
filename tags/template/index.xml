<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Template on Ptzu's blog</title><link>https://ptzu.github.io/tags/template/</link><description>Recent content in Template on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 13 Apr 2018 08:03:41 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/template/index.xml" rel="self" type="application/rss+xml"/><item><title>template-difference-constraint</title><link>https://ptzu.github.io/posts/template-difference-constraint/</link><pubDate>Fri, 13 Apr 2018 08:03:41 +0000</pubDate><guid>https://ptzu.github.io/posts/template-difference-constraint/</guid><description>目錄 題目
input 題解 作法 AC code</description></item><item><title>KMP Algorithm</title><link>https://ptzu.github.io/posts/template-kmp/</link><pubDate>Sun, 18 Mar 2018 09:54:26 +0000</pubDate><guid>https://ptzu.github.io/posts/template-kmp/</guid><description>index 從 0 開始 無配對為 -1
AC code const int MAX_N = ...; int fail[MAX_N]; void getf(string s){ fail[0] = -1; int idx = -1; for(int i = 1; i &amp;lt; s.length(); i++){ while(idx != -1 &amp;amp;&amp;amp; s[i] != s[idx + 1]){ idx = fail[idx]; } if(s[i] == s[idx + 1]){ fail[i] = idx + 1; idx++; } else fail[i] = -1; } } void KMP(string s, string t){ int idx = -1, t_len = t.</description></item><item><title>重心分解 Tree Decomposition</title><link>https://ptzu.github.io/posts/template-tree-decomposition/</link><pubDate>Sat, 17 Mar 2018 16:11:19 +0000</pubDate><guid>https://ptzu.github.io/posts/template-tree-decomposition/</guid><description>又稱為重心剖分、點分治
由於重心有個特性是, 子樹大小不超過 n / 2 n 為整顆樹的大小
所以每次找重心可以將時間複雜度壓到 O(logn)
Code struct edge{ int to, w; }; int V, k; vector &amp;lt;edge&amp;gt; g[10010]; bool vis[10010]; int son[10010], centroid, balance_size; int dis[10010]; void tree_centroid(int x, int fa, const int size){ int mx_son = 0; son[x] = 1; for(int i = 0; i &amp;lt; sz(g[x]); i++){ int v = g[x][i].to; if(v == fa || vis[v]) continue; tree_centroid(v, x, size); son[x] += son[v]; mx_son = max(mx_son, son[v]); } mx_son = max(mx_son, size - son[x]); if(mx_son &amp;lt; balance_size){ balance_size = mx_son; centroid = x; } } void tree_decomposition(int x, const int size){ balance_size = INF; tree_centroid(x, -1, size); int cent = centroid; vis[cent] = true; do something.</description></item><item><title>樹重心 Tree Centroid</title><link>https://ptzu.github.io/posts/template-tree-centroid/</link><pubDate>Wed, 14 Mar 2018 14:42:43 +0000</pubDate><guid>https://ptzu.github.io/posts/template-tree-centroid/</guid><description>將樹的一點移除, 會產生許多子樹 其中使子樹中最大數量最小的點為重心
方法為跑一次 DFS, 紀錄每個點的子樹數量 同時也更新最小值
Code vector &amp;lt;int&amp;gt; g[20010]; int son[20010], centroid, balance_size; int V; void dfs(int x, int pa){ int mx_son = 0; void tree_centroid(int x, int fa, const int size){ int mx_son = 0; son[x] = 1; for(int i = 0; i &amp;lt; sz(g[x]); i++){ int v = g[x][i]; if(v == fa) continue; tree_centroid(v, x, size); son[x] += son[v]; mx_son = max(mx_son, son[v]); } mx_son = max(mx_son, size - son[x]); if(mx_son &amp;lt; balance_size || (mx_son == balance_size &amp;amp;&amp;amp; x &amp;lt; centroid)){ balance_size = mx_son; centroid = x; } } 例題 POJ 1655</description></item><item><title>高斯消去法</title><link>https://ptzu.github.io/posts/template-gauss-elimination/</link><pubDate>Tue, 13 Mar 2018 16:32:04 +0000</pubDate><guid>https://ptzu.github.io/posts/template-gauss-elimination/</guid><description>Code typedef vector&amp;lt;int&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; int tot; // 自由變數量 void gauss(mat &amp;amp;m){ int n = m.size(); tot = 0; for(int col = 0; col &amp;lt; n; col++){ int tmp = tot; for(; tmp &amp;lt; n; tmp++) if(m[tmp][col]) break; if(tmp != n &amp;amp;&amp;amp; m[tmp][col]){ // 找到開頭是 1 的列, 有可能不在當前位置, 做列交換 for(int k = 0; k &amp;lt;= n; k++) swap(m[tot][k], m[tmp][k]); for(int row = 0; row &amp;lt; n; row++){ // 做消去 if(row !</description></item><item><title>矩陣行列式 Matrix Determinant</title><link>https://ptzu.github.io/posts/template-matrix-determinant/</link><pubDate>Sun, 11 Mar 2018 16:44:05 +0000</pubDate><guid>https://ptzu.github.io/posts/template-matrix-determinant/</guid><description>Code typedef vector&amp;lt;ll&amp;gt; vec; typedef vector&amp;lt;vec&amp;gt; mat; ll determinant(mat m){ int n = m.size(); ll det = 1; for(int col = 0; col &amp;lt; n; col++){ for(int row = col + 1; row &amp;lt; n; row++){ int x = col, y = row; // 目前列, 下一列 while(m[y][col]){ // 下一列不為 0 就繼續做 ll q = m[x][col] / m[y][col]; for(int k = 0; k &amp;lt; n; k++){ m[x][k] -= m[y][k] * q; } swap(x, y); } if(x !</description></item><item><title>2-SAT</title><link>https://ptzu.github.io/posts/template-twosat/</link><pubDate>Thu, 08 Mar 2018 12:02:50 +0000</pubDate><guid>https://ptzu.github.io/posts/template-twosat/</guid><description>當有{%math%}(a\vee b){%endmath%}這種型式的時候 可以轉成{%math%}(\neg a\Rightarrow b\wedge \neg b\Rightarrow a){%endmath%} 箭頭左邊建一條邊到右邊
addClause 的 flag 是代表該變數要不要取 not
只要{%math%}x, \neg x{%endmath%}不在同一個 SCC 內, 命題為真
邏輯定律 肯定前件律(MP): {%math%}p\supset q,\ p/\ q{%endmath%} 否定後件律(MT): {%math%}p\supset q,\ \neg q/\ \neg p{%endmath%} 連言律(Conj): {%math%}p,\ q/\ p\wedge q{%endmath%} 簡化律(Simp): {%math%}p\wedge q/\ p{%endmath%} 選言三段論(DS): {%math%}p\vee q,\ \neg p/\ q{%endmath%} 假言三段論(HS): {%math%}p\supset q,\ q\supset r/\ p\supset r{%endmath%} 添加律(Add): {%math%}p/\ p\vee q{%endmath%} 建構兩難律(CD): {%math%}p\supset q,\ r\supset s,\ p\vee r/\ q\vee s{%endmath%} 雙重否定律(DN): {%math%}p\equiv \neg \neg p{%endmath%} 笛摩根定律(DeM): {%math%}\neg (p\wedge q)\equiv \neg p \vee \neg q{%endmath%} 交換律(Comm): {%math%}p\vee q\equiv q\vee p{%endmath%} 結合律(Assoc): {%math%}p\vee (q\vee r) \equiv (p\vee q)\vee r{%endmath%} 分配律(Dist): {%math%}p\wedge (q\vee r)\equiv (p\wedge q)\vee (p\wedge r){%endmath%} {%math%}p\vee (q\wedge r)\equiv (p\vee q)\wedge (p\vee r){%endmath%} 換值換位律(Contra): {%math%}p\supset q\equiv \neg q\supset \neg p{%endmath%} 蘊涵律(Impl): {%math%}p\supset q\equiv \neg p\vee q{%endmath%} 等值律(Equiv): {%math%}(p\equiv q)\equiv (p\supset q)\wedge (q\supset p)\equiv (p\wedge q)\vee (\neg p\wedge \neg q){%endmath%} 移出律(Exp): {%math%}(p\wedge q)\supset r\equiv p\supset (q\supset r){%endmath%} 恆真律(Taut): {%math%}p\supset q\equiv \neg p\vee q{%endmath%} 其中 {%math%}\supset {%endmath%} 是條件符號</description></item><item><title>雙連通單元 BCC</title><link>https://ptzu.github.io/posts/template-bcc/</link><pubDate>Sun, 04 Mar 2018 19:30:28 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bcc/</guid><description>在一個無向圖中 若任兩點, 存在&amp;quot;兩條點不重複路徑&amp;quot;, 則稱此圖為 點-雙連通 而點-雙連通內部沒有割點 若任兩點, 存在&amp;quot;兩條邊不重複路徑&amp;quot;, 則稱此圖為 邊-雙連通
點-雙連通的最大子圖稱為雙連通單元(分量)
點-雙連通單元 性質:
條件: low[v] &amp;gt;= dfn 割點可以屬於多個連通單元 任兩個連通單元的共同點最多一個, 也就是割點 連通單元內不會有割點 可順便求割點 這在網路上有兩種寫法 一種是在 stack 存點, 另一種存邊 由於割點可以屬於多個單元, 所以在 pop 時, 不能將割點 pop 出去 而這份 code, 不會將割點 pop 出去, 但有個副作用是 root 會留在 stack 多筆測資使用要小心
存邊的寫法有空再來理解
存點 Code // 割點的 bccid 沒有意義 const int MAX_V = ...; int V, E; vector &amp;lt;int&amp;gt; g[MAX_V], bcc[MAX_V]; int dfn[MAX_V], low[MAX_V], tot, bccid[MAX_V], bcc_cnt; bool cut[MAX_V]; stack &amp;lt;int&amp;gt; S; void dfs(int x, int fa){ int child = 0; dfn[x] = low[x] = ++tot; S.</description></item><item><title>關節點、橋</title><link>https://ptzu.github.io/posts/template-articulation-point/</link><pubDate>Fri, 02 Mar 2018 12:59:19 +0000</pubDate><guid>https://ptzu.github.io/posts/template-articulation-point/</guid><description>關節點 關節點必須符合兩個性質其中一個：
假設目前點為 x, 子孫為 v, low[v] &amp;gt;= dfn 若該點是 root(起始點), 則他的小孩數量 &amp;gt; 1 先來看第一個性質, 當 low[v] 都大於等於當前的編號 就代表所有子孫不會連到當前點的祖先 也就是當前點斷掉的話, 就會分成兩塊
接下來看為何為特別將 root 設個條件(搭配下面的測資) root 的子孫 low 值一定都比 dfn[root] 大 那拿掉 root 一定可以斷開嘛？ 答案是否, 當圖案為一直線 拿掉起點不會產生新的 SCC 只有當 root_child &amp;gt; 1 時才會
相關測資 #root Input: 5 1 2 2 3 3 4 4 5 0 0 Output: 3 # dfn and low Input: 5 1 3 2 2 4 5 3 4 5 0 5 1 2 3 2 3 4 5 4 5 0 Output: 1 1 Code // 割點的 bccid 沒有意義 const int MAX_V = .</description></item><item><title>強連通單元 SCC</title><link>https://ptzu.github.io/posts/template-scc/</link><pubDate>Tue, 27 Feb 2018 23:58:21 +0000</pubDate><guid>https://ptzu.github.io/posts/template-scc/</guid><description>強連通單元為一集合, 集合內任取兩點, 都可以互相連通 任何有向圖都能分解成幾個 SCC 將 SCC 縮成一個點就會變成 DAG 求 SCC 數量方法有兩種
Tarjan 跑兩次 DFS Tarjan dfn[i]: DFS的順序(時間編號) low[i]: 能到達 i 的最小的時間編號 i 能達到的最小時間編號
在理解的時候有幾個問題
stack 的作用？ 用來存放已經走過, 但還沒變成 SCC 的點 in_stack 陣列存在的必要性？ 在看網路很多模版的時候, 他們是取作 vis 陣列的 而我想說既然有 dfn 陣列, 那還沒有時間戳的點肯定是沒走過的 為何需要 vis 陣列？ 首先走過的點可分為兩種 一種是在 stack 裏面, 另一種是不在了 當一個點不在 stack 內, 代表已經成為一個 SCC 若我們拿別的 SCC 來更新自己 low 值肯定出錯 因為已成為 SCC 的點不可能再走到當前點了 所以我認為取做 in_stack 更加恰當, 只有在 stack 的點可以更新當前 low 值 要用 dfn 還是 low 更新？ 第 19 行網路上幾乎都是用 dfn 更新 但我想想, 在 stack 的點若可走到當前點 那個點的 low 值也一定可以走到當前點 所以用 low 值更新應該沒錯吧(?</description></item><item><title>常用技巧篇</title><link>https://ptzu.github.io/posts/template-tricks/</link><pubDate>Tue, 20 Feb 2018 13:32:22 +0000</pubDate><guid>https://ptzu.github.io/posts/template-tricks/</guid><description>列舉因數 判斷後綴字串 a 是否為 b 的後綴字串
bool Suf(string a, string b){ if(a.length() &amp;gt; b.length()) return false; return a == b.substr(b.length() - a.length(), a.length()); } 分堆 離散化 平移視窗 浮點數 Graph linked list const int MAX_N = 50010; struct node{ int to, w; node* next; }*g[MAX_N], edges[MAX_N * 3]; int tot; inline void addEdge(int a, int b, int c){ node *e = &amp;amp;edges[tot++]; e-&amp;gt;to = b; e-&amp;gt;w = c; e-&amp;gt;next = g[a]; g[a] = e; }</description></item><item><title>LCA (Lowest Common Ancestor)</title><link>https://ptzu.github.io/posts/template-lca/</link><pubDate>Fri, 16 Feb 2018 19:57:50 +0000</pubDate><guid>https://ptzu.github.io/posts/template-lca/</guid><description>待學方法: Tarjan 離線O(n), RMQ在線
使用倍增法(binary lifting)求 LCA par[v][k] 為點 v 往上走 {%math%}2^{k}{%endmath%} 次的點 首先跑一次 DFS 求出各點的深度 接著跑 LCA 時, 先將比較深的那個點, 往上走到相同高度 由於 LCA 那個點往上走, 每個點都是共同祖先 所以可以用二分搜尋的概念
0 0 0 0 1 1 1 1 ^ ^ 走 2^0 次 走 2^7 次 0 代表不是祖先 1 代表是祖先 一開始走最大步, 接著逐漸縮小 如果該點不是祖先, 就往上走 是祖先就不動, 最後停下來的地方就是邊界
可求任意點對的 LCA 注意: 點是 0-indexed, 需先求好每個點走 1 步的 par 複雜度: {%math%}O(NlogN){%endmath%}
Code const int MAX_N = 10000; const int MAX_LOG_N = 14; int N, root; int depth[MAX_N]; int par[MAX_N][MAX_LOG_N]; vector &amp;lt;int&amp;gt; g[MAX_N]; void init(){ memset(par, -1, sizeof(par)); memset(g, 0, sizeof(g)); } void dfs(int u, int p, int d){ depth[u] = d; for(int i = 0; i &amp;lt; sz(g[u]); i++){ int v = g[u][i]; if(v !</description></item><item><title>逆序數對 Inversion</title><link>https://ptzu.github.io/posts/template-inversion/</link><pubDate>Thu, 15 Feb 2018 21:23:46 +0000</pubDate><guid>https://ptzu.github.io/posts/template-inversion/</guid><description>若有一個 N 個數的數列 A 針對 index i &amp;lt; j, A[i] &amp;gt; A[j], 則 &amp;lt;A[i], A[j]&amp;gt; 稱為一個逆序數對 可用 Merge sort, BIT&amp;hellip; 等求出 詳細見:維基百科
例題 POJ 2299</description></item><item><title>位元操作 Bit Operation</title><link>https://ptzu.github.io/posts/template-bit-operation/</link><pubDate>Sun, 11 Feb 2018 23:34:06 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bit-operation/</guid><description>待補
https://blog.kuoe0.tw/posts/2012/01/28/bitwise-operation-set-operation/</description></item><item><title>卡塔蘭數 Catalan number</title><link>https://ptzu.github.io/posts/template-catalan-number/</link><pubDate>Sat, 10 Feb 2018 00:02:58 +0000</pubDate><guid>https://ptzu.github.io/posts/template-catalan-number/</guid><description>一般式: {%math%} C_{n} = \dfrac {1}{n+1}\binom{2n}{n} = \dfrac {\left( 2n\right) !}{\left( n+1\right) !n!} {%endmath%} 遞迴式: {%math%}C_{n} = \dfrac {4*n-2}{n+1}C_{n-1}{%endmath%} 若可以觀察出 h(0) = 1,h(1) = 1 h(n) = h(0)*h(n-1) + h(1)*h(n-2) + &amp;hellip; + h(n-1)h(0) (其中 n &amp;gt;= 2) 則有可能是卡塔蘭數 可用於 二元樹種類個數&amp;hellip;等問題
Code big fac[MAX_N * 2]; big res = fac[2 * n] / fac[n + 1] / fac[n]; 例題 Uva 10007 POJ 2084</description></item><item><title>快速傅利葉轉換 FFT</title><link>https://ptzu.github.io/posts/template-fft/</link><pubDate>Fri, 09 Feb 2018 21:03:48 +0000</pubDate><guid>https://ptzu.github.io/posts/template-fft/</guid><description>Code const int N = 500005; const double PI = acos(-1.0); struct Virt{ double r,i; Virt(double r=0.0,double i=0.0){ this-&amp;gt;r=r; this-&amp;gt;i=i; } Virt operator+(const Virt &amp;amp;x){ return Virt(r+x.r,i+x.i); } Virt operator-(const Virt &amp;amp;x){ return Virt(r-x.r,i-x.i); } Virt operator*(const Virt &amp;amp;x){ return Virt(r*x.r-i*x.i,i*x.r+r*x.i); } }; //雷德算法--倒位序 void Rader(Virt F[],int len){ int j=len&amp;gt;&amp;gt;1; for(int i=1;i&amp;lt;len-1;i++){ if(i&amp;lt;j)swap(F[i],F[j]); int k = len &amp;gt;&amp;gt; 1; while(j&amp;gt;=k){ j-=k; k&amp;gt;&amp;gt;=1; } if(j&amp;lt;k)j+=k; } } //FFT实现 void FFT(Virt F[],int len,int on){ Rader(F, len); for(int h=2;h&amp;lt;=len;h&amp;lt;&amp;lt;=1) //分治后计算长度为h的DFT { Virt wn(cos(-on*2*PI/h),sin(-on*2*PI/h)); //单位复根e^(2*PI/m)用欧拉公式展开 for(int j=0; j&amp;lt;len; j+=h) { Virt w(1,0); //旋转因子 for(int k=j;k&amp;lt;j+h/2;k++) { Virt u=F[k]; Virt t=w*F[k+h/2]; F[k]=u+t; //蝴蝶合并操作 F[k+h/2]=u-t; w=w*wn; //更新旋转因子 } } } if(on==-1) for(int i=0;i&amp;lt;len;i++) F[i].</description></item><item><title>雙調TSP (Bitonic TSP)</title><link>https://ptzu.github.io/posts/template-bitonic-tsp/</link><pubDate>Thu, 08 Feb 2018 17:09:02 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bitonic-tsp/</guid><description>前言 從字面理解不知道是什麼怪東西。。。 據說是 CLRS 書 15-1 的習題, 有空再去翻看看~
簡單來說是 TSP 的簡化版, 限定從最左走到最右, 而且必須嚴格遞增/減 所以不再是 NP-Hard, 而是有 {%math%}O(n^{2}){%endmath%} 的作法
狀態 定義dp[i][j]: 從起點 1 出發, 走到 i 和 j 的最小總和(上下不同兩條路徑) dp[N][N] 即為答案, 因為可以看成 1 走到 N, N 走到 1 轉移 要怎麼保證上下兩條路徑, 不會走到相同的點呢？ 針對每個點, 每次只會把它放到上面或下面的路徑 假設目前要加的點是 j 上面那條路的最後點有可能是 1 ~ j - 1 分為兩個 case 討論
i &amp;lt; j - 1 點 j 可以從 j - 1 推導過來 dp[i][j] = dp[i][j - 1] + dis[j - 1][j], for i &amp;lt; j - 1 2.</description></item><item><title>Floyd Warshall</title><link>https://ptzu.github.io/posts/template-floyd-warshall/</link><pubDate>Mon, 05 Feb 2018 12:55:12 +0000</pubDate><guid>https://ptzu.github.io/posts/template-floyd-warshall/</guid><description>全點對最短路徑 時間複雜度: {%math%}O(n^{3}){%endmath%}
Code void floyd(int V){ for(int k = 0; k &amp;lt; V; k++){ for(int i = 0; i &amp;lt; V; i++){ for(int j = 0; j &amp;lt; V; j++){ d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } }</description></item><item><title>位元DP</title><link>https://ptzu.github.io/posts/template-digit-dp/</link><pubDate>Sun, 04 Feb 2018 11:54:45 +0000</pubDate><guid>https://ptzu.github.io/posts/template-digit-dp/</guid><description>以 旅行推銷員問題(TSP) 為例 複雜度: {%math%} O(2^{n}n^{2}) {%endmath%}
BOTTOM UP 狀態 S代表目前已經走過的點集合, v為目前的點 dp[S][v]: 已經走完 S, 目前在 v, 所花費的最小權重和 轉移 找一點不在集合的點 u, 列舉集合的點 v 走到 u 的距離 {%math%}dp[S | (1 &amp;laquo; u)][u] = min\left { dp[S | (1 &amp;laquo; u)][i], dp[S][v] + d[v][u], u \notin S \right }{%endmath%}
Code for(int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; n); i++) fill(dp[i], dp[i] + n, INF); dp[1][0] = 0; for(int S = 1; S &amp;lt; (1 &amp;lt;&amp;lt; n); S++){ for(int i = 0; i &amp;lt; n; i++){ if((S &amp;amp; (1 &amp;lt;&amp;lt; i)) == 0){ for(int j = 0; j &amp;lt; n; j++){ if(S &amp;amp; (1 &amp;lt;&amp;lt; j)) dp[S | (1 &amp;lt;&amp;lt; i)][i] = min(dp[S | (1 &amp;lt;&amp;lt; i)][i], dp[S][j] + d[j][i]); } } } } TOP DOWN 作法 top-down 的作法, 我覺得有點難想, 要搭配圖案</description></item><item><title>0/1 背包問題</title><link>https://ptzu.github.io/posts/template-01knaspack/</link><pubDate>Fri, 02 Feb 2018 17:11:55 +0000</pubDate><guid>https://ptzu.github.io/posts/template-01knaspack/</guid><description>狀態 dp[i] = 在背包容量 i 情況下的最大價值 轉移 dp[j] = max(dp[j - wi] + vi), for i &amp;lt; n Code 例題 Uva 10130 POJ 3624</description></item><item><title>主席樹 Chairman Tree</title><link>https://ptzu.github.io/posts/template-chairman-tree/</link><pubDate>Fri, 02 Feb 2018 16:33:45 +0000</pubDate><guid>https://ptzu.github.io/posts/template-chairman-tree/</guid><description>Code 例題 POJ 2104 帶修改: ZOJ 2112(記憶體限制很緊)</description></item><item><title>樹狀數組 Binary Indexed Tree</title><link>https://ptzu.github.io/posts/template-bit/</link><pubDate>Wed, 24 Jan 2018 16:36:06 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bit/</guid><description>可做到:
單點更新 前綴和查詢(範圍查詢) 注意是 1-based index
Code const int MAX_N = 20000; int bit[MAX_N + 10]; int add(int i, int x){ while(i &amp;lt;= n){ bit[i] += x; i += i &amp;amp; -i; } } int sum(int i){ int ans = 0; while(i){ ans += bit[i]; i -= i &amp;amp; -i; } return ans; } 例題 POJ 1990</description></item><item><title>線段樹 Segment Tree</title><link>https://ptzu.github.io/posts/template-segment-tree/</link><pubDate>Wed, 24 Jan 2018 10:14:23 +0000</pubDate><guid>https://ptzu.github.io/posts/template-segment-tree/</guid><description>可做到:
範圍更新 範圍查詢 主要有兩種版本 一種是直接開 input 大小, 另一種是開滿 2 的倍數 陣列大小一定要開到 input 的 4 倍 原因是線段樹本身就需要 2 * N 的空間 樹高會是 {%math%}\left \lceil log_{2}N \right \rceil{%endmath%} 所以可能會多一層 (不管有沒有補滿 2 的倍數都會)
經過測試 update 的時候一定要 push 再 pull query 可以只做 push 就好
Code 這種寫法是直接開 input 大小 1-indexed, 閉區間 [l, r] 在時間上和空間上都比較優秀 缺點是要 trace 的時候不太好做
#define L(x) (x&amp;lt;&amp;lt;1) #define R(x) (1+(x&amp;lt;&amp;lt;1)) #define mid ((l+r)&amp;gt;&amp;gt;1) const int MAX_N = 101010; int seg[MAX_N * 4], lazy[MAX_N * 4]; int a[MAX_N]; void seg_build(int idx, int l, int r){ if(l == r){ seg[idx] = a[l]; return ; } seg_build(L(idx), l, mid); seg_build(R(idx), mid + 1, r); seg[idx] = seg[L(idx)] + seg[R(idx)]; } void seg_push(int idx, int l, int r){ if(lazy[idx]){ seg[L(idx)] += lazy[idx] * (mid - l + 1); seg[R(idx)] += lazy[idx] * (r - (mid + 1) + 1); lazy[L(idx)] += lazy[idx]; lazy[R(idx)] += lazy[idx]; lazy[idx] = 0; } } void seg_update(int a, int b, int x, int idx, int l, int r){ if(r &amp;lt; a || l &amp;gt; b) return ; if(a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b){ seg[idx] += (r - l + 1) * x; lazy[idx] += x; return ; } seg_push(idx, l, r); seg_update(a, b, x, L(idx), l, mid); seg_update(a, b, x, R(idx), mid + 1, r); seg[idx] = seg[L(idx)] + seg[R(idx)]; } int seg_query(int a, int b, int idx, int l, int r){ if(r &amp;lt; a || l &amp;gt; b) return 0; if(a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b) return seg[idx]; seg_push(idx, l, r); return seg_query(a, b, L(idx), l, mid) + seg_query(a, b, R(idx), mid + 1, r); } Code 這是開滿 2 的倍數版本 0-indexed, 開區間 [l, r)</description></item><item><title>Kruskal Algorithm</title><link>https://ptzu.github.io/posts/template-kruskal/</link><pubDate>Fri, 12 Jan 2018 13:23:37 +0000</pubDate><guid>https://ptzu.github.io/posts/template-kruskal/</guid><description>時間瓶頸在排序 複雜度： O(ElogV)
Code struct Union_Find { int par[1010], num[1010]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U; struct edge{ int u, v, w; bool operator &amp;lt;(const edge&amp;amp; e) const{ return w &amp;lt; e.</description></item><item><title>Sollin Algorithm</title><link>https://ptzu.github.io/posts/template-sollin/</link><pubDate>Fri, 12 Jan 2018 12:59:18 +0000</pubDate><guid>https://ptzu.github.io/posts/template-sollin/</guid><description>求 MST, 不過速度有點慢
Code truct edge{ int u, v, w; }; struct Union_Find { int par[1010], num[1010]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U; edge edges[100000]; int V, E; int mn[1000]; int ComponentSize; // 一開始等於V int sollin(){ int ans = 0; while(ComponentSize &amp;gt; 1){ for(int i = 0; i &amp;lt; V; i++) mn[i] = INT_MAX; // 找出每個 Component 的最小邊是誰 for(int i = 0; i &amp;lt; E; i++){ edge e = edges[i]; int a = U.</description></item><item><title>Bipartite Matching</title><link>https://ptzu.github.io/posts/template-bipartite-matching/</link><pubDate>Sat, 06 Jan 2018 16:19:43 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bipartite-matching/</guid><description>匈牙利演算法(Hungarian Algorithm) 時間複雜度: O({%math%}n^{3}{%endmath%})
Code const int MAX_V = 1010; int V; vector &amp;lt;int&amp;gt; g[MAX_V]; int match[MAX_V]; bool vis[MAX_V]; void add_edge(int u, int v){ g[u].pb(v); g[v].pb(u); } bool dfs(int u){ vis[u] = true; for(int i = 0; i &amp;lt; sz(g[u]); i++){ int v = g[u][i], w = match[v]; if(w &amp;lt; 0 || (!vis[w] &amp;amp;&amp;amp; dfs(w))){ match[u] = v; match[v] = u; return true; } } return false; } int bipartite_matching(){ int res = 0; memset(match, -1, sizeof(match)); for(int i = 0; i &amp;lt; V; i++){ if(match[i] &amp;lt; 0){ memset(vis, 0, sizeof(vis)); if(dfs(i)) res++; } } return res; }</description></item><item><title>Max Flow</title><link>https://ptzu.github.io/posts/template-dinic/</link><pubDate>Thu, 04 Jan 2018 19:13:59 +0000</pubDate><guid>https://ptzu.github.io/posts/template-dinic/</guid><description>Dinic 演算法 時間複雜度: O({%math%}EV^{2}{%endmath%})
Code struct edge{ int to, cap, rev; }; vector &amp;lt;edge&amp;gt; g[MAX_V]; int iter[MAX_V]; int level[MAX_V]; void add_edge(int u, int v, int w){ g[u].pb((edge){v, w, sz(g[v])}); g[v].pb((edge){u, 0, sz(g[u]) - 1}); } void bfs(int S){ memset(level, -1, sizeof(level)); queue &amp;lt;int&amp;gt; q; level[S] = 0; q.push(S); while(!q.empty()){ int v = q.front(); q.pop(); for(int i = 0; i &amp;lt; sz(g[v]); i++){ edge&amp;amp; e = g[v][i]; if(e.cap &amp;gt; 0 &amp;amp;&amp;amp; level[e.</description></item><item><title>BSGS Algorithm</title><link>https://ptzu.github.io/posts/template-bsgs/</link><pubDate>Wed, 03 Jan 2018 23:08:32 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bsgs/</guid><description>求離散對數 時間複雜度: O({%math%}\sqrt {n}{%endmath%})
Code map &amp;lt;ll, int&amp;gt; mp; //value, idx int fastpow(ll a, ll b){ ll base = a, ans = 1; while(b){ if(b &amp;amp; 1) ans = ans * base % P; base = base * base % P; b &amp;gt;&amp;gt;= 1; } return ans; } int BSGS(int a, int b, int P){ mp.clear(); int m = ceil(sqrt(P)); ll value = b % P; // j = 0, value = b mp[value] = 0; for(int j = 1; j &amp;lt;= m; j++){ value = value * a % P; // a^j * b mp[value] = j; } ll t = fastpow(a, m, P); // a ^ m value = 1; for(int i = 1; i &amp;lt;= m; i++){ value = value * t % P; // a ^ (i*m) if(mp.</description></item><item><title>Prim Algorithm</title><link>https://ptzu.github.io/posts/template-prim/</link><pubDate>Fri, 22 Dec 2017 14:07:32 +0000</pubDate><guid>https://ptzu.github.io/posts/template-prim/</guid><description>基本上和 Dijkstra 一樣 只是 d[ ] 從到原點的距離改成到樹的距離
Code struct Edge{ int to, w; }; vector &amp;lt;Edge&amp;gt; g[MAX_V]; int d[MAX_V]; bool inTree[MAX_V]; int V, E; int prim(int S){ priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt;pq; fill(d, d + V, INF); memset(inTree, 0, sizeof(inTree)); d[S] = 0; pq.push((pii){0, S}); int res = 0, cnt = 0;; while(!pq.empty()){ pii top = pq.top(); pq.pop(); int u = top.nd; if(inTree[u] || d[u] &amp;lt; top.st) continue; inTree[u] = true; // 加到樹裡面 res += d[u]; cnt++; // 看是否有每個點都被連上 for(int i = 0; i &amp;lt; sz(g[u]); i++){ Edge e = g[u][i]; // 更新距離 if(e.</description></item><item><title>SPFA</title><link>https://ptzu.github.io/posts/template-spfa/</link><pubDate>Fri, 22 Dec 2017 14:07:27 +0000</pubDate><guid>https://ptzu.github.io/posts/template-spfa/</guid><description>可偵測負環 和 Dijkstra 差不多, 多用了 cnt 陣列去紀錄每個點被更新幾次 如果有個點被更新超過 V 次, 代表有負環
Code struct Edge { int to, w; }; const int MAX_V = ...; int V; vector&amp;lt;Edge&amp;gt; g[MAX_V]; int d[MAX_V]; int cnt[MAX_V]; bool SPFA(int S) { // 回傳有無負環 fill(d, d + V, INF); fill(cnt, cnt + V, 0); priority_queue&amp;lt; pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; pq; d[S] = 0; pq.push(pii(0, S)); cnt[S] = 1; while (!pq.empty()) { pii top = pq.top(); pq.</description></item><item><title>Bellman Ford</title><link>https://ptzu.github.io/posts/template-bellman-ford/</link><pubDate>Fri, 22 Dec 2017 14:07:15 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bellman-ford/</guid><description>Code struct Edge{ int from, to, w; }; int V, E; int d[MAX_V]; int cnt[MAX_V]; vector &amp;lt;Edge&amp;gt; edges; set &amp;lt;int&amp;gt; ring; // 紀錄負環 void bellman(int S){ fill(d, d + V, INF); d[S] = 0; // 因為邊的順序不一定, 所以負環不一定每輪都會被更新, 多跑幾次 for(int i = 0; i &amp;lt; V + 10; i++){ for(int j = 0; j &amp;lt; E; j++){ Edge e = edges[j]; if(d[e.from] + e.w &amp;lt; d[e.to]){ d[e.to] = d[e.from] + e.</description></item><item><title>大數運算</title><link>https://ptzu.github.io/posts/template-bigint/</link><pubDate>Tue, 24 Oct 2017 23:31:43 +0000</pubDate><guid>https://ptzu.github.io/posts/template-bigint/</guid><description>第三次寫大數了 在比賽裡面因為 JAVA 有內建大數 所以此類題目比較少出 不過刷題的時候還是會遇到
struct big{ vector &amp;lt;int&amp;gt; digit; big(){ } big(string s){ int len = s.length(); for(int i = 0; len - 1 - i &amp;gt;= 0; i++){ digit.push_back(s[len - 1 - i] - &amp;#39;0&amp;#39;); } } big operator +(const big&amp;amp; obj)const{ int carry = 0; int maxSize = max(digit.size(), obj.digit.size()), minSize = min(digit.size(), obj.digit.size()); big res; for(int i = 0; i &amp;lt; minSize; i++){ int num = digit[i] + obj.</description></item><item><title>Mod Inverse 模板</title><link>https://ptzu.github.io/posts/template-mod-inverse/</link><pubDate>Mon, 09 Oct 2017 08:30:52 +0000</pubDate><guid>https://ptzu.github.io/posts/template-mod-inverse/</guid><description>AC code int mod_inverse(int a, int m){ int x, y; // x 是所求 extgcd(a, m, x, y); return (m + x % m) % m; }</description></item><item><title>Dijkstra Algorithm</title><link>https://ptzu.github.io/posts/template-dijkstra/</link><pubDate>Sun, 01 Oct 2017 11:16:22 +0000</pubDate><guid>https://ptzu.github.io/posts/template-dijkstra/</guid><description>Code struct edge{ int to, w; }; int d[MAX_N]; vector &amp;lt;edge&amp;gt; g[MAX_N]; int dijkstra(int S){ priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; pq; //d, v fill(d, d + n, INF); d[S] = 0; pq.push((pii){0, S}); while(!pq.empty()){ pii top = pq.top(); pq.pop(); int u = top.nd; if(d[u] &amp;lt; top.st) continue; for(int i = 0; i &amp;lt; sz(g[u]); i++){ edge e = g[u][i]; if(d[u] + e.w &amp;lt; d[e.to]){ d[e.to] = d[u] + e.w; pq.</description></item><item><title>快速冪(FastPow) 模板</title><link>https://ptzu.github.io/posts/template-fastpow/</link><pubDate>Mon, 18 Sep 2017 01:06:00 +0000</pubDate><guid>https://ptzu.github.io/posts/template-fastpow/</guid><description>在 log(N) 時間內求取冪次方
code int fastpow(int a,int b) { int ans = 1,base = a; while(b!=0) { if(b&amp;amp;1) ans *= base; base *= base; b&amp;gt;&amp;gt;=1; } return ans; }</description></item><item><title>Eratosthenes 模板</title><link>https://ptzu.github.io/posts/template-eratosthenes/</link><pubDate>Sun, 17 Sep 2017 22:39:17 +0000</pubDate><guid>https://ptzu.github.io/posts/template-eratosthenes/</guid><description>求取小於 n 的質數
code const int MAX_N = 1e5; vector &amp;lt;int&amp;gt; prime; bool is_prime[MAX_N + 10]; int sieve(int n){ fill(is_prime, is_prime + n, true); is_prime[0] = is_prime[1] = false; for(int i = 2; i &amp;lt;= n; i++){ if(is_prime[i]){ //紀錄質數 prime.push_back(i); // 消除 i 的倍數 for(int j = i * 2; j &amp;lt;= n; j += i){ is_prime[j] = false; } } } return (int)prime.size(); }</description></item><item><title>Extgcd 模板</title><link>https://ptzu.github.io/posts/template-extgcd/</link><pubDate>Sun, 17 Sep 2017 15:23:05 +0000</pubDate><guid>https://ptzu.github.io/posts/template-extgcd/</guid><description>求取 ax + by = gcd(a, b) 此方程式之解 並回傳 gcd(a, b)
code int extgcd(int a, int b, int &amp;amp;x, int &amp;amp;y){ int d = a; if(b != 0){ d = extgcd(b, a % b, y, x); y -= (a / b) * x; } else{ x = 1; y = 0; } return d; }</description></item><item><title>LCS 模板</title><link>https://ptzu.github.io/posts/template-lcs/</link><pubDate>Thu, 16 Mar 2017 10:34:32 +0000</pubDate><guid>https://ptzu.github.io/posts/template-lcs/</guid><description>定義 dp[i][j]: s1&amp;hellip;si 和 t1&amp;hellip;tj 的最長共同子序列
string s1, s2; int dp[100][100]; int main(){ cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2; int len1 = s1.length(); int len2 = s2.length(); for(int i = 0; i &amp;lt; len1; i++){ for(int j = 0; j &amp;lt; len2; j++){ if(s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j] + 1; else dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]); } } cout &amp;lt;&amp;lt; dp[len1][len2] &amp;lt;&amp;lt; endl; return 0; }</description></item><item><title>二分搜</title><link>https://ptzu.github.io/posts/template-binary-search/</link><pubDate>Wed, 01 Mar 2017 00:13:45 +0000</pubDate><guid>https://ptzu.github.io/posts/template-binary-search/</guid><description>0, 1型 bool C(int x){ } int sol(){ int l = 0, u = N; if(C(l)) return l; if(!C(u)) return -1; while(u - l &amp;gt; 1){ int mid = (u + l) / 2; if(C(mid)) l = mid; else u = mid; } return u; } 1, 0型 bool C(int x){ } int sol(){ int l = 0, u = N; if(!C(l)) return -1; if(C(u)) return u; while(u - l &amp;gt; 1){ int mid = (u + l) / 2; if(C(mid)) u = mid; else l = mid; } return l; }</description></item><item><title>併查集 Disjoint set</title><link>https://ptzu.github.io/posts/template-dsu/</link><pubDate>Thu, 02 Feb 2017 18:22:18 +0000</pubDate><guid>https://ptzu.github.io/posts/template-dsu/</guid><description>code const int MAX_N = ...; struct Union_Find { int par[MAX_N], num[MAX_N]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U;</description></item></channel></rss>
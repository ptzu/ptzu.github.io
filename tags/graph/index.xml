<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Graph on Ptzu's blog</title><link>https://ptzu.github.io/tags/graph/</link><description>Recent content in Graph on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 12 Jan 2018 15:12:43 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>二分匹配</title><link>https://ptzu.github.io/posts/bipartite-matching/</link><pubDate>Fri, 12 Jan 2018 15:12:43 +0000</pubDate><guid>https://ptzu.github.io/posts/bipartite-matching/</guid><description>問題描述 給一張二分圖, 我們想要求取他的最大匹配 那什麼是匹配呢？ 匹配就是一個 &amp;ldquo;邊的集合&amp;rdquo; 裡面蒐集的邊有這個性質 &amp;ldquo;任兩條邊的端點必不相同&amp;rdquo; 我們想要的就是讓這個集合愈大愈好 而在二分圖上的最大匹配就是二分匹配
名詞解釋 匹配點, 非匹配點, 匹配邊, 非匹配邊: 最大匹配: 匹配邊數最多的匹配 完美匹配: 圖中的每一個點都是匹配點 交替路徑: 從未匹配點出發, 依序走未匹配邊, 匹配邊, 交錯下去的路徑 增廣路徑: 從未匹配點出發, 走交替路徑, 然後可以抵達另一個未匹配點的路徑
演算法過程 這裡介紹匈牙利演算法, 請搭配模版理解 一開始我們只要一遇到未匹配點, 那就將兩點匹配 接著從點3出發, 發現有一條增廣路徑 然後將剛剛那條路徑的顏色交換, 也就是非匹配邊和匹配邊互換身份 最後都沒有增廣路徑了, 結束演算法 匹配數 = 3
延伸主題 名詞 邊涵蓋: 一個邊集合 F, 使圖中的任意一點都至少與 F 的邊相連 點涵蓋: 一個點集合 S, 使圖中的任意一條邊都至少與 S 的點相連 獨立集合: 一個點集合 S, S 中的任意兩點在圖中都不相連 定理 對沒有孤立點的圖, |最大匹配| + |最小邊涵蓋| = |V| |最大獨立集合| + |最小點涵蓋| = |V| |最大匹配| = |最小點涵蓋| (König定理) 證明待補</description></item><item><title>POJ 2421 Constructing Roads</title><link>https://ptzu.github.io/posts/poj2421/</link><pubDate>Fri, 12 Jan 2018 13:11:08 +0000</pubDate><guid>https://ptzu.github.io/posts/poj2421/</guid><description>題目
input 第一行輸入正整數 N, 3 &amp;lt;= N &amp;lt;= 100 代表有 N 個村莊 接著輸入一個 N * N 的相鄰矩陣, 代表邊 然後輸入一個正整數 q 接著 q 行輸入 a, b 代表 a, b 之間已經有建好路
題解 建路需要成本, 已經有些路建好 求要連接所有村莊, 最小成本是多少？
作法 求 MST, 不過這題範圍比較小 所以我拿來測試 Sollin 演算法
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;climits&amp;gt;#include &amp;lt;cstring&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>POJ 3041 Asteroids</title><link>https://ptzu.github.io/posts/poj3041/</link><pubDate>Sat, 06 Jan 2018 11:24:59 +0000</pubDate><guid>https://ptzu.github.io/posts/poj3041/</guid><description>題目
input 第一列輸入兩個正整數 N, K, 代表 N * N 的地圖, 和 K 顆行星
題解 現在你有兩種武器, 分別可以射出橫的或直的射線 被射線射到的行星就會被摧毀 現有 k 顆行星 請問最少要幾次射線才能摧毀全部行星
作法 最小點涵蓋
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_V = 1010; int V; vector &amp;lt;int&amp;gt; g[MAX_V]; int match[MAX_V]; bool vis[MAX_V]; void add_edge(int u, int v){ g[u].</description></item><item><title>POJ 1258 Agri-Net</title><link>https://ptzu.github.io/posts/poj1258/</link><pubDate>Sun, 01 Oct 2017 17:01:36 +0000</pubDate><guid>https://ptzu.github.io/posts/poj1258/</guid><description>題目
input 含有多筆測資, 每筆測資開頭輸入一正整數 N, 3 &amp;lt;= N &amp;lt;= 100 代表有 N 個農場 接著輸入一個 N * N 的相鄰矩陣, 代表邊
題解 農夫 John 要在農場建立網路, 連接網路電纜需要成本 求連接所有農場的最小成本
作法 Kruskal 裸題
AC code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX struct Union_Find { int par[1010], num[1010]; void init(int n){ for(int i = 0; i &amp;lt; n; i++){ par[i] = i; num[i] = 1; } } int find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); } void unite(int a, int b){ a = find(a); b = find(b); if(a == b) return ; if(num[a] &amp;gt; num[b]) swap(a, b); par[a] = b; num[b] += num[a]; } }U; struct edge{ int u, v, w; bool operator &amp;lt;(const edge&amp;amp; e) const{ return w &amp;lt; e.</description></item><item><title>Uva 10986 - Sending email</title><link>https://ptzu.github.io/posts/uva10986/</link><pubDate>Sun, 01 Oct 2017 10:34:39 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10986/</guid><description>目錄 題目
題解 有 n 台 server, 之間用 cable 連結 每條 cable 有傳送延遲 請問從 server S to server T 最少需要多少時間？
作法 Dijkstra 裸題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) // #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX struct edge{ int to, w; }; int n, m, S, T; int d[20010]; vector &amp;lt;edge&amp;gt; g[20010]; int dijkstra(){ priority_queue &amp;lt;pii, vector&amp;lt;pii&amp;gt;, greater&amp;lt;pii&amp;gt; &amp;gt; pq; //d, v fill(d, d + n, INF); d[S] = 0; pq.</description></item></channel></rss>
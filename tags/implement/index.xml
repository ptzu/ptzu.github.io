<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Implement on Ptzu's blog</title><link>https://ptzu.github.io/tags/implement/</link><description>Recent content in Implement on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 Mar 2018 20:41:17 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/tags/implement/index.xml" rel="self" type="application/rss+xml"/><item><title>Uva 10056 - What is the Probability ?</title><link>https://ptzu.github.io/posts/uva10056/</link><pubDate>Thu, 08 Mar 2018 20:41:17 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10056/</guid><description>題目
input 第一列輸入 T (T &amp;lt;= 1000), 代表 T cases 每筆測資輸入 n, p, k 代表 n 個玩家, 抽到勝利的機率, 第 k 個玩家
題解 一群人在玩骰子, 非傳統骰子, 只要骰到某個數字他就贏 骰到某個數字的機率為 p, 求第 k 個人贏的機率
作法 模擬算機率 贏的機率為 p, 輸的機率為 1 - p = q 但由於沒有說要玩幾輪 所以不斷累加 全輸的機率 * 某一輪贏的機率 因為後面的機率已經太小了, 不會影響答案, 所以設個中斷點即可
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 10420 - List of Conquests</title><link>https://ptzu.github.io/posts/uva10420/</link><pubDate>Fri, 22 Dec 2017 13:22:06 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10420/</guid><description>題目
input 第一列有一正整數 n, n &amp;lt;= 2000 接下來有 n 列, 每列最多 75 字 每列第一個字為國家, 後面接著女生的名字
題解 統計每個國家有幾個人
作法 用 map 去對應國家和人數
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX map &amp;lt;string, int&amp;gt; mp; int main(){ fio; int n; cin &amp;gt;&amp;gt; n; string s, name; for(int i = 0; i &amp;lt; n; i++){ cin &amp;gt;&amp;gt; s; getline(cin, name); mp[s]++; } for(auto it : mp){ cout &amp;lt;&amp;lt; it.</description></item><item><title>Uva 10101 - Bangla Numbers</title><link>https://ptzu.github.io/posts/uva10101/</link><pubDate>Fri, 22 Dec 2017 12:56:33 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10101/</guid><description>題目
input 含多筆測資, 每筆測資輸入一個 long long 範圍內的非負整數
題解 把數字轉為題目規定的單位 kuti: 10000000 lakh: 100000 hajar: 1000 shata: 100 要注意的是, 單位前面的數字可能也可以轉為單位
作法 模擬
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX void print(ll n){ if(n &amp;gt;= 10000000){ print(n / 10000000); printf(&amp;#34; kuti&amp;#34;); n %= 10000000; } if(n &amp;gt;= 100000){ print(n / 100000); printf(&amp;#34; lakh&amp;#34;); n %= 100000; } if(n &amp;gt;= 1000){ print(n / 1000); printf(&amp;#34; hajar&amp;#34;); n %= 1000; } if(n &amp;gt;= 100){ print(n / 100); printf(&amp;#34; shata&amp;#34;); n %= 100; } if(n !</description></item><item><title>Uva 10929 - You can say 11</title><link>https://ptzu.github.io/posts/uva10929/</link><pubDate>Fri, 22 Dec 2017 12:18:32 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10929/</guid><description>題目
input 含多筆測資, 每筆測資為 1000 位數的數字, 輸入 0 為結束 注意數字可能有前綴 0 (卡這種東西真的很無聊, 題目又沒講)
題解 輸入一個數字, 判斷是否為 11 的倍數
作法 因為有 1000 位, 用字串來處理 (奇位數和 - 偶位數和) 是 11 的倍數的話, 該數可被 11 整除
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX char s[2000]; int main(){ while(scanf(&amp;#34;%s&amp;#34;, s) !</description></item><item><title>Uva 100 - The 3n + 1 problem</title><link>https://ptzu.github.io/posts/uva100/</link><pubDate>Fri, 22 Dec 2017 11:54:04 +0000</pubDate><guid>https://ptzu.github.io/posts/uva100/</guid><description>題目
input 多筆測資, 每筆測資含兩個正整數 a, b 0 &amp;lt; a, b &amp;lt; 1000000 (題目寫10000是錯的)
題解 目前有一個猜測還未被證實 給任意一個數 n, 如果是奇數就 n * 3 + 1, 否則就 n / 2 則最後一定會變成 1 則中間變化的過程稱為 cycle length(包含自己) 給 a, b 兩數, 求之間的數最大的 cycle length 注意變化過程在 32 bits integer內 所以要用 unsigned
作法 模擬
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 10035 - Primary Arithmetic</title><link>https://ptzu.github.io/posts/uva10035/</link><pubDate>Fri, 22 Dec 2017 11:00:09 +0000</pubDate><guid>https://ptzu.github.io/posts/uva10035/</guid><description>題目
input 多筆測資, 每筆輸入兩個 10 位的正整數 輸入 0 0 代表結束
題解 兩個數字相加, 求有幾次進位
作法 用大數加法去算有幾次進位
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX int main(){ fio; string s1, s2; while(cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2){ if(s1 == &amp;#34;0&amp;#34; &amp;amp;&amp;amp; s2 == &amp;#34;0&amp;#34;) break; if(s1.</description></item><item><title>Uva 12019 - Doom's Day Algorithm</title><link>https://ptzu.github.io/posts/uva12019/</link><pubDate>Mon, 18 Dec 2017 20:06:57 +0000</pubDate><guid>https://ptzu.github.io/posts/uva12019/</guid><description>題目
input 第一列有一正整數 N, 代表 test case 接著有 N 列測資, 每筆測資有 M, D, 代表月份和日期
題解 求出 2011年日期的星期
作法 先看 2011/1/1 是星期幾 然後記他的前一天是星期幾 之後在根據日期加上去, 7取餘數就是答案
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 1000000; int ZERO = 5; int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; string days[] = {&amp;#34;Sunday&amp;#34;, &amp;#34;Monday&amp;#34;, &amp;#34;Tuesday&amp;#34;, &amp;#34;Wednesday&amp;#34;, &amp;#34;Thursday&amp;#34;, &amp;#34;Friday&amp;#34;, &amp;#34;Saturday&amp;#34;}; int main(){ int n; while(scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !</description></item><item><title>Uva 275 - Expanding Fractions</title><link>https://ptzu.github.io/posts/uva275/</link><pubDate>Mon, 23 Oct 2017 17:16:18 +0000</pubDate><guid>https://ptzu.github.io/posts/uva275/</guid><description>題目
input a, b不超過1000
題解 找循環小數和其長度
作法 詳解請見 uva202
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int save[3030]; vector &amp;lt;int&amp;gt; res; void init(){ } int main(){ int a, b; while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a, &amp;amp;b) !</description></item><item><title>Uva 202 - Repeating Decimals</title><link>https://ptzu.github.io/posts/uva202/</link><pubDate>Sun, 22 Oct 2017 23:18:53 +0000</pubDate><guid>https://ptzu.github.io/posts/uva202/</guid><description>題目
input a, b 不超過3000
題解 求出 a / b 的循環小數以及其長度
作法 首先要知道的是, 在做除法時, 如果有個餘數重複出現過 則一定有循環小數。 a / b 的餘數會是 0 ~ b-1, 所以當計算到 b 次的時候 根據鴿籠原理, 一定會有個餘數重複, 所以有理數必有循環小數 我們只要模擬除法, 並用 save 陣列紀錄每個餘數的出現位置 若有出現過則找到循環小數, 並可以知道他的起始位置
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int save[3030]; vector &amp;lt;int&amp;gt; res; void init(){ } int main(){ int a, b; while(scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a, &amp;amp;b) !</description></item><item><title>Uva 1368 - DNA Consensus String</title><link>https://ptzu.github.io/posts/uva1368/</link><pubDate>Sun, 22 Oct 2017 19:49:35 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1368/</guid><description>題目
input m 個 DNA 序列長度 n 4 &amp;lt;= m &amp;lt;= 50, 4 &amp;lt;= n &amp;lt;= 1000
題解 定義 Hamming distance 為兩字串在同個 index, 有幾個字元不同 定義 Consensus error, 對於一個字串 y, 和字串集合 S, 他們之間的 Hamming distance 總和 而 Consensus error 最小的字串稱為 Consensus string 求 m 個序列中的 Consensus string 和他的 error
作法 要使每個字元的 error 最小, 那就找 m 個序列中 針對每個位置出現最多次的那個字元 若有多個符合的字串, 找到字典序最小的那個
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.</description></item><item><title>Uva 232 - Crossword Answers</title><link>https://ptzu.github.io/posts/uva232/</link><pubDate>Sun, 22 Oct 2017 18:16:39 +0000</pubDate><guid>https://ptzu.github.io/posts/uva232/</guid><description>題目
input 1 &amp;lt;= r,c &amp;lt;= 10
題解 給一個 r * c 的格子, 有黑白格, 黑格用 * 表示 一個白格的上方 or 右方若 &amp;lsquo;沒有格子&amp;rsquo; 或 &amp;lsquo;有黑色格子&amp;rsquo; 則稱該白格為 eligible 將所有 eligible 格子從左到右, 上到下依序編號 每個單字的開頭一定要放在 eligible 求 Across(橫向單字), Down(縱向單字) 有哪些
作法 題目非常長, 不過作法卻很簡單, 實作就好了
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 227 - Puzzle</title><link>https://ptzu.github.io/posts/uva227/</link><pubDate>Sun, 22 Oct 2017 12:49:12 +0000</pubDate><guid>https://ptzu.github.io/posts/uva227/</guid><description>題目
input 含多筆測資, 輸入 &amp;lsquo;Z&amp;rsquo; 代表測資結束 每筆測資輸入 5X5 方格的字母 接著輸入需要做的移動, 上下左右對應到 ABLR, 輸入 0 代表操作結束 注意操作可能有多行
PS: 5X5中的那個空格, 直接複製網站測資會沒有空格, 自行補上
題解 給一個 5X5 方格, 每個小方格都有一個字母, 但有一格是空的 針對那個空格, 有四種操作, 上下左右移動 如果有不合法的移動, 輸出 &amp;ldquo;This puzzle has no final configuration.&amp;rdquo; 否則輸出移動後的方格狀況
作法 方格移動題
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 455 - Periodic Strings</title><link>https://ptzu.github.io/posts/uva455/</link><pubDate>Sun, 22 Oct 2017 11:02:47 +0000</pubDate><guid>https://ptzu.github.io/posts/uva455/</guid><description>題目
input 最多 80 字元的字串
題解 求字串裏面最短的重複週期 例如: HoHoHo, 有 Ho 週期為 2 輸出2
作法 暴力法列舉不同子字串
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; void init(){ } int main(){ int TC, n; string s; scanf(&amp;#34;%d&amp;#34;, &amp;amp;TC); getline(cin, s); for(int tc = 0; tc &amp;lt; TC; tc++){ getline(cin, s); getline(cin, s); int len = s.</description></item><item><title>Uva 1585 - Score</title><link>https://ptzu.github.io/posts/uva1585/</link><pubDate>Sun, 22 Oct 2017 01:08:49 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1585/</guid><description>題目
input 給多行字串, 每行字串長度最多80
題解 一個字串含有 &amp;lsquo;O&amp;rsquo;, &amp;lsquo;X&amp;rsquo;, 分別代表該題目對或錯 該題的分數取決於是目前連續第幾個答對的 例如有 &amp;lsquo;OO&amp;rsquo;, 則第 1 題 1 分, 第 2 題 2 分 以此類推, 求全部拿多少分
作法 實作
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; void init(){ } int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 0; i &amp;lt; n; i++){ string s; cin &amp;gt;&amp;gt; s; int cnt = 0, ans = 0; for(int i = 0; i &amp;lt; s.</description></item><item><title>Uva 1584 - Circular Sequence</title><link>https://ptzu.github.io/posts/uva1584/</link><pubDate>Sat, 21 Oct 2017 22:43:09 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1584/</guid><description>題目
input 題解 作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX //const int MAX_N = 101010; int n; string s; void init(){ } bool cmp(int now, int ans){ for(int i = 0; i &amp;lt; s.</description></item><item><title>Uva 1583 - Digit Generator</title><link>https://ptzu.github.io/posts/uva1583/</link><pubDate>Sat, 21 Oct 2017 10:53:31 +0000</pubDate><guid>https://ptzu.github.io/posts/uva1583/</guid><description> 題目
input 1 &amp;lt;= n &amp;lt;= 100000
題解 給一個數字, 求他的最小生成元 例如: 256 = 245 + 2 + 4 + 5, 則 245 是 256 的生成元 一個數字可能有 0 個或多個生成元 求最小的
作法 先建表, 把每個數字可以生成的數字記起來 在根據輸入去查表
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX const int MAX_N = 101010; int ans[MAX_N]; void init(){ } int main(){ int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 1; i &amp;lt;= 100000; i++){ int tmp = i, sum = 0; while(tmp &amp;gt; 0){ sum += tmp % 10; tmp /= 10; } if(ans[i + sum] == 0) ans[i + sum] = i; } for(int i = 0; i &amp;lt; n; i++){ int x; scanf(&amp;#34;%d&amp;#34;, &amp;amp;x); printf(&amp;#34;%d\n&amp;#34;, ans[x]); } return 0; }</description></item><item><title>Uva 340 - Master-Mind Hints</title><link>https://ptzu.github.io/posts/uva340/</link><pubDate>Sat, 21 Oct 2017 10:30:23 +0000</pubDate><guid>https://ptzu.github.io/posts/uva340/</guid><description>題目
input 含多筆測資, 每筆測資開頭有一正整數 N, N &amp;lt;= 1000, 代表密碼的長度 第二列有N個1到9的數字，代表密碼 接著有多組猜測, 每組猜測為 N 個 1~9 的數字, 全為 0 代表猜測結束 N = 0 代表測資結束
題解 如果有猜中數字, 位置也對, 則會得到一個 A 若是有猜中數字, 但位置不對, 則會得到一個 B 輸出幾A幾B
作法 我們可以先計算, 到底有幾個數字被猜中了 也就是針對 1~9 取 min(在密碼出現的次數, 猜測出現的次數) 然後我們可以找出, 有幾個數字是在正確位置 猜中次數扣掉正確位置的, 剩餘的都是在不正確位置, 也就是 B
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.</description></item><item><title>Uva 401 - Palindromes</title><link>https://ptzu.github.io/posts/uva401/</link><pubDate>Fri, 20 Oct 2017 23:15:53 +0000</pubDate><guid>https://ptzu.github.io/posts/uva401/</guid><description>題目
input 給多行字串
題解 迴文字串定義：從左邊或右邊讀過來都長一樣 鏡像字串定義：以字型來看, 他是左右對稱的
作法 AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair &amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define sz(a) (int)a.size() #define INF 0x3f3f3f3f #define st first #define nd second #define fio ios::sync_with_stdio(false), cin.tie(0) #define DEBUG(x) printf(&amp;#34;Here: %d\n&amp;#34;, x), exit(0); // LLONG_MIN LLONG_MAX INT_MIN INT_MAX map &amp;lt;char, char&amp;gt; mp; void init(){ } int main(){ string s; char s1[] = {&amp;#39;A&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;8&amp;#39;}; char s2[] = {&amp;#39;A&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;H&amp;#39;, &amp;#39;I&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;J&amp;#39;, &amp;#39;M&amp;#39;, &amp;#39;O&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;T&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;V&amp;#39;, &amp;#39;W&amp;#39;, &amp;#39;X&amp;#39;, &amp;#39;Y&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;Z&amp;#39;, &amp;#39;8&amp;#39;}; int len = strlen(s1); for(int i = 0; i &amp;lt; len; i++) mp[s1[i]] = s2[i]; while(cin &amp;gt;&amp;gt; s){ string tmp = s; reverse(tmp.</description></item></channel></rss>
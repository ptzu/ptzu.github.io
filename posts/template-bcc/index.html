<!doctype html><html lang=en-us><head><title>雙連通單元 BCC // Ptzu's blog</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.81.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Roger Lin"><meta name=description content><link rel=stylesheet href=https://ptzu.github.io/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><meta name=twitter:card content="summary"><meta name=twitter:title content="雙連通單元 BCC"><meta name=twitter:description content="在一個無向圖中 若任兩點, 存在&#34;兩條點不重複路徑&#34;, 則稱此圖為 點-雙連通 而點-雙連通內部沒有割點 若任兩點, 存在&#34;兩條邊不重複路徑&#34;, 則稱此圖為 邊-雙連通
點-雙連通的最大子圖稱為雙連通單元(分量)
點-雙連通單元 性質:
 條件: low[v] >= dfn 割點可以屬於多個連通單元 任兩個連通單元的共同點最多一個, 也就是割點 連通單元內不會有割點 可順便求割點  這在網路上有兩種寫法 一種是在 stack 存點, 另一種存邊 由於割點可以屬於多個單元, 所以在 pop 時, 不能將割點 pop 出去 而這份 code, 不會將割點 pop 出去, 但有個副作用是 root 會留在 stack 多筆測資使用要小心
存邊的寫法有空再來理解
存點 Code // 割點的 bccid 沒有意義 const int MAX_V = ...; int V, E; vector <int> g[MAX_V], bcc[MAX_V]; int dfn[MAX_V], low[MAX_V], tot, bccid[MAX_V], bcc_cnt; bool cut[MAX_V]; stack <int> S; void dfs(int x, int fa){ int child = 0; dfn[x] = low[x] = ++tot; S."><meta property="og:title" content="雙連通單元 BCC"><meta property="og:description" content="在一個無向圖中 若任兩點, 存在&#34;兩條點不重複路徑&#34;, 則稱此圖為 點-雙連通 而點-雙連通內部沒有割點 若任兩點, 存在&#34;兩條邊不重複路徑&#34;, 則稱此圖為 邊-雙連通
點-雙連通的最大子圖稱為雙連通單元(分量)
點-雙連通單元 性質:
 條件: low[v] >= dfn 割點可以屬於多個連通單元 任兩個連通單元的共同點最多一個, 也就是割點 連通單元內不會有割點 可順便求割點  這在網路上有兩種寫法 一種是在 stack 存點, 另一種存邊 由於割點可以屬於多個單元, 所以在 pop 時, 不能將割點 pop 出去 而這份 code, 不會將割點 pop 出去, 但有個副作用是 root 會留在 stack 多筆測資使用要小心
存邊的寫法有空再來理解
存點 Code // 割點的 bccid 沒有意義 const int MAX_V = ...; int V, E; vector <int> g[MAX_V], bcc[MAX_V]; int dfn[MAX_V], low[MAX_V], tot, bccid[MAX_V], bcc_cnt; bool cut[MAX_V]; stack <int> S; void dfs(int x, int fa){ int child = 0; dfn[x] = low[x] = ++tot; S."><meta property="og:type" content="article"><meta property="og:url" content="https://ptzu.github.io/posts/template-bcc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-04T19:30:28+00:00"><meta property="article:modified_time" content="2018-03-04T19:30:28+00:00"></head><body><header class=app-header><a href=https://ptzu.github.io/><img class=app-header-avatar src=/avatar.jpg alt="Roger Lin"></a><h1>Ptzu's blog</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>Record of My Life.</p><div class=app-header-social><a href=https://github.com/ptzu target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>My Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>雙連通單元 BCC</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Mar 4, 2018</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://ptzu.github.io/tags/template/>Template</a></div></div></header><div class=post-content><p>在一個無向圖中
若任兩點, 存在"兩條點不重複路徑", 則稱此圖為 點-雙連通
而點-雙連通內部沒有割點
若任兩點, 存在"兩條邊不重複路徑", 則稱此圖為 邊-雙連通</p><p>點-雙連通的最大子圖稱為雙連通單元(分量)</p><h1 id=點-雙連通單元>點-雙連通單元</h1><p>性質:</p><ol><li>條件: low[v] >= dfn<input checked disabled type=checkbox></li><li>割點可以屬於多個連通單元</li><li>任兩個連通單元的共同點最多一個, 也就是割點</li><li>連通單元內不會有割點</li><li>可順便求割點</li></ol><p>這在網路上有兩種寫法
一種是在 stack 存點, 另一種存邊
由於割點可以屬於多個單元, 所以在 pop 時, 不能將割點 pop 出去
而這份 code, 不會將割點 pop 出去, 但有個副作用是 root 會留在 stack
多筆測資使用要小心</p><p>存邊的寫法有空再來理解</p><h2 id=存點-code>存點 Code</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// 割點的 bccid 沒有意義
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAX_V <span style=color:#f92672>=</span> ...;
<span style=color:#66d9ef>int</span> V, E;
vector <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> g[MAX_V], bcc[MAX_V];
<span style=color:#66d9ef>int</span> dfn[MAX_V], low[MAX_V], tot, bccid[MAX_V], bcc_cnt;
<span style=color:#66d9ef>bool</span> cut[MAX_V];
stack <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> S;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> fa){
    <span style=color:#66d9ef>int</span> child <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    dfn[x] <span style=color:#f92672>=</span> low[x] <span style=color:#f92672>=</span> <span style=color:#f92672>++</span>tot;
    S.push(x);
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> sz(g[x]); i<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> g[x][i];
        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>dfn[v]){
            dfs(v, x);
            child<span style=color:#f92672>++</span>;
            low[x] <span style=color:#f92672>=</span> min(low[x], low[v]);
            <span style=color:#66d9ef>if</span>(low[v] <span style=color:#f92672>&gt;=</span> dfn[x]){
                cut[x] <span style=color:#f92672>=</span> true;
                bcc[bcc_cnt].clear();
                <span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>){
                    <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> S.top(); S.pop();
                    bccid[u] <span style=color:#f92672>=</span> bcc_cnt;
                    bcc[bcc_cnt].pb(u);
                    <span style=color:#66d9ef>if</span>(u <span style=color:#f92672>==</span> v) <span style=color:#66d9ef>break</span>;
                }
                bccid[x] <span style=color:#f92672>=</span> bcc_cnt; <span style=color:#75715e>// 沒有意義
</span><span style=color:#75715e></span>                bcc[bcc_cnt].pb(x);
                bcc_cnt<span style=color:#f92672>++</span>;
            }
        }
        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(dfn[v] <span style=color:#f92672>&lt;</span> dfn[x] <span style=color:#f92672>&amp;&amp;</span> v <span style=color:#f92672>!=</span> fa){ <span style=color:#75715e>// 反向邊
</span><span style=color:#75715e></span>            low[x] <span style=color:#f92672>=</span> min(low[x], dfn[v]);
        }
    }
    <span style=color:#75715e>// 樹根
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(fa <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> child <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) cut[x] <span style=color:#f92672>=</span> false;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bcc_tarjan</span>(){
    bcc_cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>dfn[i]) dfs(i, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
    }
}
</code></pre></div><h1 id=邊-雙連通分量>邊-雙連通分量</h1><p>性質:</p><ol><li>條件: low[v] > dfn<input checked disabled type=checkbox></li><li>連通單元之間沒有共同點, 可以安心 pop</li><li>橋即為連通單元之間的連結, 因此拔掉橋, 就得到各個連通單元</li><li>連通單元內沒有橋</li><li>可順便求橋</li></ol><p>我有試過用上面的 code, 改一下條件
不過答案會錯
因此就改寫法了</p><h2 id=code>Code</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAX_V <span style=color:#f92672>=</span> ...;
<span style=color:#66d9ef>int</span> V, E;
vector <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> g[MAX_V], bcc[MAX_V];
<span style=color:#66d9ef>int</span> dfn[MAX_V], low[MAX_V], tot, bccid[MAX_V], bcc_cnt;
stack <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> S;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> fa){
    <span style=color:#66d9ef>int</span> child <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    dfn[x] <span style=color:#f92672>=</span> low[x] <span style=color:#f92672>=</span> <span style=color:#f92672>++</span>tot;
    S.push(x);
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> sz(g[x]); i<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> g[x][i];
        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>dfn[v]){
            dfs(v, x);
            child<span style=color:#f92672>++</span>;
            low[x] <span style=color:#f92672>=</span> min(low[x], low[v]);
            <span style=color:#66d9ef>if</span>(low[v] <span style=color:#f92672>&gt;</span> dfn[x]){
                ...<span style=color:#960050;background-color:#1e0010>存橋</span>
            }
        }
        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(dfn[v] <span style=color:#f92672>&lt;</span> dfn[x] <span style=color:#f92672>&amp;&amp;</span> v <span style=color:#f92672>!=</span> fa){ <span style=color:#75715e>// 反向邊
</span><span style=color:#75715e></span>            low[x] <span style=color:#f92672>=</span> min(low[x], dfn[v]);
        }
    }
    <span style=color:#66d9ef>if</span>(dfn[x] <span style=color:#f92672>==</span> low[x]){ <span style=color:#75715e>// 不會走到祖先, 因此整團為一個單元
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>){
            <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> S.top(); S.pop();
            bccid[v] <span style=color:#f92672>=</span> bcc_cnt;
            bcc[bcc_cnt].pb(v);
            <span style=color:#66d9ef>if</span>(v <span style=color:#f92672>==</span> x) <span style=color:#66d9ef>break</span>;
        }
        bcc_cnt<span style=color:#f92672>++</span>;
    }
}
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bcc_tarjan</span>(){
    bcc_cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> V; i<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>dfn[i]) dfs(i, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
    }
}
</code></pre></div><h1 id=構造-邊-雙連通單元>構造 邊-雙連通單元</h1><p>若一張圖有橋, 該怎麼把整張圖變成 邊-雙連通單元呢？
首先將連通單元求出, 縮點後
需要加的邊為: (度數為 1 的點) + 1 / 2
可參考 POJ 3352</p><h1 id=例題>例題</h1><ol><li>POJ 1144(求割點)</li><li>POJ 3352(邊-雙連通單元)</li></ol><h1 id=參考>參考</h1><ol><li><a href=https://www.zhihu.com/question/40746887>https://www.zhihu.com/question/40746887</a></li><li><a href=https://www.byvoid.com/zht/blog/biconnect>https://www.byvoid.com/zht/blog/biconnect</a></li></ol></div><div class=post-footer></div></article></main></body></html>
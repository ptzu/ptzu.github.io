<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ptzu's blog</title><link>https://ptzu.github.io/</link><description>Recent content on Ptzu's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 11 Sep 2018 21:25:58 +0000</lastBuildDate><atom:link href="https://ptzu.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>藍芽鍵盤於 Windows 和 Ubuntu 雙系統之配對與開機</title><link>https://ptzu.github.io/posts/bluetooth-keyboard-dual-boot-ubuntu/</link><pubDate>Tue, 11 Sep 2018 21:25:58 +0000</pubDate><guid>https://ptzu.github.io/posts/bluetooth-keyboard-dual-boot-ubuntu/</guid><description>前言 最近組了一台新電腦放到交大宿舍 不過位置有點小 所以採用了無線滑鼠和鍵盤 其中鍵盤是 Logitech K810 藍芽 其實如果都選 2.4GHz 的接收器鍵鼠, 就沒有這篇了ＸＤ 但是 K810 的造型實在太生火了 所以還是買了下去 這篇主要解決了以下問題:
藍芽鍵盤無法在開機選單選擇系統 藍芽在切換系統後需要重新配對 切換系統後時間不一致 藍芽於 BIOS 由於藍芽必須在系統啟動後才能配對 所以在 BIOS 階段是無法使用的ＱＱ 在我的搜尋下有兩個解法 一是將 Ubuntu grub 改成可以用滑鼠選擇 這裡我找到了 Gujin bootloader 號稱 mouse support 的開機選單 不過套件有點久遠, 又一直 build 不起來 只好放棄了 二是使用 EasyBCD 替 Windows 製作多系統開機選單 這個流程是已經載入 Windows 了 所以可以使用藍芽鍵鼠進行選擇
系統背景 我的雙系統都是以 MBR 格式安裝的 並用 BIOS(Lagacy) 啟動 若是用 UEFI 的話不確定能否使用
還原 Windows bootloader 首先我是先安裝 Windows 再裝 Ubuntu Windows 的 bootloader 在 MBR 磁區會被蓋掉 所以我們開機的時候會是 grub 但是因為找不到 grub 的解法ＸＤ 所以我們必須再把 grub 蓋掉 這部分我們可以到 Windows 安裝畫面(CD or USB) 然後按修復電腦 -&amp;gt; 使用命令提示字元 接著切換到開機的磁區(C槽) 輸入指令</description></item><item><title>相機座標系、世界座標系</title><link>https://ptzu.github.io/posts/camera-frame-world-frame/</link><pubDate>Wed, 08 Aug 2018 23:15:18 +0000</pubDate><guid>https://ptzu.github.io/posts/camera-frame-world-frame/</guid><description>最近在讀 SLAM 相關 paper 時 常看到 camera/world frame 我原本想說是和 keyframe 類似的東西 結果是完全不同的東西呀～ 這邊指的是座標系(雖然我還是不知道為什麼要用frame)
順手整理一下相機的相關座標轉換 相機模型中主要有四個平面座標系:
畫素平面座標系（u,v): 圖像在像素中的位置 像平面座標系 (影像物理座標（x,y)): 以相機主點為原點，場景點在圖像平面上的投影座標。 相機座標系（Xc,Yc,Zc): 以相機為中心的三維座標。 世界座標系（Xw,Yw,Zw): 絕對座標系統中的三維座標。 當我們能將這四個座標軸作轉換, 那麼就能從二維影像得知在三維世界中的位置
畫素平面 &amp;lt;=&amp;gt; 像平面 因為畫素不能反映圖像真實尺寸 像平面可以想成是一張二維影像 只是被縮小成像素大小(物理層面) 畫素單位是 pixel(微米大小), 而像平面單位是 mm
假設畫素座標為 {%math%}(u, v, 1)^{T}{%endmath%} (這邊用的是齊次座標, 當成是(u, v)就好了) 像平面座標 {%math%}(x, y){%endmath%} 每個像素的真實尺寸為 dx * dy
我們以圖像中心當作像平面座標的原點 {%math%}(u_{0}, v_{0}){%endmath%} 所以: {%math%}\left{\begin{matrix} u=\frac{x}{dx}+u_{0}\ v=\frac{y}{dy}+v_{0} \end{matrix}\right.{%endmath%} {%math%}\left{\begin{matrix} x=udx-u_{0}dx\ y=udy-u_{0}dy \end{matrix}\right.{%endmath%}
若以矩陣來表示: {%math%}\begin{bmatrix} u\ v\ 1 \end{bmatrix} \begin{bmatrix} \frac{1}{dx} &amp;amp; 0 &amp;amp; u_{0}\ 0&amp;amp; \frac{1}{dy} &amp;amp; v_{0}\ 0&amp;amp; 0 &amp;amp; 1 \end{bmatrix}\begin{bmatrix} x\ y\ 1 \end{bmatrix}{%endmath%}</description></item><item><title>二分匹配</title><link>https://ptzu.github.io/posts/bipartite-matching/</link><pubDate>Fri, 12 Jan 2018 15:12:43 +0000</pubDate><guid>https://ptzu.github.io/posts/bipartite-matching/</guid><description>問題描述 給一張二分圖, 我們想要求取他的最大匹配 那什麼是匹配呢？ 匹配就是一個 &amp;ldquo;邊的集合&amp;rdquo; 裡面蒐集的邊有這個性質 &amp;ldquo;任兩條邊的端點必不相同&amp;rdquo; 我們想要的就是讓這個集合愈大愈好 而在二分圖上的最大匹配就是二分匹配
名詞解釋 匹配點, 非匹配點, 匹配邊, 非匹配邊: 最大匹配: 匹配邊數最多的匹配 完美匹配: 圖中的每一個點都是匹配點 交替路徑: 從未匹配點出發, 依序走未匹配邊, 匹配邊, 交錯下去的路徑 增廣路徑: 從未匹配點出發, 走交替路徑, 然後可以抵達另一個未匹配點的路徑
演算法過程 這裡介紹匈牙利演算法, 請搭配模版理解 一開始我們只要一遇到未匹配點, 那就將兩點匹配 接著從點3出發, 發現有一條增廣路徑 然後將剛剛那條路徑的顏色交換, 也就是非匹配邊和匹配邊互換身份 最後都沒有增廣路徑了, 結束演算法 匹配數 = 3
延伸主題 名詞 邊涵蓋: 一個邊集合 F, 使圖中的任意一點都至少與 F 的邊相連 點涵蓋: 一個點集合 S, 使圖中的任意一條邊都至少與 S 的點相連 獨立集合: 一個點集合 S, S 中的任意兩點在圖中都不相連 定理 對沒有孤立點的圖, |最大匹配| + |最小邊涵蓋| = |V| |最大獨立集合| + |最小點涵蓋| = |V| |最大匹配| = |最小點涵蓋| (König定理) 證明待補</description></item><item><title>BSGS 演算法</title><link>https://ptzu.github.io/posts/bsgs-algorithm/</link><pubDate>Sat, 28 Oct 2017 13:25:28 +0000</pubDate><guid>https://ptzu.github.io/posts/bsgs-algorithm/</guid><description>BSGS 原名Baby Steps Giant Steps，又名大小步算法 用途是用來解離散對數, {% math %} a^{x}\equiv b\left( mod\ p\right) {% endmath %} 求最小 x 的解
步驟為
令 {% math %} x=im-j {% endmath %} {% math %} m = \left \lceil \sqrt{p} \right \rceil {% endmath %} {% math %} a^{im-j} \equiv b(mod\ p) {% endmath %} 移項 {% math %} a^{im} \equiv a^{j}b(mod\ p) {% endmath %} 對於 {% math %} a^{j}b {% endmath %} 列舉 0 ~ m 存起來 再對於 {% math %} a^{im} {% endmath %} 列舉 1 ~ m 對於第一個符合方程式的 i, j 即為所求, 代回去可得到 x 問題與證明 何時無解？ 有解必須滿足費馬小定理, p 為質數, 且 gcd(a, p) = 1</description></item><item><title>關於 '\n' 的各種輸入</title><link>https://ptzu.github.io/posts/aboutnewline/</link><pubDate>Sun, 22 Oct 2017 10:20:09 +0000</pubDate><guid>https://ptzu.github.io/posts/aboutnewline/</guid><description>在 C/C++ 輸入字串的時候 輸入一個整數 n, 接著讀取 n 個字串 常常會發生下面這種問題
咦！！我的第 5 行勒？？ 不用懷疑, 絕對不是你的電腦壞掉, 而是你不夠了解程式內部的細節 事實上, 當我們每按一次 enter(換行) 的時候 他其實是輸入換行符號 在 Windows 上是 CR+LF, 在 Linux 上是 LF(也就是'\n'), 在 MAC OS 上是 CR 所以當我們進行輸入的時候, 資料會先被放在 buffer(暫存區) 而像 scanf 這些 input 函數會去 buffer 將資料讀取到記憶體 所以當 scanf 讀取一個數字時, 其實有個 &amp;lsquo;\n&amp;rsquo; 被遺留在 buffer 就像如此: 而這個時候 fgets 讀取就會讀到 &amp;lsquo;\n&amp;rsquo;, 理所當然的就少一行資料
以下就來分析各種 input 函數對於 &amp;lsquo;\n&amp;rsquo; 的處理方式
scanf(&amp;quot;%s&amp;quot;) 遇到 &amp;lsquo;\n&amp;rsquo; 就中止, 不讀入 &amp;lsquo;\n&amp;rsquo; fgets 遇到 &amp;lsquo;\n&amp;rsquo; 就中止, 讀入 &amp;lsquo;\n&amp;rsquo;, 會放到子串裡面 cin &amp;raquo; s 遇到 &amp;lsquo;\n&amp;rsquo; 就中止, 不讀入 &amp;lsquo;\n&amp;rsquo; getline 遇到 &amp;lsquo;\n&amp;rsquo; 就中止, 讀入 &amp;lsquo;\n&amp;rsquo;, 不會放到子串裡面 scanf(&amp;quot;%d\n&amp;quot;) 其實 scanf 是一個匹配函數, 甚至好幾個 &amp;lsquo;\n&amp;rsquo; 都被處理掉了 看完以上的例子, 應該會更清楚要怎麼處理這種 input 了！</description></item><item><title>大數取 MOD</title><link>https://ptzu.github.io/posts/bigint-mod/</link><pubDate>Mon, 09 Oct 2017 08:40:40 +0000</pubDate><guid>https://ptzu.github.io/posts/bigint-mod/</guid><description>Code ll getMod(string s, ll mod){ ll r = 0; for(char c : s) r = (r * 10 + c - &amp;#39;0&amp;#39;) % mod; return r; }</description></item><item><title>不使用 JQuery 達到 Ajax 上傳表單</title><link>https://ptzu.github.io/posts/ajax-form/</link><pubDate>Sat, 20 May 2017 13:19:55 +0000</pubDate><guid>https://ptzu.github.io/posts/ajax-form/</guid><description>這篇不介紹使用 JQuery 的 Ajax 而是利用 XMLHttpRequest(xhr) 來做到相同的效果 首先是 Ajax 的 Javascript 語法 xmlhttp.open(方法, 請求對象, true)
GET 例子 var xmlhttp = new XMLHttpRequest(); xml.http.open(&amp;#34;GET&amp;#34;, XXX.php, true); xmlhttp.onreadystatechange=function check_user() { if(xmlhttp.readyState == 4) { if(xmlhttp.status == 200) { ... } } } xml.send(null); 如果想帶參數, 在請求對象那邊可以改成 XXX.php?arg1=val1&amp;amp;&amp;amp;arg2=val2 然後在對象那邊用 $_GET[&amp;lsquo;arg1&amp;rsquo;], $_GET[&amp;lsquo;arg2&amp;rsquo;] 來取得
POST 例子 待測試
var xmlhttp = new XMLHttpRequest(); xml.http.open(&amp;#34;POST&amp;#34;, XXX.php, true); xmlhttp.onreadystatechange=function check_user() { if(xmlhttp.readyState == 4) { if(xmlhttp.status == 200) { .</description></item><item><title>Codeforces Beta Round 93 (Div. 1 Only)</title><link>https://ptzu.github.io/posts/cf93/</link><pubDate>Mon, 01 Aug 2016 21:10:58 +0000</pubDate><guid>https://ptzu.github.io/posts/cf93/</guid><description>B. Password # string 題目
題解 給一字串 尋找是否有一子字串 出現在前綴(開頭), 中間, 以及後綴 輸出符合條件的最長子字串 如果沒有就輸出 Just a legend
作法 字串搜尋類型的題目 暴力搜尋會花上 O(nm) 的時間 為了這題, 又去重新理解一次KMP 果然這東西還是很難記住啊~~
這題有兩種作法
用failure function 的特性 用rolling hash(尚未研究) 如果還不懂何謂KMP 先去看看演算法教學吧~~ &amp;mdash;-以下開始&amp;mdash;- 當建好 f 函數時 把所有有匹配到的字元, 做上標記(不標記最後一字元) 然後看字串最後一個字元的 f 函數值是多少 假如前綴和後綴都有, 那我們就要來看中間是否有出現過啦 作法就是以最後一字元的函數值做回溯
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; typedef vector &amp;lt;ll&amp;gt; vec; typedef vector &amp;lt;vec&amp;gt; mat; #define pb push_back #define pf push_front #define mp make_pair #define sz(a) (int)a.</description></item><item><title>Codeforces Beta Round 89 (Div. 2) (not finished)</title><link>https://ptzu.github.io/posts/cf89/</link><pubDate>Fri, 15 Jul 2016 16:34:29 +0000</pubDate><guid>https://ptzu.github.io/posts/cf89/</guid><description>D. Caesar&amp;rsquo;s Legions 題目
題解 給 n1, n2, k1, k2 現有一排軍隊, n1 個步兵, n2個騎兵 步兵不能連續站在一起超過 k1 個, 騎兵不能超過 k2 個 求有多少種排法符合條件
作法 一開始想到的DP定義 dp[i][j][k] : i 位士兵, 最後一串連續的士兵為 j: 0 是步兵, 1 是騎兵, 連續的長度為k
但這樣會有個問題,用了 i 位士兵,無法判定那兩種士兵各用了幾位(可能會超過(n1 or n2)
所以改成 dp[i][j][k][l] : i, j 分別代表步兵和騎兵各有幾位 其他定義相同
答案為dp[n1][n2][0][1~k1] + dp[n1][n2][1][1~k2] 總和 % 100000000
DP遞迴 if(連續長度 &amp;gt; 1) //直接補上一個數字,方法數等同前一長度的方法數 dp[i][j][k][l] = dp[i][j][k][l - 1] else if(連續長度 == 1) //選擇另一種士兵,連續長度為 1 &amp;lt;= s &amp;lt;= (k1 or k2)的總和, 要注意 s 不能超過 i 或 j, 不然會多算 dp[i][j][k][l] = sum(dp[i][j][!</description></item><item><title>Codeforces Round 340 (Div. 2)</title><link>https://ptzu.github.io/posts/cf340/</link><pubDate>Sat, 28 May 2016 23:48:37 +0000</pubDate><guid>https://ptzu.github.io/posts/cf340/</guid><description>A. Elephant 題目
題解 簡單題 一次可走 1~5 求到終點最少要走幾次
作法 終點座標除以 5 再看是否整除
AC code #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; typedef pair&amp;lt;int,int&amp;gt; pii; typedef long long ll; #define pb push_back #define pf push_front #define make_pair mp #define sz(a) (int)a.size() #define i128 __int128 #define INF 0x3f3f3f3f // LLONG_MIN LLONG_MaX INT_MIN INT_MaX int main(){ int x; cin &amp;gt;&amp;gt; x; int ans = x / 5; if(x % 5 != 0) ans++; cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0; } B.</description></item></channel></rss>